<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>兜的破烂</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="兜的破烂">
<meta property="og:url" content="https://mhh12121.github.io/index.html">
<meta property="og:site_name" content="兜的破烂">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="兜的破烂">
  
    <link rel="alternate" href="/atom.xml" title="兜的破烂" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">兜的破烂</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">学习☆记录</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://mhh12121.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Comcon/somethingAboutTcp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/02/Comcon/somethingAboutTcp/" class="article-date">
  <time datetime="2019-07-02T07:01:00.000Z" itemprop="datePublished">2019-07-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/02/Comcon/somethingAboutTcp/">Something about Networking</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3>为什么多个tcp连接会比单个tcp连接快？（tmd面试傻了，居然没答出来这个）</h3>
<p>一开始看见，这不是显而易见的吗？？？</p>
<p>后来发现，其实他想听到的答案是：</p>
<ol>
<li>tcp的流量窗口（拥塞控制）
如下图：
<img src="/img/tcpWindow.jpg" alt="tcpwindow">盗图
绿色为 发送者发送，且接收者acked
黄色为 发送者发送，接收者未确认（in-flight）
蓝色为 可用但为发送</li>
</ol>
<p>cwnd= width（in-flight）+width（not sent）</p>
<p>发送速率：
<strong>rate = cwnd / RTT byte/sec</strong>
即发送速率在RTT（往返时延）一定的情况下，只受cwnd影响</p>
<ol start="2">
<li>慢启动</li>
</ol>
<p>tcp会进行<strong>慢启动</strong>直到丢包,每接到一个ack就会把窗口（cwnd）×2，当出现丢包的，有以下两种状况：</p>
<ol>
<li>接收者发送给发送者的ACK丢失，会导致 timeout</li>
<li>发送者发送给接收者的数据丢失，发送者会收到接受者的重复ACK，如果收到三个重复的ACK，可以确认为丢包</li>
</ol>
<ol start="3">
<li>路由器（多个TCP有拥塞控制）
给出带宽为R，有K个连接经过
最后每个连接平均分的都会是 R/K</li>
</ol>
<p>终上：</p>
<p>一个tcp连接很可能不能把当前路由的带宽都用完（），所以要多个tcp连接，这样才能最大保证速率</p>
<h3>总结</h3>
<p>回答问题，要从特么原理开始一步步推导来說，不能想当然</p>
<h3>各种握手挥手（我求求我自己把这些gdx记得滚瓜烂熟，每次都漏一点）</h3>
<p>TCP连接</p>
<ol start="3">
<li>DNS协议</li>
</ol>
<p>首先这🐔是<strong>应用层</strong>协议！！！
:smile:</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mhh12121.github.io/2019/07/02/Comcon/somethingAboutTcp/" data-id="cjxmwz4sw000faeugkc4f6v0t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/networking/">networking</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Go/gRPC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/29/Go/gRPC/" class="article-date">
  <time datetime="2019-06-29T06:40:00.000Z" itemprop="datePublished">2019-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/29/Go/gRPC/">Something in gRPC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>常用的rpc框架，我们先从它的proto开始了解吧</p>
<p>我们这里只讨论go语法，语言方面其他都是大同小异</p>
<h2>proto</h2>
<p>创建proto文件 <strong>data.proto</strong>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto2"</span>;</span><br><span class="line"></span><br><span class="line">service Authenticate&#123;</span><br><span class="line">	rpc login(toServerData) returns (ResponseFromServer)&#123;&#125;</span><br><span class="line">	rpc home(toServerData) returns(ResponseFromServer)&#123;&#125;</span><br><span class="line">	rpc logout(toServerData) returns(ResponseFromServer)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message toServerData&#123;</span><br><span class="line">    required <span class="keyword">int32</span> ctype = <span class="number">1</span>;</span><br><span class="line">    optional bytes httpdata=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">message ResponseFromServer &#123;</span><br><span class="line">	required <span class="keyword">bool</span> Success=<span class="number">1</span>;</span><br><span class="line">	optional bytes tcpData=<span class="number">2</span>;</span><br><span class="line">	<span class="comment">// Errcode int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用安装的protoc插件生成
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=/mypath --go_out=plugins=grpc:. *.proto //当前在mypath路径下，用grpc模式生成proto文件</span><br></pre></td></tr></table></figure></p>
<p>生成 <strong>data.pb.proto</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mhh12121.github.io/2019/06/29/Go/gRPC/" data-id="cjxmwz4t8000qaeug3ij9grd1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ToMyLover" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/26/ToMyLover/" class="article-date">
  <time datetime="2019-06-26T03:40:00.000Z" itemprop="datePublished">2019-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/26/ToMyLover/">To my lover</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>I was looking for something until met you,
So I found the whole world</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mhh12121.github.io/2019/06/26/ToMyLover/" data-id="cjxmwz4s50004aeugou5vl66n" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Love/">Love</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Go/Context" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/21/Go/Context/" class="article-date">
  <time datetime="2019-06-21T03:40:00.000Z" itemprop="datePublished">2019-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/21/Go/Context/">Golang Context</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Golang出色的协程为其增添不少色彩，而Context在协程间的协作，同步发挥了很大的作用
&lt;!--more--&gt;</p>
<p><img src="/img/golangContextMascot.jpg" alt="Context"></p>
<h2>作用</h2>
<p>开头已经说道，Context主要用于在goroutine之间传递上下文信息，而这些信息包括key-value pair，cancel信号，timeout信号等
http包，sql包里面都用到了context，比如http包里面，API可以由外部执行cancel操作，可以设置timeout信号来cancel
http请求服务如果过慢，则可以用timeout进行释放资源
举例：获取商品的默认库存数量等</p>
<p><strong><em>参考 go在今日头条的实践</em></strong></p>
<p>另外，之前的<img src="/Concurrency" alt="Concurrency"> 有谈到协程之前如何同步（比如 channel和select）
但如果要共享一些全局变量，或者需要同时被关闭，就可以用context来实现</p>
<h2>源码</h2>
<p>可以参考官方blog<img src="https://blog.golang.org/context" alt="context blog"></p>
<p>整体提供了：
&lt;table&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th&gt;Usage&lt;/th&gt;
&lt;th&gt;Comment&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Context&lt;/td&gt;
&lt;td&gt;Interface&lt;/td&gt;
&lt;td&gt;Define four methods:&lt;br&gt;&lt;br&gt;Deadline() (deadline time.Time, ok bool)&lt;br&gt;Done()&lt;-chan struct{}&lt;br&gt;Err() error&lt;br&gt;Value(key interface{}) interface{}&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;emptyCtx&lt;/td&gt;
&lt;td&gt;struct&lt;/td&gt;
&lt;td&gt;Also define interface, but it's empty&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CancelFunc&lt;/td&gt;
&lt;td&gt;func&lt;/td&gt;
&lt;td&gt;cancel func&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CancelCtx&lt;/td&gt;
&lt;td&gt;struct&lt;/td&gt;
&lt;td&gt;mark as cancelable&lt;/td&gt;
&lt;td rowspan=&quot;3&quot;&gt;都有实现自己的方法&lt;br&gt;&lt;br&gt;&lt;br&gt;Cancel()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;timerCtx&lt;/td&gt;
&lt;td&gt;struct&lt;/td&gt;
&lt;td&gt;canceled if timeout&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;valueCtx&lt;/td&gt;
&lt;td&gt;struct&lt;/td&gt;
&lt;td&gt;save K-V pair&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Background&lt;/td&gt;
&lt;td&gt;func&lt;/td&gt;
&lt;td&gt;Background returns a non-nil, empty Context. It is never canceled, has no&lt;br&gt;values, and has no deadline. It is typically used by the main function,&lt;br&gt; initialization, and tests, and as the top-level Context for incoming requests.&lt;/td&gt;
&lt;td&gt;返回空的context，常用做top-level context&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TODO&lt;/td&gt;
&lt;td&gt;func&lt;/td&gt;
&lt;td&gt;TODO returns a non-nil, empty Context.&lt;br&gt;Code should use context.TODO when it' s unclear which Context to use or it is not yet available&lt;br&gt; (because the surrounding function has not yet been extended to accept a Context&lt;br&gt;parameter). TODO is recognized by static analysis tools that determine&lt;br&gt;whether Contexts are propagated correctly in a program.&lt;/td&gt;
&lt;td&gt;返回空的context&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WithCancel&lt;/td&gt;
&lt;td&gt;func&lt;/td&gt;
&lt;td&gt;Based on parent context, generate a cancelable context&lt;/td&gt;
&lt;td&gt;基于父context生成可取消context&lt;br&gt;(自然就会调用下面的propagateCancel)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;newCancelCtx&lt;/td&gt;
&lt;td&gt;func&lt;/td&gt;
&lt;td&gt;create a cancelable context&lt;/td&gt;
&lt;td&gt;返回一个CancelCtx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;propagateCancel&lt;/td&gt;
&lt;td&gt;func&lt;/td&gt;
&lt;td&gt;propagateCancel arranges for child to be canceled&lt;/td&gt;
&lt;td&gt;向下传递context的关系&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;parentCancelCtx&lt;/td&gt;
&lt;td&gt;func &lt;/td&gt;
&lt;td&gt;parentCancelCtx follows a chain of parent references until it finds a&lt;br&gt;&lt;br&gt;*cancelCtx. This function understands how each of the concrete types in this&lt;br&gt;&lt;br&gt;package represents its parent.&lt;/td&gt;
&lt;td&gt;找到第一个可取消的父节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;removeChild&lt;/td&gt;
&lt;td&gt;func&lt;/td&gt;
&lt;td&gt;remove child&lt;/td&gt;
&lt;td&gt;去掉父节点的孩子节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;init&lt;/td&gt;
&lt;td&gt;func&lt;/td&gt;
&lt;td&gt;init this package&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WithDeadLine&lt;/td&gt;
&lt;td&gt;func&lt;/td&gt;
&lt;td&gt;Create a context with deadline&lt;/td&gt;
&lt;td rowspan=&quot;3&quot;&gt;同理，都是为了创建不同功能的context&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WithTimeout&lt;/td&gt;
&lt;td&gt;func&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WIthValue&lt;/td&gt;
&lt;td&gt;func&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;</p>
<p>context里面的类图：</p>
<p><img src="/img/go_context.png" alt="contextClass"></p>
<p>如上图所示，展开</p>
<h3>Interface</h3>
<h4>Context</h4>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">//deadline会返回 这个context应该被取消的时间， 如果ok==false，指没有deadline设置（即返回deadline的时间或者返回没有设置deadline）</span></span><br><span class="line">	Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">    <span class="comment">//返回一个关闭的只读channel ，代表着这个context应该被cancel或者到了deadline</span></span><br><span class="line">    </span><br><span class="line">	Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//channel Done（）关闭后，返回关闭原因</span></span><br><span class="line">	Err() error</span><br><span class="line">    <span class="comment">//获取key对应的value值</span></span><br><span class="line">	Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于 <strong>Done()</strong> 需要注意的是这个是一个<strong>只读</strong> 的 <strong>channel</strong>！</p>
<ol>
<li>只有在其被关闭后，才可以从里面读出值， 而且这个值是相应类型的 <strong>零值</strong>，所以goroutine可以在其关闭后读出零值，判断后继续做后面的事情</li>
<li>其具有关联性，即所有用到这个context的goroutine，一旦有一方关闭了(Done())，其他的也会被关闭</li>
</ol>
<h4>Canceler</h4>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A canceler is a context type that can be canceled directly. The</span></span><br><span class="line"><span class="comment">// implementations are *cancelCtx and *timerCtx.</span></span><br><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">	cancel(removeFromParent <span class="keyword">bool</span>, err error)</span><br><span class="line">	Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>源码说的很清楚了，这个接口会被 *cancelCtx和 *timerCtx 实现</p>
<p>//todo 为啥 Canceler里面有 cancel()，而Context里面 没有呢,是种设计问题吧？context有一些不会用到cancel，比如emptyCtx？</p>
<h3>struct</h3>
<h4>emptyCtx</h4>
<p>这个暂时略过，只要知道把这个当成一个占位符即可，有些函数可能以后会用到context，暂时把它当作一个参数传进去而已
它的相关方法有background() 和 TODO()
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An emptyCtx is never canceled, has no values, and has no deadline. It is not</span></span><br><span class="line"><span class="comment">// struct&#123;&#125;, since vars of this type must have distinct addresses.</span></span><br></pre></td></tr></table></figure></p>
<h4>cancelCtx</h4>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A cancelCtx can be canceled. When canceled, it also cancels any children</span></span><br><span class="line"><span class="comment">// that implement canceler.</span></span><br><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line">	mu       sync.Mutex            <span class="comment">// protects following fields</span></span><br><span class="line">	done     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;         <span class="comment">// created lazily, closed by first cancel call</span></span><br><span class="line">	children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">	err      error                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个cancelCtx 有实现了接口 <strong>Context</strong>
我们注意到源码中说到 done是 created lazily，即这个不是初始化就会有;发现这个在其下的Done()方法里面才会初始化：</p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)<span class="comment">//这里</span></span><br><span class="line">	&#125;</span><br><span class="line">	d := c.done</span><br><span class="line">	c.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面说到 这个 <strong>&lt;-chan struct{}</strong> 指的是只读 channel，在其他地方如果读取的话（还没关闭）会block住</p>
<p>紧接着**cancel()**方法</p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cancel closes c.done, cancels each of c's children, and, if</span></span><br><span class="line"><span class="comment">// removeFromParent is true, removes c from its parent's children.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"context: internal error: missing cancel error"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;<span class="comment">//前面说道err是当timeout或者cancel的时候会添加，所以有err就一定是被取消了（var Canceled = errors.New("context canceled")）</span></span><br><span class="line">		c.mu.Unlock()</span><br><span class="line">		<span class="keyword">return</span> <span class="comment">// already canceled</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.err = err</span><br><span class="line">	<span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.done = closedchan <span class="comment">//var closedchan = make(chan struct&#123;&#125;)</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">close</span>(c.done)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;<span class="comment">//loop所有的children，每个都调用cancel（）</span></span><br><span class="line">		<span class="comment">// <span class="doctag">NOTE:</span> acquiring the child's lock while holding parent's lock.//为啥要锁住呢，golang里面没有可重入锁，所以child和parent的锁都是分开的</span></span><br><span class="line">		child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	c.children = <span class="literal">nil</span><span class="comment">//把children字段设为nil</span></span><br><span class="line">	c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> removeFromParent &#123;<span class="comment">//从父context移除自己</span></span><br><span class="line">		removeChild(c.Context, c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>源码注释写着</p>
<ol>
<li>cancel会关闭掉 done这个channel，还会cancel掉c的所有children</li>
<li>如果removeFromparent 是true，最后调用removeChild()</li>
</ol>
<h5>Cancel（）方法的流程：</h5>
<ol>
<li>关闭c.Done() channel，然后不断地cancel它的子节点</li>
<li>并从父节点移除自己（removeFromParent）</li>
</ol>
<p>自然地，我们先看看removeChild()函数
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// removeChild removes a context from its parent.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeChild</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">	p, ok := parentCancelCtx(parent)<span class="comment">//拿出父context，这里是p</span></span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	p.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> p.children != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">delete</span>(p.children, child)<span class="comment">//直接从map里面删除这个child（删除自己）</span></span><br><span class="line">	&#125;</span><br><span class="line">	p.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&lt;del&gt;PS：里面的parentCancelCtx（）后来发现问题出在 valueCtx上面，我们放在 <a href>valueCtx</a> 讲 &lt;/del&gt;</p>
<h5>WithCancel（）流程：</h5>
<p>我们回到上面的<strong>cancel()</strong> 方法，输入的removeFromParent什么时候是true or false呢，全局查找后发现在**WithCancel()**里面有用到，
同时这也是一个Export出去（大写）的方法，目的是创建一个可cancel的Context：
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A CancelFunc tells an operation to abandon its work.</span></span><br><span class="line"><span class="comment">// A CancelFunc does not wait for the work to stop.</span></span><br><span class="line"><span class="comment">// After the first call, subsequent calls to a CancelFunc do nothing.</span></span><br><span class="line"><span class="keyword">type</span> CancelFunc <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">WithCancel</span> <span class="title">returns</span> <span class="title">a</span> <span class="title">copy</span> <span class="title">of</span> <span class="title">parent</span> <span class="title">with</span> <span class="title">a</span> <span class="title">new</span> <span class="title">Done</span> <span class="title">channel</span>. <span class="title">The</span> <span class="title">returned</span></span></span><br><span class="line"><span class="function">// <span class="title">context</span>'<span class="title">s</span> <span class="title">Done</span> <span class="title">channel</span> <span class="title">is</span> <span class="title">closed</span> <span class="title">when</span> <span class="title">the</span> <span class="title">returned</span> <span class="title">cancel</span> <span class="title">function</span> <span class="title">is</span> <span class="title">called</span></span></span><br><span class="line"><span class="function">// <span class="title">or</span> <span class="title">when</span> <span class="title">the</span> <span class="title">parent</span> <span class="title">context</span>'<span class="title">s</span> <span class="title">Done</span> <span class="title">channel</span> <span class="title">is</span> <span class="title">closed</span>, <span class="title">whichever</span> <span class="title">happens</span> <span class="title">first</span>.</span></span><br><span class="line"><span class="function">//</span></span><br><span class="line"><span class="function">// <span class="title">Canceling</span> <span class="title">this</span> <span class="title">context</span> <span class="title">releases</span> <span class="title">resources</span> <span class="title">associated</span> <span class="title">with</span> <span class="title">it</span>, <span class="title">so</span> <span class="title">code</span> <span class="title">should</span></span></span><br><span class="line"><span class="function">// <span class="title">call</span> <span class="title">cancel</span> <span class="title">as</span> <span class="title">soon</span> <span class="title">as</span> <span class="title">the</span> <span class="title">operations</span> <span class="title">running</span> <span class="title">in</span> <span class="title">this</span> <span class="title">Context</span> <span class="title">complete</span>.</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class="line">	c := newCancelCtx(parent)<span class="comment">//这个就是复制parent</span></span><br><span class="line">	propagateCancel(parent, &amp;c)</span><br><span class="line">	<span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>传入parent Context（一般是background），返回一个parentcontext的复制，这个parent contex有 <strong>新的Done channel</strong></li>
<li>这个新（复制）的Done channel会在两种情况被关闭（不管哪个先发生）：
返回的cancel CancelFunc （复制的） 被called （注意，<strong>CancelFunc只能被调用一次，接下来的都会do nothing</strong>）
parent context的 Done channel被关闭</li>
</ol>
<p><strong>那么删除前该怎么办（调用返回的cancel CancelFunc前），直接断开当前context和其parent的链接？</strong>
不行，还要把当前context的children全部cancel掉：
这里走到propagateCancel()函数</p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// propagateCancel arranges for child to be canceled when parent is.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> parent.Done() == <span class="literal">nil</span> &#123;<span class="comment">//没有初始化操作，即没有调用Done()操作，所以自然不存在cancel</span></span><br><span class="line">		<span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">		p.mu.Lock()</span><br><span class="line">		<span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// parent has already been canceled</span></span><br><span class="line">            </span><br><span class="line">			child.cancel(<span class="literal">false</span>, p.err)<span class="comment">//这里传入的就是false，因为父context已经被cancel掉了（父与当前child的链接断开），只需要把child和其下面的</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">				p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">			p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		p.mu.Unlock()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;<span class="comment">//如果没有找到parent context（它自己是空的），就新建一个goroutine监视parent context或者child context的done信号</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-parent.Done():<span class="comment">//如果找不到父节点，这个就不会调用</span></span><br><span class="line">				child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">			<span class="keyword">case</span> &lt;-child.Done():<span class="comment">//可能父节点取消了，这个会重复让子节点再取消一次</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从源码知道，propagateCancel()主要目的是当parent被cancel，把child给取消;（跟<strong>cancel（）方法重叠？？？</strong>）
会不断的传播传播下去，把parent的children字段全部设为空的struct</p>
<h4>parentCancelCtx特殊性</h4>
<p>之前说到的在这个parentCancelCtx() for循环里面，万一把当前context嵌套在一个struct里面，
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parentCancelCtx follows a chain of parent references until it finds a</span></span><br><span class="line"><span class="comment">// *cancelCtx. This function understands how each of the concrete types in this</span></span><br><span class="line"><span class="comment">// package represents its parent.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span> <span class="params">(*cancelCtx, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;<span class="comment">//很奇怪？？？为啥要for呢？？？</span></span><br><span class="line">		<span class="keyword">switch</span> c := parent.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> *cancelCtx:</span><br><span class="line">			<span class="keyword">return</span> c, <span class="literal">true</span></span><br><span class="line">		<span class="keyword">case</span> *timerCtx:</span><br><span class="line">			<span class="keyword">return</span> &amp;c.cancelCtx, <span class="literal">true</span></span><br><span class="line">		<span class="keyword">case</span> *valueCtx:</span><br><span class="line">			parent = c.Context<span class="comment">//for的问题在这里</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4>valueCtx</h4>
<p>结构体：
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A valueCtx carries a key-value pair. It implements Value for that key and</span></span><br><span class="line"><span class="comment">// delegates all other calls to the embedded Context.</span></span><br><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line">	key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先可以确认它是一个<strong>Context</strong> ，它的独立方法只有两个，其他都是继承context：
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"%v.WithValue(%#v, %#v)"</span>, c.Context, c.key, c.val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">		<span class="keyword">return</span> c.val</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Value（）的方法是取出对应key的value，但返回值是 <strong>c.Context.Value(key)</strong>，明显是递归调用，
其会一直往它的parent context查找，key是否等于输入的key，一直到终点（background）
前面也说到 <strong>background=new（emptyCtx）</strong>，所以在终点调用的其实是**emptyCtx.Value()**返回的是nil值</p>
<p>Export出去的创建一个valueCtx的方法：
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WithValue returns a copy of parent in which the value associated with key is</span></span><br><span class="line"><span class="comment">// val.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Use context Values only for request-scoped data that transits processes and</span></span><br><span class="line"><span class="comment">// APIs, not for passing optional parameters to functions.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The provided key must be comparable and should not be of type</span></span><br><span class="line"><span class="comment">// string or any other built-in type to avoid collisions between</span></span><br><span class="line"><span class="comment">// packages using context. Users of WithValue should define their own</span></span><br><span class="line"><span class="comment">// types for keys. To avoid allocating when assigning to an</span></span><br><span class="line"><span class="comment">// interface&#123;&#125;, context keys often have concrete type</span></span><br><span class="line"><span class="comment">// struct&#123;&#125;. Alternatively, exported context key variables' static</span></span><br><span class="line"><span class="comment">// type should be a pointer or interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"nil key"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !reflect.TypeOf(key).Comparable() &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"key is not comparable"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>WithValue（）适用范围：<strong>只用与在request作用域内的数据，这种数据是在进程或API传输所用，而不是作为函数的parameter使用</strong></p>
<p>WithValue（）规定了：</p>
<ol>
<li>
<p>其key不应该是string或者其他内置的类型，主要是为了防止使用context包的其他包之间产生冲突</p>
</li>
<li>
<p>所以key应该是用户自己设置的，要自己覆盖Comparable（）方法才行
这里给出 **Comparable()**的源码解释
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Methods applicable only to some types, depending on Kind.</span></span><br><span class="line">	<span class="comment">// The methods allowed for each kind are:</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//	Int*, Uint*, Float*, Complex*: Bits</span></span><br><span class="line">	<span class="comment">//	Array: Elem, Len</span></span><br><span class="line">	<span class="comment">//	Chan: ChanDir, Elem</span></span><br><span class="line">	<span class="comment">//	Func: In, NumIn, Out, NumOut, IsVariadic.</span></span><br><span class="line">	<span class="comment">//	Map: Key, Elem</span></span><br><span class="line">	<span class="comment">//	Ptr: Elem</span></span><br><span class="line">	<span class="comment">//	Slice: Elem</span></span><br><span class="line">    <span class="comment">//	Struct: Field, FieldByIndex, FieldByName, FieldByNameFunc, NumField</span></span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>为了防止赋值给interface{}，context的key经常是有具体类型的struct，此外，export出去的key的静态类型应该是指针或者interface</p>
</li>
</ol>
<h5>流程</h5>
<ol>
<li>判断key是否为空，key的类型是否合法</li>
<li>返回一个有parent指针的valueCtx;所以，创建valueCtx是可以从parent开始一级一级往下创建，如下图：
<img src="/img/valueCtx.png" alt="valueCtx"></li>
</ol>
<h4>timerCtx</h4>
<p>结构体：
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A timerCtx carries a timer and a deadline. It embeds a cancelCtx to</span></span><br><span class="line"><span class="comment">// implement Done and Err. It implements cancel by stopping its timer then</span></span><br><span class="line"><span class="comment">// delegating to cancelCtx.cancel.</span></span><br><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	cancelCtx</span><br><span class="line">	timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line"></span><br><span class="line">	deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它的cancel方法
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">	c.cancelCtx.cancel(<span class="literal">false</span>, err)</span><br><span class="line">	<span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">		<span class="comment">// Remove this timerCtx from its parent cancelCtx's children.</span></span><br><span class="line">		removeChild(c.cancelCtx.Context, c)</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.timer.Stop()</span><br><span class="line">		c.timer = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>流程：</p>
<ol>
<li>先调用里面的cancelCtx的cancel（）方法，取消其子节点</li>
<li>如果要</li>
</ol>
<p>哪里用到timerCtx.cancel（）呢，我们看看创建一个timerCtx的函数：</p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Canceling this context releases resources associated with it, so code should</span></span><br><span class="line"><span class="comment">// call cancel as soon as the operations running in this Context complete:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 	func slowOperationWithTimeout(ctx context.Context) (Result, error) &#123;</span></span><br><span class="line"><span class="comment">// 		ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)</span></span><br><span class="line"><span class="comment">// 		defer cancel()  // releases resources if slowOperation completes before timeout elapses</span></span><br><span class="line"><span class="comment">// 		return slowOperation(ctx)</span></span><br><span class="line"><span class="comment">// 	&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WithDeadline returns a copy of the parent context with the deadline adjusted</span></span><br><span class="line"><span class="comment">// to be no later than d. If the parent's deadline is already earlier than d,</span></span><br><span class="line"><span class="comment">// WithDeadline(parent, d) is semantically equivalent to parent. The returned</span></span><br><span class="line"><span class="comment">// context's Done channel is closed when the deadline expires, when the returned</span></span><br><span class="line"><span class="comment">// cancel function is called, or when the parent context's Done channel is</span></span><br><span class="line"><span class="comment">// closed, whichever happens first.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Canceling this context releases resources associated with it, so code should</span></span><br><span class="line"><span class="comment">// call cancel as soon as the operations running in this Context complete.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line">		<span class="comment">// The current deadline is already sooner than the new one.</span></span><br><span class="line">		<span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">	&#125;</span><br><span class="line">	c := &amp;timerCtx&#123;</span><br><span class="line">		cancelCtx: newCancelCtx(parent),</span><br><span class="line">		deadline:  d,</span><br><span class="line">	&#125;</span><br><span class="line">	propagateCancel(parent, c)</span><br><span class="line">	dur := time.Until(d)</span><br><span class="line">	<span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		c.cancel(<span class="literal">true</span>, DeadlineExceeded) <span class="comment">// deadline has already passed</span></span><br><span class="line">		<span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们发现WithTimeout和WithDeadline（）都可以创建timerCtx
区别： withTimeout第二个参数是传入duration，即距离现在的时间，withDeadline第二个参数指的是绝对时间，即几时几分</p>
<p>withDeadline（）流程：</p>
<ol>
<li>
<p>检查当前的deadline，如果存在且当前deadline比传入的时间要早，那么就退化成WithCancel（）</p>
</li>
<li>
<p>如果不存在deadline或者传入时间较晚，把当前timerCtx加入到parent Context里面;
但是注意，还要计算现在的时间是否大于了传入的时间，如果大于说明已经过了传入的deadline，直接退化成cancel（），并传入exceed错误信息：
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DeadlineExceeded error = deadlineExceededError&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> deadlineExceededError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span>   &#123; <span class="keyword">return</span> <span class="string">"context deadline exceeded"</span> &#125;</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>如果上述都不成立，调用time.AfterFunc()，规定时间后调用cancel()</p>
</li>
</ol>
<h3>使用例子</h3>
<p>这个经典的goroutine泄漏：</p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">repeatGen</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    c:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>;;i++&#123;</span><br><span class="line">            c&lt;-i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> v:=<span class="keyword">range</span> repeatGen()&#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">        <span class="keyword">if</span> v==<span class="number">3</span>&#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当v==3的时候，break出来，但这时候repeatGen里面的goroutine仍然在跑，不会被终止,goroutine发生泄漏</p>
<p>用context改进：
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">repeatGen</span><span class="params">(ctx context.Context)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    c:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> i:<span class="number">0</span>;;i++&#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-ctx.Done():<span class="comment">//等待done信号</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> c&lt;-i:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ctx,cancelFunc:=WithCancel(context.Background())</span><br><span class="line">    <span class="keyword">defer</span> cancelFunc()<span class="comment">//最后无论怎么样也要调用确保一定能关掉（为保万一而已，不一定要）</span></span><br><span class="line">    <span class="keyword">for</span> v:=<span class="keyword">range</span> repeatGen(ctx)&#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">        <span class="keyword">if</span> v==<span class="number">3</span>&#123;</span><br><span class="line">            cancelFunc()<span class="comment">//完成直接调用cancel</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>参考《go语言圣经》</em></strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mhh12121.github.io/2019/06/21/Go/Context/" data-id="cjxmwz4t3000kaeugc9sfwfpe" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Go/SortedMap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/19/Go/SortedMap/" class="article-date">
  <time datetime="2019-06-19T02:36:00.000Z" itemprop="datePublished">2019-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/19/Go/SortedMap/">Something should be noted in golang&#39;s map</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>There is <strong>SortedMap</strong> or <strong>LinkedHashMap</strong> in Java
Both can ensure the inserted order of elements, but f ** k myself, I found that Go <strong>only supports basic HashMap</strong>
which means you have to do SortedMap and LinkedHashMap by yourself.</p>
<pre><code>                                ----From a damn interview test
</code></pre>
<p>&lt;!--more--&gt;
I met a problem in an interview test:</p>
<p>Given a file containing URLs on every line,you must record all of their occurence times, then save it into a new file
format like:</p>
<pre><code>url1  2times
url2  3times
url3  4times
</code></pre>
<p>But it should be noticed that all urls in new file have the same sequence as those in source files;</p>
<p>其实你要解决三个问题：</p>
<ol>
<li>url频次统计（首先想起map）</li>
<li>要按顺序放入新文件？？？//todo</li>
<li>文件太大怎么办（拆乘多个文件，进行映射，再统计，但这里又不知道怎么保证顺序？？！！难倒只有手动实现LinkedHashMap红黑树？）</li>
</ol>
<p>Go blog <img src="https://blog.golang.org/go-maps-in-action" alt="map in action"> says:</p>
<blockquote>
<blockquote>
<blockquote>
<p>When iterating over a map with a range loop, the iteration order is not specified and is not guaranteed to be the same from one iteration to the next. Since the release of Go 1.0, the runtime has randomized map iteration order.</p>
</blockquote>
</blockquote>
</blockquote>
<h3>SortedMap</h3>
<p>Someone has already implemented it
From Go blog  <img src="https://blog.golang.org/go-maps-in-action" alt="map in action"></p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"sort"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> keys []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> m &#123;<span class="comment">//extract all the damn key out</span></span><br><span class="line">    keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">&#125;</span><br><span class="line">sort.Ints(keys)<span class="comment">//sort them</span></span><br><span class="line"><span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;<span class="comment">//then you can get a sorted map</span></span><br><span class="line">    fmt.Println(<span class="string">"Key:"</span>, k, <span class="string">"Value:"</span>, m[k])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>If your <strong>key</strong> is not an int or string or you wanna sort it by yourself:</p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//we assume a struct is like below:</span></span><br><span class="line"><span class="keyword">type</span> Obj <span class="keyword">struct</span> &#123;</span><br><span class="line">	Title    <span class="keyword">string</span></span><br><span class="line">	Sequence <span class="keyword">int</span></span><br><span class="line">	Size     <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">type</span> By <span class="function"><span class="keyword">func</span><span class="params">(o1, o2 *Obj)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//<span class="title">ObjSorter</span> <span class="title">joins</span> <span class="title">a</span> <span class="title">By</span> <span class="title">function</span> <span class="title">and</span> <span class="title">a</span> <span class="title">slice</span> <span class="title">of</span> <span class="title">Objs</span> <span class="title">to</span> <span class="title">be</span> <span class="title">sorted</span>.</span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">ObjSorter</span> <span class="title">struct</span></span> &#123;<span class="comment">//to wrap the obj and by function into this struct</span></span><br><span class="line">	objs []Obj</span><br><span class="line">	by   <span class="function"><span class="keyword">func</span><span class="params">(o1, o2 *Obj)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(by By)</span> <span class="title">Sort</span><span class="params">(objs []Obj)</span></span> &#123;</span><br><span class="line">	os := &amp;ObjSorter&#123;</span><br><span class="line">		objs: objs,</span><br><span class="line">		by:   by,</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Sort(os)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ObjSorter)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.by(&amp;s.objs[i], &amp;s.objs[j])</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ObjSorter)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	s.objs[i], s.objs[j] = s.objs[j], s.objs[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ObjSorter)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s.objs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Then to use it:</p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SortedMap</span><span class="params">(m <span class="keyword">map</span>[Obj]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	sortByTitle := <span class="function"><span class="keyword">func</span><span class="params">(o1, o2 *Obj)</span> <span class="title">bool</span></span> &#123; <span class="comment">//sort by Ttitle field</span></span><br><span class="line">		<span class="keyword">return</span> o1.Title &lt; o2.Title</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// sortBySequence := func(o1, o2 *Obj) bool &#123; //sortBy Sequence field</span></span><br><span class="line">	<span class="comment">// 	return o1.Sequence &lt; o2.Sequence</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	tempObjs := <span class="built_in">make</span>([]Obj, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> k := <span class="keyword">range</span> m &#123;</span><br><span class="line">		tempObjs = <span class="built_in">append</span>(tempObjs, k)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	By(sortByTitle).Sort(tempObjs)<span class="comment">//Sorted this</span></span><br><span class="line">	<span class="keyword">for</span> _, k := <span class="keyword">range</span> tempObjs &#123;<span class="comment">//operate this </span></span><br><span class="line">		fmt.Printf(<span class="string">"key:%v,value:%v \n"</span>, k, m[k])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>To test:</p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    obj1 := &amp;Obj&#123;Title: <span class="string">"4"</span>&#125;</span><br><span class="line">	obj2 := &amp;Obj&#123;Title: <span class="string">"2"</span>&#125;</span><br><span class="line">	obj3 := &amp;Obj&#123;Title: <span class="string">"1"</span>&#125;</span><br><span class="line">	objs := <span class="built_in">make</span>([]*Obj, <span class="number">0</span>)</span><br><span class="line">	objs = <span class="built_in">append</span>(objs, obj1, obj2, obj3)</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[Obj]<span class="keyword">int</span>)</span><br><span class="line">	m[*obj1] = <span class="number">1</span></span><br><span class="line">	m[*obj3] = <span class="number">1</span></span><br><span class="line">	m[*obj2] = <span class="number">1</span></span><br><span class="line">	SortedMap(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Result:</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key:&#123;1 0 0&#125;,value:1 </span><br><span class="line">key:&#123;2 0 0&#125;,value:1 </span><br><span class="line">key:&#123;4 0 0&#125;,value:1</span><br></pre></td></tr></table></figure></p>
<p>Above example can be found in <img src="https://golang.org/pkg/sort/" alt="Golang slice doc examples"></p>
<h3>LinkedHashMap</h3>
<p>To just ensure <strong>inserted order</strong>:
you can refer to <img src alt="Java LinkedHashMap">//or arrayMap()</p>
<p><strong>But</strong>
here we won't achieve the LinkedHashMap, it's kind of troublesome...</p>
<p>We do a trade-off between time and space:</p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//just create a slice to save sequence</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CalcUrls</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sequence:=<span class="built_in">make</span>([]<span class="keyword">string</span>,<span class="number">0</span>)</span><br><span class="line">    m:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    </span><br><span class="line">    url:=fp.ReadLine()</span><br><span class="line">    <span class="keyword">if</span> _,exists:=m[url];exists&#123;</span><br><span class="line">        m[url]++</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        sequence=<span class="built_in">append</span>(sequence,url)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">for</span> _,v:=<span class="keyword">range</span> sequence&#123;</span><br><span class="line">        res:=fmt.Sprintf(<span class="string">"url:%v,times:%v"</span>,v,m[v])</span><br><span class="line">        Writer.write(res)<span class="comment">//write into the new file</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>---------------------------------新增---------------------------------------------</strong>
主要是红黑树是为了能便于删除和添加，而我遇到的面试题只考虑添加，所以没必要，
但是隔了一天，还是觉得不爽</p>
<p>自己尝试实现一下基于红黑树的map看看，就当做复习吧：</p>
<p>首先，红黑树也是AVL树，区别就只是颜色上的判断不同而已，所以AVL的rotate我这里略过，主要就是颜色的判断
要符合</p>
<ol>
<li>每个节点是黑或者红</li>
<li>根节点是黑色</li>
<li>每个叶子节点是黑色（且为nil，添加的时候没用到，删除的时候会用）</li>
<li>如果一个节点是红色的，它的子节点必须是黑色的</li>
<li><strong>从一个节点到该节点的所有叶子节点的路径上包含相同数目的黑节点</strong> （这个一行代码可以搞定，但之后很可能会违反第4，所以要紧接着进行处理）</li>
</ol>
<p>插入时候，检查：
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要思路，先像AVL一样插入，之后再调整</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(brtree *BRTree)</span> <span class="title">insertNode</span><span class="params">(pnode *BRNode)</span></span> &#123;</span><br><span class="line">	tempRoot := brtree.root</span><br><span class="line">	<span class="keyword">var</span> temp *BRNode</span><br><span class="line">	<span class="keyword">for</span> tempRoot != <span class="literal">nil</span> &#123; <span class="comment">//已有根节点，就往下loop找到插入点</span></span><br><span class="line">		temp = tempRoot <span class="comment">//每次更新</span></span><br><span class="line">		<span class="keyword">if</span> pnode.val &gt; tempRoot.val &#123;</span><br><span class="line">			tempRoot = tempRoot.right</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			tempRoot = tempRoot.left</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pnode.parent = temp <span class="comment">//找到最后，把pnode的parent指向找到的最后一个点</span></span><br><span class="line">	<span class="keyword">if</span> temp != <span class="literal">nil</span> &#123;    <span class="comment">//不是根节点</span></span><br><span class="line">		<span class="keyword">if</span> temp.val &lt; pnode.val &#123; <span class="comment">//判断放在左子树还是右子树</span></span><br><span class="line">			temp.right = pnode</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			temp.left = pnode</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">//根节点</span></span><br><span class="line">		brtree.root = pnode</span><br><span class="line">	&#125;</span><br><span class="line">	pnode.color = RED <span class="comment">//直接把这个颜色先设置为红色！！！主要为了满足：</span></span><br><span class="line">	<span class="comment">// 从一个节点到该节点的所有叶子节点的路径上包含相同数目的黑节点（可以试想一下，最下方插入一个红色节点，因为目前红色节点的叶子节点肯定是黑色的nil，所以必会满足这个特性）</span></span><br><span class="line">	brtree.insertCheck(pnode) <span class="comment">//再检查，因为这个时候可能跟上面的第4点违背了，比如在红色的节点下面插一个红色的节点</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入时进行检查</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(brtree *BRTree)</span> <span class="title">insertCheck</span><span class="params">(pnode *BRNode)</span></span> &#123;</span><br><span class="line">	<span class="comment">//1. 该节点没有父节点，即为root（与上面insertNode插入点的检查并不重复，因为接下来会进行递归，这个属于边界条件，所以这个检查root必不可少）</span></span><br><span class="line">	<span class="keyword">if</span> pnode.parent == <span class="literal">nil</span> &#123;</span><br><span class="line">		brtree.root = pnode</span><br><span class="line">		brtree.root.color = BLACK</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2.父节点是黑色直接添加(不用管)，红色接着处理</span></span><br><span class="line">	<span class="keyword">if</span> pnode.parent.color == RED &#123;</span><br><span class="line">		<span class="comment">//2.1 父，叔叔节点不为空而且其颜色是红色 ,则将该父叔都改为黑色,将祖父改成红色</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">							  10,B</span></span><br><span class="line"><span class="comment">							 /     \</span></span><br><span class="line"><span class="comment">						    6,B	    15,B</span></span><br><span class="line"><span class="comment">						   /   \     /  \</span></span><br><span class="line"><span class="comment">						4,R   8,R  11,R  19,R</span></span><br><span class="line"><span class="comment">						/</span></span><br><span class="line"><span class="comment">					pnode,R</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">					==&gt;父叔节点都变成黑色，祖父变成红色</span></span><br><span class="line"><span class="comment">							  10,B</span></span><br><span class="line"><span class="comment">							 /     \</span></span><br><span class="line"><span class="comment">						    6,R	    15,B</span></span><br><span class="line"><span class="comment">						   /   \     /  \</span></span><br><span class="line"><span class="comment">						4,B   8,B  11,R  19,R</span></span><br><span class="line"><span class="comment">			             /</span></span><br><span class="line"><span class="comment">					  pnode,R</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">					==&gt;递归，从祖父（6）开始，因为此时父节点属于根节点，是黑色，所以完成</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">					           10,B</span></span><br><span class="line"><span class="comment">							 /     \</span></span><br><span class="line"><span class="comment">						    6,R	    15,B</span></span><br><span class="line"><span class="comment">						   /   \     /  \</span></span><br><span class="line"><span class="comment">						4,B   8,B  11,R  19,R</span></span><br><span class="line"><span class="comment">			             /</span></span><br><span class="line"><span class="comment">					  pnode,R</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">if</span> pnode.getUncle() != <span class="literal">nil</span> &amp;&amp; pnode.getUncle().color == RED &#123;</span><br><span class="line">			pnode.parent.color = BLACK</span><br><span class="line">			pnode.getUncle().color = BLACK</span><br><span class="line">			pnode.getGrandParent().color = RED</span><br><span class="line">			brtree.insertCheck(pnode.getGrandParent()) <span class="comment">//对该树上的节点递归上去处理</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//2.2 父节点为红色，叔叔节点不存在或者是黑色</span></span><br><span class="line"></span><br><span class="line">			isLeft := pnode == pnode.parent.left</span><br><span class="line">			isParentLeft := pnode.parent == pnode.getGrandParent().left</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> isLeft &amp;&amp; isParentLeft &#123;</span><br><span class="line">				<span class="comment">//2.2.1 是左子树，其父节点也是左子树</span></span><br><span class="line">				<span class="comment">/*       ...</span></span><br><span class="line"><span class="comment">						  /</span></span><br><span class="line"><span class="comment">				        8,B</span></span><br><span class="line"><span class="comment">					    /  \</span></span><br><span class="line"><span class="comment">					   7,R   /nil</span></span><br><span class="line"><span class="comment">					  /</span></span><br><span class="line"><span class="comment">					pnode,R</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="comment">//=》</span></span><br><span class="line">				<span class="comment">/*         /</span></span><br><span class="line"><span class="comment">					     7,B</span></span><br><span class="line"><span class="comment">				         /   \</span></span><br><span class="line"><span class="comment">				     pnode,R  8,R</span></span><br><span class="line"><span class="comment">				               \</span></span><br><span class="line"><span class="comment">				             /nil</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				pnode.parent.color = BLACK</span><br><span class="line">				pnode.getGrandParent().color = RED</span><br><span class="line">				brtree.rotateRight(pnode.getGrandParent())</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> !isLeft &amp;&amp; !isParentLeft &#123;</span><br><span class="line">				<span class="comment">//2.2.2 不是左子树，父亲也不是左子树</span></span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">						  7,B</span></span><br><span class="line"><span class="comment">					      /  \</span></span><br><span class="line"><span class="comment">					2,B/nil   8,R</span></span><br><span class="line"><span class="comment">					           \</span></span><br><span class="line"><span class="comment">					           10,pnode</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				pnode.parent.color = BLACK</span><br><span class="line">				pnode.getGrandParent().color = RED</span><br><span class="line">				brtree.rotateLeft(pnode.getGrandParent())</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> isLeft &amp;&amp; !isParentLeft &#123;</span><br><span class="line">				<span class="comment">//2.2.3 是左子树，但父亲不是左子树</span></span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">						8,B</span></span><br><span class="line"><span class="comment">					    /  \</span></span><br><span class="line"><span class="comment">					6,B/nil   10,R</span></span><br><span class="line"><span class="comment">					        /</span></span><br><span class="line"><span class="comment">					      pnode，R</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">						pnode,R</span></span><br><span class="line"><span class="comment">					    /  \</span></span><br><span class="line"><span class="comment">					6,B/nil  8,B</span></span><br><span class="line"><span class="comment">					            \</span></span><br><span class="line"><span class="comment">					            10,R</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				brtree.rotateRight(pnode.parent)</span><br><span class="line">				<span class="comment">//实际上变成了2.2.2</span></span><br><span class="line">				brtree.rotateLeft(pnode.parent) <span class="comment">//pnode现在在原先pnode的父节点位置</span></span><br><span class="line">				pnode.color = BLACK</span><br><span class="line">				pnode.left.color = RED</span><br><span class="line">				pnode.right.color = RED</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> !isLeft &amp;&amp; isParentLeft &#123;</span><br><span class="line">				<span class="comment">//2.2.4不是左子树，但父亲是左子树</span></span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">							 \</span></span><br><span class="line"><span class="comment">					        8,B</span></span><br><span class="line"><span class="comment">						    /  \</span></span><br><span class="line"><span class="comment">						   7,R   10,B/nil</span></span><br><span class="line"><span class="comment">						      \</span></span><br><span class="line"><span class="comment">						      pnode，R</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="comment">//==&gt;</span></span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">						 8，B</span></span><br><span class="line"><span class="comment">					    /    \</span></span><br><span class="line"><span class="comment">					  pnode,R  10,B/nil</span></span><br><span class="line"><span class="comment">					  /</span></span><br><span class="line"><span class="comment">					7,R</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">						 pnode，R</span></span><br><span class="line"><span class="comment">					    /    \</span></span><br><span class="line"><span class="comment">					   8,B   10,B/nil</span></span><br><span class="line"><span class="comment">					  /</span></span><br><span class="line"><span class="comment">					7,R</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line"></span><br><span class="line">				brtree.rotateLeft(pnode.parent)</span><br><span class="line">				<span class="comment">//实际上变成了2.2.1</span></span><br><span class="line">				brtree.rotateRight(pnode.parent)</span><br><span class="line">				pnode.color = BLACK</span><br><span class="line">				pnode.left.color = RED</span><br><span class="line">				pnode.right.color = RED</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么把红黑树放在map上呢：</p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><strong>---------------------------------end-----------------------------------------------</strong>
The above code may use O(2n) space, but time complexity reduce to O(n)
<strong>!!!Everything seems done!!!</strong></p>
<p>So what if we use a <strong>large file?</strong></p>
<h3>Large File</h3>
<p>Solution: Split the large file into several files, it depends on your MEM:</p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HashFile</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">int</span></span>&#123;<span class="comment">//pass a url</span></span><br><span class="line">    seed:=<span class="number">131</span></span><br><span class="line">    hash:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,v:=<span class="keyword">range</span> url&#123;</span><br><span class="line">        hash=hash*seed+v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash &amp; <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">    <span class="comment">//url:=fp.ReadLine()</span></span><br><span class="line">    pos:=HashFile(url)</span><br><span class="line">    file:=pos%<span class="number">10</span><span class="comment">//we assume that it split into 10 files</span></span><br><span class="line">    bufio.newWriter(file+<span class="string">".txt"</span>)</span><br><span class="line">    Writer.Write(file+<span class="string">".txt"</span>)<span class="comment">//write it into specific file</span></span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">    urls:=<span class="built_in">make</span>([]<span class="keyword">string</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">        urlPlusTimes:=LoopEachFile(files)<span class="comment">//calculate each files' urls</span></span><br><span class="line">        urls=<span class="built_in">append</span>(urls,urlPlusTimes...)<span class="comment">// Here comes to the question??? how to ensure sequence???</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3>Addition</h3>
<h4>unsafe</h4>
<p>map in golang is <strong>not thread-safe</strong>;
So it involves with concurrency situation, you must add <strong>sync.Mutex</strong> or <strong>sync.RWMutex</strong>
About that, can refer to <img src="/Concurrency" alt="my previous blog"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mhh12121.github.io/2019/06/19/Go/SortedMap/" data-id="cjxmwz4tb000saeugtbdrrqbm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Go/GolangMux" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/08/Go/GolangMux/" class="article-date">
  <time datetime="2019-06-08T02:10:00.000Z" itemprop="datePublished">2019-06-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/08/Go/GolangMux/">Golang Mux</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>开始做笔记...
(之前面试被怼了)</p>
<p>&lt;!--more--&gt;</p>
<h2>路由匹配原理(Regexp in Router)</h2>
<p>First, let's go through its *** usage ***:</p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router:=mux.router()</span><br><span class="line">router.HandlerFunc(<span class="string">"/api/v&#123;version&#125;/&#123;category&#125;"</span>,handler)</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//then in handler:</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter,r *http.request)</span></span>&#123;</span><br><span class="line">    vars:=mux.Vars(r)<span class="comment">//Get the variables!</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Let's cut it into two parts:</p>
<h3>HandlerFunc(path,handler)</h3>
<p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandleFunc registers a new route with a matcher for the URL path.</span></span><br><span class="line"><span class="comment">// See Route.Path() and Route.HandlerFunc().</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">HandleFunc</span><span class="params">(path <span class="keyword">string</span>, f <span class="keyword">func</span>(http.ResponseWriter,</span></span></span><br><span class="line"><span class="function"><span class="params">    *http.Request)</span>) *<span class="title">Route</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.NewRoute().Path(path).HandlerFunc(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>then let's see  *** Route.Path(path) *** :</p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Path -----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Path adds a matcher for the URL path.</span></span><br><span class="line"><span class="comment">// It accepts a template with zero or more URL variables enclosed by &#123;&#125;. The</span></span><br><span class="line"><span class="comment">// template must start with a "/".</span></span><br><span class="line"><span class="comment">// Variables can define an optional regexp pattern to be matched:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - &#123;name&#125; matches anything until the next slash.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - &#123;name:pattern&#125; matches the given regexp pattern.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For example:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     r := mux.NewRouter()</span></span><br><span class="line"><span class="comment">//     r.Path("/products/").Handler(ProductsHandler)</span></span><br><span class="line"><span class="comment">//     r.Path("/products/&#123;key&#125;").Handler(ProductsHandler)</span></span><br><span class="line"><span class="comment">//     r.Path("/articles/&#123;category&#125;/&#123;id:[0-9]+&#125;").</span></span><br><span class="line"><span class="comment">//       Handler(ArticleHandler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Variable names must be unique in a given route. They can be retrieved</span></span><br><span class="line"><span class="comment">// calling mux.Vars(request).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Route)</span> <span class="title">Path</span><span class="params">(tpl <span class="keyword">string</span>)</span> *<span class="title">Route</span></span> &#123;<span class="comment">//根据传入的url增加正则匹配</span></span><br><span class="line">	r.err = r.addRegexpMatcher(tpl, regexpTypePath)</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>In *** r.err = r.addRegexpMatcher(tpl, regexpTypePath) ***
the *** regexpTypePath=0 *** means this is for matching Path instead of Host/Port/Prefix/Query</p>
<p>Continue, Go into method *** addRegexpMatcher() ***:</p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addRegexpMatcher adds a host or path matcher and builder to a route.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Route)</span> <span class="title">addRegexpMatcher</span><span class="params">(tpl <span class="keyword">string</span>, typ regexpType)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> r.err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> typ == regexpTypePath || typ == regexpTypePrefix &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(tpl) &gt; <span class="number">0</span> &amp;&amp; tpl[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"mux: path must start with a slash, got %q"</span>, tpl)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> r.regexp.path != <span class="literal">nil</span> &#123;</span><br><span class="line">			tpl = strings.TrimRight(r.regexp.path.template, <span class="string">"/"</span>) + tpl</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	rr, err := newRouteRegexp(tpl, typ, routeRegexpOptions&#123;<span class="comment">// 核心部分</span></span><br><span class="line">		strictSlash:    r.strictSlash,</span><br><span class="line">		useEncodedPath: r.useEncodedPath,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, q := <span class="keyword">range</span> r.regexp.queries &#123;</span><br><span class="line">		<span class="keyword">if</span> err = uniqueVars(rr.varsN, q.varsN); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> typ == regexpTypeHost &#123;</span><br><span class="line">		<span class="keyword">if</span> r.regexp.path != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err = uniqueVars(rr.varsN, r.regexp.path.varsN); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		r.regexp.host = rr</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r.regexp.host != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err = uniqueVars(rr.varsN, r.regexp.host.varsN); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> typ == regexpTypeQuery &#123;</span><br><span class="line">			r.regexp.queries = <span class="built_in">append</span>(r.regexp.queries, rr)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			r.regexp.path = rr</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	r.addMatcher(rr)<span class="comment">//这里会把当前matcher加入matcher slice</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>We will find that we only enter the first *** if *** block (from line 4 - line 11):
Getinto the *** newRouteRegexp() ***</p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newRouteRegexp parses a route template and returns a routeRegexp,</span></span><br><span class="line"><span class="comment">// used to match a host, a path or a query string.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It will extract named variables, assemble a regexp to be matched, create</span></span><br><span class="line"><span class="comment">// a "reverse" template to build URLs and compile regexps to validate variable</span></span><br><span class="line"><span class="comment">// values used in URL building.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Previously we accepted only Python-like identifiers for variable</span></span><br><span class="line"><span class="comment">// names ([a-zA-Z_][a-zA-Z0-9_]*), but currently the only restriction is that</span></span><br><span class="line"><span class="comment">// name and pattern can't be empty, and names can't contain a colon.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newRouteRegexp</span><span class="params">(tpl <span class="keyword">string</span>, typ regexpType, options routeRegexpOptions)</span> <span class="params">(*routeRegexp, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">return</span> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>I will roughly split the above code into serveral parts as below:</p>
<h4>Procedure :</h4>
<ol>
<li>根据括号筛选变量 (braceIndices)
It will check the all *** {variable} *** in Path and save them into a slice:
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// braceIndices returns the first level curly brace indices from a string.</span></span><br><span class="line"><span class="comment">// It returns an error in case of unbalanced braces.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">braceIndices</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> level, idx <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> idxs []<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		<span class="keyword">switch</span> s[i] &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'&#123;'</span>:</span><br><span class="line">			<span class="keyword">if</span> level++; level == <span class="number">1</span> &#123;</span><br><span class="line">				idx = i</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'&#125;'</span>:</span><br><span class="line">			<span class="keyword">if</span> level--; level == <span class="number">0</span> &#123;</span><br><span class="line">				idxs = <span class="built_in">append</span>(idxs, idx, i+<span class="number">1</span>)<span class="comment">//注意：这里只是存了variable开始和结尾的index，而不是string</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> level &lt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"mux: unbalanced braces in %q"</span>, s)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> level != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"mux: unbalanced braces in %q"</span>, s)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> idxs, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>====&gt;</p>
<ol start="2">
<li>移除斜杠 (Remove endSlash)
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> has Suffix():</span><br><span class="line">    tpl = tpl[:<span class="built_in">len</span>(tpl)<span class="number">-1</span>]<span class="comment">//remove end slash</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>====&gt;</p>
<ol start="3">
<li>traverse idxs(variables)
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">varsN := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(idxs)/<span class="number">2</span>)<span class="comment">//多少个变量</span></span><br><span class="line">varsR := <span class="built_in">make</span>([]*regexp.Regexp, <span class="built_in">len</span>(idxs)/<span class="number">2</span>)<span class="comment">//多少个变量的匹配</span></span><br><span class="line">pattern := bytes.NewBufferString(<span class="string">""</span>)</span><br><span class="line">pattern.WriteByte(<span class="string">'^'</span>)</span><br><span class="line">reverse := bytes.NewBufferString(<span class="string">""</span>)</span><br><span class="line"><span class="keyword">var</span> end <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(idxs); i += <span class="number">2</span> &#123;<span class="comment">//因为之前说过idxs里面是index,+=2实际是遍历下一个变量</span></span><br><span class="line">    <span class="comment">// Set all values we are interested in.</span></span><br><span class="line">    raw := tpl[end:idxs[i]]<span class="comment">//括号之前的string</span></span><br><span class="line">    end = idxs[i+<span class="number">1</span>]<span class="comment">//指的是closed bracket</span></span><br><span class="line">    parts := strings.SplitN(tpl[idxs[i]+<span class="number">1</span>:end<span class="number">-1</span>], <span class="string">":"</span>, <span class="number">2</span>)<span class="comment">//把变量给弄出来,不过可能有&#123;name:pattern&#125;这种情况，所以要分割开</span></span><br><span class="line">    name := parts[<span class="number">0</span>]</span><br><span class="line">    patt := defaultPattern <span class="comment">//defaultPattern是 [^/]+,即匹配‘/’多次</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(parts) == <span class="number">2</span> &#123;</span><br><span class="line">        patt = parts[<span class="number">1</span>]<span class="comment">//如果有检测到：，就用后面的正则</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Name or pattern can't be empty.</span></span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">""</span> || patt == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"mux: missing name or pattern in %q"</span>,</span><br><span class="line">            tpl[idxs[i]:end])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Build the regexp pattern.</span></span><br><span class="line">    fmt.Fprintf(pattern, <span class="string">"%s(?P&lt;%s&gt;%s)"</span>, regexp.QuoteMeta(raw), varGroupName(i/<span class="number">2</span>), patt)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build the reverse template.</span></span><br><span class="line">    fmt.Fprintf(reverse, <span class="string">"%s%%s"</span>, raw)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Append variable name and compiled pattern.</span></span><br><span class="line">    varsN[i/<span class="number">2</span>] = name<span class="comment">//！！！！这个就是变量的存储位置</span></span><br><span class="line">    varsR[i/<span class="number">2</span>], err = regexp.Compile(fmt.Sprintf(<span class="string">"^%s$"</span>, patt))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>返回后回到 *<em>func (r <em>Route) addRegexpMatcher(tpl string, typ regexpType) error</em></em> func，
这个函数最后会把match加入matchers里面
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addMatcher adds a matcher to the route.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Route)</span> <span class="title">addMatcher</span><span class="params">(m matcher)</span> *<span class="title">Route</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.err == <span class="literal">nil</span> &#123;</span><br><span class="line">		r.matchers = <span class="built_in">append</span>(r.matchers, m)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="4">
<li></li>
</ol>
<h3>Vars()</h3>
<p>The place used by mux to save variables called *** context *** (上下文)
And we have to talk about the *** context in 'net/http' ***:
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个是mux里面的context</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Context </span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RouteMatch stores information about a matched route.</span></span><br><span class="line"><span class="keyword">type</span> RouteMatch <span class="keyword">struct</span> &#123;</span><br><span class="line">	Route   *Route</span><br><span class="line">	Handler http.Handler</span><br><span class="line">	Vars    <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// MatchErr is set to appropriate matching error</span></span><br><span class="line">	<span class="comment">// It is set to ErrMethodMismatch if there is a mismatch in</span></span><br><span class="line">	<span class="comment">// the request method and route method</span></span><br><span class="line">	MatchErr error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> contextKey <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	varsKey contextKey = <span class="literal">iota</span></span><br><span class="line">	routeKey</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vars returns the route variables for the current request, if any.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Vars</span><span class="params">(r *http.Request)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> rv := contextGet(r, varsKey); rv != <span class="literal">nil</span> &#123;<span class="comment">//这里会从request的context里面获取key-value pair，然后转换成map</span></span><br><span class="line">		<span class="keyword">return</span> rv.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Then go into *** contextGet(r,varsKey) ***:
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//"mux"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">contextGet</span><span class="params">(r *http.Request, key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> r.Context().Value(key)<span class="comment">//发现用的是net/http里面的context</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Context struct in *** &quot;net/http&quot; ***可以参考自己写的一个<a href="/Context.html">context</a></p>
<p>一切到最后，handleFunc()会调用ServeHTTP（w,req），里面就会把RouteMatch的vars导出，放入http包里的context里
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP dispatches the handler registered in the matched route.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When there is a match, the route variables can be retrieved calling</span></span><br><span class="line"><span class="comment">// mux.Vars(request).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !r.skipClean &#123;</span><br><span class="line">		path := req.URL.Path</span><br><span class="line">		<span class="keyword">if</span> r.useEncodedPath &#123;</span><br><span class="line">			path = req.URL.EscapedPath()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Clean path to canonical form and redirect.</span></span><br><span class="line">		<span class="keyword">if</span> p := cleanPath(path); p != path &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Added 3 lines (Philip Schlump) - It was dropping the query string and #whatever from query.</span></span><br><span class="line">			<span class="comment">// This matches with fix in go 1.2 r.c. 4 for same problem.  Go Issue:</span></span><br><span class="line">			<span class="comment">// http://code.google.com/p/go/issues/detail?id=5252</span></span><br><span class="line">			url := *req.URL</span><br><span class="line">			url.Path = p</span><br><span class="line">			p = url.String()</span><br><span class="line"></span><br><span class="line">			w.Header().Set(<span class="string">"Location"</span>, p)</span><br><span class="line">			w.WriteHeader(http.StatusMovedPermanently)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> match RouteMatch</span><br><span class="line">	<span class="keyword">var</span> handler http.Handler</span><br><span class="line">	<span class="keyword">if</span> r.Match(req, &amp;match) &#123;</span><br><span class="line">		handler = match.Handler</span><br><span class="line">		req = setVars(req, match.Vars)<span class="comment">//这里，设置vars</span></span><br><span class="line">		req = setCurrentRoute(req, match.Route)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &amp;&amp; match.MatchErr == ErrMethodMismatch &#123;</span><br><span class="line">		handler = methodNotAllowedHandler()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		handler = http.NotFoundHandler()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	handler.ServeHTTP(w, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mhh12121.github.io/2019/06/08/Go/GolangMux/" data-id="cjxmwz4sx000gaeugjpcf76dz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java/Java-Class" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/05/java/Java-Class/" class="article-date">
  <time datetime="2019-06-05T15:48:00.000Z" itemprop="datePublished">2019-06-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/05/java/Java-Class/">class loading</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>类的加载</p>
<p>双亲委托模型</p>
<p>//todo</p>
<p>final，static 等在jvm 内存中的处理</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mhh12121.github.io/2019/06/05/java/Java-Class/" data-id="cjxmwz4t0000iaeugjg28tci9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Go/Slice" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/05/Go/Slice/" class="article-date">
  <time datetime="2019-06-05T15:48:00.000Z" itemprop="datePublished">2019-06-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/05/Go/Slice/">Something about Slice in Go</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Golang's Slice is kinda diffrent===&gt;</p>
<p>&lt;!--more--&gt;
<img src="/img/golangusergroups.png" alt="group"></p>
<p>This article [Slice]https://blog.golang.org/slices may give you more information</p>
<h2>slice struct</h2>
<p>slice其实是一个结构体，并不是简单的数组或者链表(不想用英文写了)</p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//actually its not visible to programmer</span></span><br><span class="line"><span class="comment">//我自己臆想出来的,但可以从src/runtime/slice.go找出,或者走这个链接：https://golang.org/src/runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span>&#123;</span><br><span class="line">    length <span class="keyword">int</span> <span class="comment">//length</span></span><br><span class="line">    pointer <span class="keyword">interface</span>&#123;&#125; <span class="comment">//point to first element, the type depends on the element</span></span><br><span class="line">    Capacity <span class="keyword">int</span><span class="comment">//max容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际上是这样的:
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span>&#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span></span><br><span class="line">    <span class="built_in">cap</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>来到这里你可能会想到，好像一个对象耶，那么这玩意儿传入func里面是不是传指针进去呢？（即里面的修改会影响到origianl？）
答案是不会</p>
<p>Example:
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubtractOneFromLength</span><span class="params">(slice []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    slice = slice[<span class="number">0</span> : <span class="built_in">len</span>(slice)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Before: len(slice) ="</span>, <span class="built_in">len</span>(slice))</span><br><span class="line">    newSlice := SubtractOneFromLength(slice)<span class="comment">//you haven't passed the slice's header into it</span></span><br><span class="line">    fmt.Println(<span class="string">"After:  len(slice) ="</span>, <span class="built_in">len</span>(slice))</span><br><span class="line">    fmt.Println(<span class="string">"After:  len(newSlice) ="</span>, <span class="built_in">len</span>(newSlice))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>You *** Must *** do so:
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newSlice := SubtractOneFromLength(&amp;slice)<span class="comment">//Like this will work!</span></span><br></pre></td></tr></table></figure></p>
<h2>Enlarge Capcity</h2>
<p>你可以理解slice是动态列表，到达某个值后很自然就会扩容，扩容的大小文档里面也写了，是直接 *** ×2 ***
但是，那些只针对于没有定义 *** cap *** 字段的slice，万一规定了，像
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">15</span>)</span><br></pre></td></tr></table></figure></p>
<p>上限就是15了，如果强行append。。。。。。*** 也没关系! ***，只是这个时候会进行扩容，然后,原slice的地址（即第一个元素的地址）会进行改变
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">slice[<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">slice=<span class="built_in">append</span>(slice,<span class="number">3</span>)</span><br><span class="line">fmt.Println(&amp;slice[<span class="number">0</span>])<span class="comment">//0x414020</span></span><br><span class="line"></span><br><span class="line">slice=<span class="built_in">append</span>(slice,<span class="number">4</span>)</span><br><span class="line">fmt.Println(&amp;slice[<span class="number">0</span>])<span class="comment">//0x414040</span></span><br></pre></td></tr></table></figure></p>
<p>同样，*** 这里有另外几个坑 ***：</p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example in docs</span></span><br><span class="line">    slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">15</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"len: %d, cap: %d\n"</span>, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))<span class="comment">//15</span></span><br><span class="line">    newSlice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(slice), <span class="number">2</span>*<span class="built_in">cap</span>(slice))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        newSlice[i] = slice[i]</span><br><span class="line">    &#125;</span><br><span class="line">    slice = newSlice</span><br><span class="line">    fmt.Printf(<span class="string">"len: %d, cap: %d\n"</span>, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))<span class="comment">//30</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>
<p>究竟是哪个slice
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a:=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">a[<span class="number">1</span>]=<span class="number">2</span></span><br><span class="line">a[<span class="number">2</span>]=<span class="number">3</span></span><br><span class="line"></span><br><span class="line">b:=<span class="built_in">append</span>(a,<span class="number">4</span>)</span><br><span class="line">c:=<span class="built_in">append</span>(a,<span class="number">100</span>)</span><br><span class="line">fmt.Println(&amp;a[<span class="number">0</span>], &amp;b[<span class="number">0</span>], &amp;c[<span class="number">0</span>]) <span class="comment">//0xc0000125c0 0xc0000125c0 0xc0000125c0   Found that they use the same memory address</span></span><br><span class="line">fmt.Println(a, b, c)<span class="comment">//[1 2 3] [1 2 3 100] [1 2 3 100]</span></span><br><span class="line"></span><br><span class="line">c[<span class="number">0</span>] = <span class="number">101</span></span><br><span class="line">fmt.Println(a, b, c)<span class="comment">//[101 2 3] [101 2 3 100] [101 2 3 100]</span></span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>值传递？引用传递？</p>
</li>
</ol>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">y:=[]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line">add(y)<span class="comment">//你可能这样子推论：go里面都是值传递==&gt;所以这里面的改动不会影响到y。可惜，这是错的</span></span><br><span class="line">fmt.Println(y)<span class="comment">//&#123;1,1,1&#125;  ///wtf？？？？？</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(y []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// for _,v:=range y&#123; //这个就不会改变，因为这个v只是值的拷贝</span></span><br><span class="line">    <span class="comment">//     v++</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="keyword">range</span> y&#123;</span><br><span class="line">        y[i]++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5>注意：</h5>
<p>其实上面已经提到，slice是一个struct，传入的时候如果仅仅是修改一下元素的内容，是不会对其头部地址进行改变，所以，传入修改其值是可以的;</p>
<p>但是，做一些比如append之类的操作，这样会使整个slice发生变化，<strong>其头部指针指向一个新的slice</strong>，所以原来的slice就不会被改变</p>
<p>这里放上扩容的源码:</p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// growslice handles slice growth during append.</span></span><br><span class="line"><span class="comment">// It is passed the slice element type, the old slice, and the desired new minimum capacity,</span></span><br><span class="line"><span class="comment">// and it returns a new slice with at least that capacity, with the old data</span></span><br><span class="line"><span class="comment">// copied into it.</span></span><br><span class="line"><span class="comment">// The new slice's length is set to the old slice's length,</span></span><br><span class="line"><span class="comment">// NOT to the new requested capacity.</span></span><br><span class="line"><span class="comment">// This is for codegen convenience. The old slice's length is used immediately</span></span><br><span class="line"><span class="comment">// to calculate where to write new values during an append.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> When the old backend is gone, reconsider this decision.</span></span><br><span class="line"><span class="comment">// The SSA backend might prefer the new length or to return only ptr/cap and save stack space.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> &#123;<span class="comment">// et 指的是？？？？， old是老的slice，cap是申请的容量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        callerpc := getcallerpc()</span><br><span class="line">        racereadrangepc(old.array, <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>*<span class="keyword">int</span>(et.size)), callerpc, funcPC(growslice))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">        msanread(old.array, <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>*<span class="keyword">int</span>(et.size)))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO不懂</span></span><br><span class="line">    <span class="keyword">if</span> et.size == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">cap</span> &lt; old.<span class="built_in">cap</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(errorString(<span class="string">"growslice: cap out of range"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// append should not create a slice with nil pointer but non-zero len.</span></span><br><span class="line">        <span class="comment">// We assume that append doesn't need to preserve old.array in this case.</span></span><br><span class="line">        <span class="keyword">return</span> slice&#123;unsafe.Pointer(&amp;zerobase), old.<span class="built_in">len</span>, <span class="built_in">cap</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//-------------计算扩容数量-----------------</span></span><br><span class="line">    newcap := old.<span class="built_in">cap</span></span><br><span class="line">    doublecap := newcap + newcap</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;<span class="comment">//申请容量 &gt; 2 * 旧的容量</span></span><br><span class="line">        newcap = <span class="built_in">cap</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;<span class="comment">//老容量 &lt; 1024，直接扩成旧的两倍</span></span><br><span class="line">            newcap = doublecap</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line">            <span class="comment">// and prevent an infinite loop.</span></span><br><span class="line">            <span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;<span class="comment">//好像看见有文章說是1.25倍，但实际并不是，可以往下继续看capmen变量</span></span><br><span class="line">                newcap += newcap / <span class="number">4</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line">            <span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line">            <span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;<span class="comment">//溢出的话就使之等于申请的容量</span></span><br><span class="line">                newcap = <span class="built_in">cap</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//-------------以上计算扩容数量结束--------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------TODO以下开始计算内存位置，不但继续计算新的容量大小，还要决定扩容后是否要重新划分内存------------------</span></span><br><span class="line">    <span class="keyword">var</span> overflow <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">var</span> lenmem, newlenmem, capmem <span class="keyword">uintptr</span></span><br><span class="line">    <span class="comment">// Specialize for common values of et.size.</span></span><br><span class="line">    <span class="comment">// For 1 we don't need any division/multiplication.</span></span><br><span class="line">    <span class="comment">// For sys.PtrSize, compiler will optimize division/multiplication into a shift by a constant.//这里就说到会优化</span></span><br><span class="line">    <span class="comment">// For powers of 2, use a variable shift.</span></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> et.size == <span class="number">1</span>:</span><br><span class="line">        lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>)</span><br><span class="line">        newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>)</span><br><span class="line">        capmem = roundupsize(<span class="keyword">uintptr</span>(newcap))<span class="comment">//这个东西，感觉有关于内存对齐TODO</span></span><br><span class="line">        overflow = <span class="keyword">uintptr</span>(newcap) &gt; maxAlloc</span><br><span class="line">        newcap = <span class="keyword">int</span>(capmem)</span><br><span class="line">    <span class="keyword">case</span> et.size == sys.PtrSize:<span class="comment">//是一个指针大小</span></span><br><span class="line">        lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * sys.PtrSize</span><br><span class="line">        newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * sys.PtrSize</span><br><span class="line">        capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) * sys.PtrSize)</span><br><span class="line">        overflow = <span class="keyword">uintptr</span>(newcap) &gt; maxAlloc/sys.PtrSize</span><br><span class="line">        newcap = <span class="keyword">int</span>(capmem / sys.PtrSize)<span class="comment">//sys.PtrSize指的是一个指针的size，64位的机器就是8</span></span><br><span class="line">    <span class="keyword">case</span> isPowerOfTwo(et.size):<span class="comment">//2次幂会用variable shift</span></span><br><span class="line">        <span class="keyword">var</span> shift <span class="keyword">uintptr</span></span><br><span class="line">        <span class="keyword">if</span> sys.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line">            <span class="comment">// Mask shift for better code generation.</span></span><br><span class="line">            shift = <span class="keyword">uintptr</span>(sys.Ctz64(<span class="keyword">uint64</span>(et.size))) &amp; <span class="number">63</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            shift = <span class="keyword">uintptr</span>(sys.Ctz32(<span class="keyword">uint32</span>(et.size))) &amp; <span class="number">31</span></span><br><span class="line">        &#125;</span><br><span class="line">        lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) &lt;&lt; shift</span><br><span class="line">        newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) &lt;&lt; shift</span><br><span class="line">        capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) &lt;&lt; shift)</span><br><span class="line">        overflow = <span class="keyword">uintptr</span>(newcap) &gt; (maxAlloc &gt;&gt; shift)</span><br><span class="line">        newcap = <span class="keyword">int</span>(capmem &gt;&gt; shift)</span><br><span class="line">    <span class="keyword">default</span>:<span class="comment">//其他的情况就直接除以et.size</span></span><br><span class="line">        lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * et.size</span><br><span class="line">        newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * et.size</span><br><span class="line">        capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) * et.size)</span><br><span class="line">        overflow = <span class="keyword">uintptr</span>(newcap) &gt; maxSliceCap(et.size)</span><br><span class="line">        newcap = <span class="keyword">int</span>(capmem / et.size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The check of overflow (uintptr(newcap) &gt; maxSliceCap(et.size))</span></span><br><span class="line">    <span class="comment">// in addition to capmem &gt; _MaxMem is needed to prevent an overflow</span></span><br><span class="line">    <span class="comment">// which can be used to trigger a segfault on 32bit architectures</span></span><br><span class="line">    <span class="comment">// with this example program:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// type T [1&lt;&lt;27 + 1]int64</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// var d T</span></span><br><span class="line">    <span class="comment">// var s []T</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// func main() &#123;</span></span><br><span class="line">    <span class="comment">//   s = append(s, d, d, d, d)</span></span><br><span class="line">    <span class="comment">//   print(len(s), "\n")</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">cap</span> &lt; old.<span class="built_in">cap</span> || overflow || capmem &gt; maxAlloc &#123;</span><br><span class="line">        <span class="built_in">panic</span>(errorString(<span class="string">"growslice: cap out of range"</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> p unsafe.Pointer         <span class="comment">//这个应该是地址了</span></span><br><span class="line">    <span class="keyword">if</span> et.kind&amp;kindNoPointers != <span class="number">0</span> &#123;</span><br><span class="line">        p = mallocgc(capmem, <span class="literal">nil</span>, <span class="literal">false</span>)<span class="comment">//申请内存空间</span></span><br><span class="line">        memmove(p, old.array, lenmem)</span><br><span class="line">        <span class="comment">// The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length).</span></span><br><span class="line">        <span class="comment">// Only clear the part that will not be overwritten.</span></span><br><span class="line">        memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Note: can't use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.</span></span><br><span class="line">        p = mallocgc(capmem, et, <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">if</span> !writeBarrier.enabled &#123;</span><br><span class="line">            memmove(p, old.array, lenmem)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; lenmem; i += et.size &#123;</span><br><span class="line">                typedmemmove(et, add(p, i), add(old.array, i))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slice&#123;p, old.<span class="built_in">len</span>, newcap&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>针对以上问题的答案也有了：</p>
<ol>
<li>因为a,b,c的头指针地址都一样，所以其实它们都指向同一个slice，所以后面对任意一个进行改变，都会覆盖其他的改变</li>
</ol>
<ol start="2">
<li>slice作为参数传递进去，其实可以改变其中的元素，但是不能改变自己。如果需要，必须从返回值或传指针入手</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mhh12121.github.io/2019/06/05/Go/Slice/" data-id="cjxmwz4t2000jaeugbtkboj7k" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java/Java-constantPool" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/05/java/Java-constantPool/" class="article-date">
  <time datetime="2019-06-05T15:48:00.000Z" itemprop="datePublished">2019-06-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/05/java/Java-constantPool/">Java String constatn pool</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>//todo</p>
<p>字符串常量池</p>
<h3>内存结构</h3>
<p><img src="/img/jvm_memStruct.jpg" alt="Mem" title="jvm Memstruct"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mhh12121.github.io/2019/06/05/java/Java-constantPool/" data-id="cjxmwz4te000vaeug7n4zbs2e" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Go/Concurrency" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/05/Go/Concurrency/" class="article-date">
  <time datetime="2019-06-05T15:48:00.000Z" itemprop="datePublished">2019-06-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/05/Go/Concurrency/">Concurrency Problem</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>Channel</li>
</ol>
<p>1.1 互斥</p>
<p>要先明白一句话</p>
<blockquote>
<blockquote>
<p>Share memory by communication, do not communicate by sharing memory
通过通信来分享内存，而不是靠分享内存来通信</p>
</blockquote>
</blockquote>
<p>这句话应该见过无数遍了，但这就是golang channel的核心思想</p>
<p>作为channel，顾名思义，就像一个管道一样，主要就是控制数据流向（DataFlow），从而可以控制多个协程间的协作，达到互斥，同步等目的</p>
<p>1.2 当把channel当作传入参数的时候要先确定一下箭头方向</p>
<p>chan&lt;-string：指的是可以入可以出的channel
&lt;-chan string：指的是receive-only channnel</p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gobyexample 例子</span></span><br><span class="line"><span class="comment">// This `ping` function only accepts a channel for sending</span></span><br><span class="line"><span class="comment">// values. It would be a compile-time error to try to</span></span><br><span class="line"><span class="comment">// receive on this channel.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ping</span><span class="params">(pings <span class="keyword">chan</span>&lt;- <span class="keyword">string</span>, msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    pings &lt;- msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The `pong` function accepts one channel for receives</span></span><br><span class="line"><span class="comment">// (`pings`) and a second for sends (`pongs`).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pong</span><span class="params">(pings &lt;-<span class="keyword">chan</span> <span class="keyword">string</span>, pongs <span class="keyword">chan</span>&lt;- <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    msg := &lt;-pings</span><br><span class="line">    pongs &lt;- msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pings := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">    pongs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">    ping(pings, <span class="string">"passed message"</span>)</span><br><span class="line">    pong(pings, pongs)</span><br><span class="line">    fmt.Println(&lt;-pongs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>Mutex互斥量</li>
</ol>
<p>2.1 01互斥量</p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sema=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;,<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每次使用前</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    sema&lt;-<span class="keyword">struct</span>&#123;&#125;&#123;&#125;<span class="comment">//锁住，往里面加一个</span></span><br><span class="line">    balance+=amount</span><br><span class="line">    &lt;-sema<span class="comment">//释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.2 Sync.Mutex 互斥量</p>
<p>注意： golang的锁都不是可重入锁(ReentranLock),参考一下Java的 <img src="../Java-Concurrency.html" alt="可重入锁"></p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu Sync.Mutex</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	mu.Lock()</span><br><span class="line">	balance = balance + amount</span><br><span class="line">	mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func Withdraw() int &#123;</span></span><br><span class="line"><span class="comment">// 	return &lt;-balances</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock</span><br><span class="line">	b := balance</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Withdraw</span><span class="params">(amount <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">	Deposit(-amount)<span class="comment">//这里，重用了mu的锁，但是，golang不支持重入锁，所以这里会进行阻塞</span></span><br><span class="line">	<span class="keyword">if</span> Balance() &lt; <span class="number">0</span> &#123;</span><br><span class="line">		Deposit(amount)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.2.* RWMutex 读写互斥量</p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu Sync.RWMutex</span><br></pre></td></tr></table></figure></p>
<p>*** 写操作 Lock(), UnLock() ***
*** 读操作 RLock(), RUnlock() ***</p>
<p>读锁即是 同一时间允许多个读的协程，但只允许一个写的协程</p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//重写Balance()</span></span><br><span class="line"><span class="keyword">var</span> mu Sync.RWMutex</span><br><span class="line"><span class="keyword">var</span> balance <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> mu.RUnlock()</span><br><span class="line">    b:=balance</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li>Sync.WaitGroup 等待组 (Java CountDownLatch)</li>
</ol>
<p>Sync.WaitGroup
有三个methods:</p>
<ol>
<li>Add(delta int):将你要等待的协程加入，delta即加入的数量</li>
<li>Done() : 代表当前协程完成</li>
<li>Wait() : 等待所有协程完成(调用Done())，完成后即返回，否则一直阻塞</li>
</ol>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举个例子：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">(number <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> wg Sync.WaitGroup</span><br><span class="line">    wg.Add(number)<span class="comment">//要同步的协程数</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;number;i++&#123;</span><br><span class="line">        <span class="keyword">go</span> doSth(&amp;wg,i)</span><br><span class="line">    &#125;</span><br><span class="line">    begin:=Time.Now()</span><br><span class="line">    wg.Wait()<span class="comment">//完成后继续往下跑</span></span><br><span class="line">    end:=Time.Now()<span class="comment">//这里还可以这样进行批量测试</span></span><br><span class="line">    dur:=Time.Duration(end-begin)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSth</span><span class="params">(wg *Sync.WaitGroup,num <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    fmt.Println(num)</span><br><span class="line">    wg.Done()<span class="comment">//完成就Done</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="4">
<li>Sync.Once 单例（不知道怎么翻译。。。）</li>
</ol>
<p>顾名思义，就是只运行一次的意思，很显然适合单例模式
需要注意的是，Once只有一个Method
Do（func(){}）: Do方法只接受 *** 无参无返回值的函数 ***
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> once Sync.Once</span><br><span class="line">    doOnce:=<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">"do ONCE!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    done:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">            once.Do(doOnce)<span class="comment">//最终只输出一行 do ONCE！</span></span><br><span class="line">            done&lt;-<span class="literal">true</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">        &lt;-done</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mhh12121.github.io/2019/06/05/Go/Concurrency/" data-id="cjxmwz4t5000naeugnr0mmpa8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Golang/">Golang</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Design-Pattern/">Design Pattern</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/">Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/">Javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Love/">Love</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Regular-Expression/">Regular Expression</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/networking/">networking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/security/">security</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Design-Pattern/" style="font-size: 10px;">Design Pattern</a> <a href="/tags/Golang/" style="font-size: 10px;">Golang</a> <a href="/tags/Java/" style="font-size: 16.67px;">Java</a> <a href="/tags/Javascript/" style="font-size: 13.33px;">Javascript</a> <a href="/tags/Love/" style="font-size: 10px;">Love</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/Regular-Expression/" style="font-size: 10px;">Regular Expression</a> <a href="/tags/css/" style="font-size: 13.33px;">css</a> <a href="/tags/golang/" style="font-size: 20px;">golang</a> <a href="/tags/javascript/" style="font-size: 13.33px;">javascript</a> <a href="/tags/networking/" style="font-size: 10px;">networking</a> <a href="/tags/security/" style="font-size: 10px;">security</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/02/Comcon/somethingAboutTcp/">Something about Networking</a>
          </li>
        
          <li>
            <a href="/2019/06/29/Go/gRPC/">Something in gRPC</a>
          </li>
        
          <li>
            <a href="/2019/06/26/ToMyLover/">To my lover</a>
          </li>
        
          <li>
            <a href="/2019/06/21/Go/Context/">Golang Context</a>
          </li>
        
          <li>
            <a href="/2019/06/19/Go/SortedMap/">Something should be noted in golang&#39;s map</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Doujohner<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>