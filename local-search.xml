<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/08/31/Go/Practice/"/>
    <url>/2020/08/31/Go/Practice/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/08/31/Go/debug/"/>
    <url>/2020/08/31/Go/debug/</url>
    
    <content type="html"><![CDATA[<p>一些常用的debug，性能测试工具记录</p><a id="more"></a><h2 id="deubg">deubg</h2><p>gdb,dlv</p><h2 id="performance">Performance</h2><h3 id="go-pprof">Go pprof</h3><p>有两个包</p><p><code>runtime/pprof</code><code>net/pprof</code>用于网络型，可以实时监控</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">go</span> tool pprof  xxx.pprof</code></pre></div><p>也可以展示http网页</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">go</span> tool pprof -http localhost:<span class="hljs-number">9190</span> xxx.pprof</code></pre></div><h3 id="go-test">Go test</h3><p>pprof还可以与go test结合</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">go</span> test -bench . -cpuprofile=cpu.prof<span class="hljs-keyword">go</span> test -bench . -memprofile=./mem.prof</code></pre></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Transaction Isolation in Innodb</title>
    <link href="/2020/08/03/MySQL/InnoDBLock/"/>
    <url>/2020/08/03/MySQL/InnoDBLock/</url>
    
    <content type="html"><![CDATA[<p>事务的一些隔离问题</p><a id="more"></a><h2 id="事务的加锁级别">事务的加锁级别</h2><p>说到烂了</p><ol><li>Read Uncommitted读未提交，只<strong>防止脏写（其实脏写只是写并发的一个特例而已，还可能有更新丢失这种情况）</strong>，<strong>不防止脏读</strong>，这个级别他喵 的就等于没有隔离;但是注意这种对于一些sum，count操作其实是有用的，只不过我们日常少用;</li></ol><ol start="2"><li>Read Committed</li></ol><p>很多数据库默认就是这个级别，<strong>防止单条记录(读取到)的脏读</strong>，但是对于批量范围操作就力不从心，即不能防止幻读e.g:</p><ol start="3"><li>Repeatable Read</li></ol><p>在Read Commited的基础上使用快照来隔离不同版本，保证了单条记录加锁以及范围读取的加锁，新的满足查询条件的记录不能够插入，可以解决幻读 (<strong>这里指得是只读查询时的，对于读-写事务来讲，还是可能会有写倾斜</strong>),幻读指的就是同一个事务中，连续两次当前读得到了两个完全相同(一般有返回多条)的记录;如果索引(非唯一)的情况下，有Repeatable Read在这两次之间就又加了一个细化的锁(Gap Lock)保证这两次读之间不会插入新的提交值详情可以看下面的<a href>Gap锁</a></p><p>同Read Commited一样的是都有写锁，但是读不加锁，采用保存了多个版本(MVCC)来实现；</p><p>有些数据库会直接使用MVCC保存<strong>一个已提交的旧版本</strong>和一个<strong>未提交的新版本</strong>来实现<strong>Read Commited</strong>，虽然未提供完整的快照隔离，这种操作(Read Commited)是对于每一个不同的查询单独创建一个快照，而完整的快照级别隔离则需要对<strong>整个事务</strong>用<strong>一个快照</strong>进行</p><ol start="4"><li>Serilizable全部操作串行化，并发度下降，不推荐</li></ol><h3 id="写事务">写事务</h3><ul><li><p>脏写</p></li><li><p>更新丢失</p></li></ul><ul><li>写倾斜</li></ul><h3 id="锁与索引的关系">锁与索引的关系</h3><p>这里会有人问到，加锁的话怎么用索引呢？</p><ul><li>有一种方案是：索引直接指向数据对象的所有版本，然后使用一些策略过滤掉对当前事务不可见的版本，当后台gc进程决定删除某些旧对象版本时，对应的索引也要删除;一些数据库会把同一对象的不同版本放在同一个内存页中;一些有b-tree结构的数据库则使用append/copy-on-write方法，需要更新的时候会创建一个修改副本，copy一些必要的内容，然后让父节点或者递归一直到root的节点都指向新创建的节点，</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang Some bugs notes</title>
    <link href="/2020/07/23/Go/somebugs/"/>
    <url>/2020/07/23/Go/somebugs/</url>
    
    <content type="html"><![CDATA[<p>记录一些自己发现或者是他人发现的一些bug</p><a id="more"></a><h3 id="一个无限循环">一个无限循环</h3><p><a href="https://github.com/golang/go/issues/40367" target="_blank" rel="noopener">issues</a></p><p>一个奇怪的程序会陷入无限循环</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    rates := []<span class="hljs-keyword">int32</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<span class="hljs-keyword">for</span> s, r := <span class="hljs-keyword">range</span> rates &#123;<span class="hljs-keyword">if</span> s+<span class="hljs-number">1</span> &lt; <span class="hljs-number">1</span> &#123; <span class="hljs-comment">//但是将 (s+1) 换成 (s+其他数字) 则可以通过,又或者将panic去掉，改成其他，都可以通过编译</span><span class="hljs-built_in">panic</span>(<span class="hljs-string">"abc"</span>)&#125;fmt.Println(s, r)&#125;&#125;</code></pre></div><p>Expected:</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-symbol">0 </span><span class="hljs-number">1</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><span class="hljs-symbol">4 </span><span class="hljs-number">5</span></code></pre></div><p>Got:</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-number">0</span> <span class="hljs-number">1</span><span class="hljs-number">1</span> <span class="hljs-number">2</span><span class="hljs-number">2</span> <span class="hljs-number">3</span><span class="hljs-number">3</span> <span class="hljs-number">4</span><span class="hljs-number">4</span> <span class="hljs-number">5</span><span class="hljs-number">5</span> <span class="hljs-number">115616</span><span class="hljs-number">6</span> <span class="hljs-number">192</span><span class="hljs-number">7</span> <span class="hljs-number">6717248</span><span class="hljs-number">8</span> <span class="hljs-number">0</span><span class="hljs-number">9</span> <span class="hljs-number">115696</span><span class="hljs-number">10</span> <span class="hljs-number">192</span><span class="hljs-number">11</span> <span class="hljs-number">6717376</span><span class="hljs-number">12</span> <span class="hljs-number">0</span><span class="hljs-number">13</span> <span class="hljs-number">9447072</span><span class="hljs-number">14</span> <span class="hljs-number">192</span><span class="hljs-number">15</span> <span class="hljs-number">393048</span><span class="hljs-number">16</span> <span class="hljs-number">192</span><span class="hljs-number">17</span> <span class="hljs-number">4391790</span><span class="hljs-number">18</span> <span class="hljs-number">0</span><span class="hljs-number">19</span> <span class="hljs-number">139360</span><span class="hljs-number">20</span> <span class="hljs-number">192</span>......</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Notes about Zookeeper</title>
    <link href="/2020/07/10/Comcon/zookeeper/"/>
    <url>/2020/07/10/Comcon/zookeeper/</url>
    
    <content type="html"><![CDATA[<p>占坑</p><a id="more"></a><p>其名字的来源就是Yahoo的项目组，因为其内部很多以动物为名，所以一种可以方便管理多个服务的程序zookeeper就出现了…</p><p>首先，Zookeeper是一个分布式的程序，所以很自然就会采用分布式地部署(集群);</p><p>提供的功能说大不大:</p><ul><li>管理用户程序提交的数据</li><li>节点监听服务(服务治理，调度等)</li></ul><h2 id="常见的概念">常见的概念</h2><h3 id="session">Session</h3><p>顾名思义，指server和client端之间的一个连接，这个是一个TCP的长连接;</p><p>开始时，每个client都会获得一个sessionId，这个sessionID一定要保持 <strong>全局唯一</strong>，因为下面很多选举以及其他功能都要靠该字段保证</p><h3 id="znode">ZNode</h3><p>zookeeper中的节点分为两类：</p><ol><li>即是机器，机器节点</li><li>数据节点ZNode</li></ol><p>其中数据节点ZNode的数据结构其实是一种树状结构，由斜杠 <strong>/</strong> 进行分割的路径就是一个ZNode，比如/spls/hols,每个节点都有保存自己的信息，还有一系列metadata</p><p>而ZNode又可以分为<strong>持久节点(PERSISTENT)<strong>和</strong>临时节点(EPHEMERAL)</strong>;</p><p>顾名思义，持久指的是除非被进行显式移除操作，否则会一直存在zookeeper中，而临时节点一般是与session绑定，一旦session过期或者失效就会立即被移除；</p><p>这里还有另外两种ZNode:</p><ul><li>持久顺序节点(PERSISTENT_SEQUENTIAL), 同持久节点差不多,额外允许一个SEQUENTIAL参数(int)，由父节点维护的自增数字，会加在当前节点后面;</li><li>临时顺序节点(EPHEMERAL_SEQUENTIAL), 同临时节点差不多只不过就是增加了一个顺序参数;</li></ul><h2 id="zab协议">ZAB协议</h2><p>这里就是重头戏了！！！</p><p>ZAB协议是专门给zookeeper设计的支持崩溃回复的原子广播协议，其包括两种模式：</p><ul><li>崩溃模式</li><li>消息广播</li></ul><h3 id="消息广播">消息广播</h3><p>这个是最基本的一个模式，实际上同2PC十分接近:步骤大概如下:</p><ol><li>Leader将client的request转化成一个Proposal</li><li>Leader为每一个Follower准备了一个FIFO队列，并把proposal发送到队列上；</li><li>Follower会从队列头部拿出proposal，然后将ACK放入回队列中,</li><li>Leader如果从队列收到follower一半以上ACK反馈，就会将commit又发回到队列中</li><li>Follower继续从队列头部拿数据，拿到commit命令就完成;</li></ol><p>但是这里每一步中leader都可能崩溃(毕竟Leader压力也大)接下来就要进入到崩溃模式</p><h3 id="崩溃模式">崩溃模式</h3><p>大家都要恰饭，不可能等leader自己好起来，所以就要选举一个新的leader，这里很自然就涉及两个操作</p><ul><li>选举新的leader</li><li>新的leader要继续之前的工作</li></ul><h4 id="选举新的leader">选举新的leader</h4><p>这里首先可以描述几个状态:</p><ul><li>Looking状态</li><li>following状态</li><li>Leading状态</li></ul><p>比较容易理解，至于选举的时机,无疑就是在 初始化程序的时候 和 leader崩溃后</p><p>之前的文章有写过raft等分布式协议，ZAB也是一个有选举的协议，所以一定有：</p><h5 id="任命周期">任命周期</h5><p><strong>election epoch</strong>，对应于raft的term，一般分布式协议都有以消息标记一个事件，这种事件会同其他事件区分开，而区分的方法很多就是使用了时间戳；ZAB中，每个消息都赋予了一个zxid，zxid全局唯一；</p><p>zxid由两部分组成:</p><ul><li>高32位为epoch</li><li>低32位为epoch内自增id，每次epoch更新，低32位自增id就会归0 （万一一直不更新？？？）</li></ul><h5 id="log">log</h5><p>ZAB和raft一样都是基于复制状态机(replicated state machine)来记录不同机器的行为，其都使用log来记录一般有两种方式:</p><ul><li>所有日志取最新的一条 (raft,ZAB)</li><li>所有已提交的最新的一条</li></ul><p>Zookeeper: peerEpoch大的优先，然后到zxid大的优先Raft: Term大的优先，再到entry的index大的优先</p><p>但是这里Zookeeper与raft有一些不同的是：</p><p>Zookeeper会将两个比较分为两轮，而Raft会结合到一起进行判断 （？？？）</p><p>但是关于log的最新值问题之前已经讨论过，raft中可能会有<img src="/img/logSequenceProblem.png" srcset="/img/loading.gif" alt="这种情况"></p><p>(a)中S1是leader，且部分复制到log entry到其他机子，暂时只复制到S2;</p><p>(b)S1崩溃，S5在接收到 S3，S4以及自己的vote 选举成功，进入新的term，并接受了一个<strong>不同的entry(index 2)</strong></p><p>©接着S5崩溃，S1重启，被选举为leader，然后继续复制状态，在这个时候term 2 的log已经被大多数的机子复制，但是未commit，这个时候接下来就可能有两种情况:</p><ul><li><p>(d1) 如果S1再次崩溃，S5会再次被选举（接到S2，S3，S4）的vote，然后用自己term3的entry覆盖所有的entry（即使在©的情况下，S1的log entry已经被大部分接收，但未commit，也可能会被覆盖）</p></li><li><p>(d2) 然而如果S1在崩溃前复制自己term的entry到一半以上的机子，这时候根据规则就会commit(因为S5是不会赢得选举);这个就是理想的状态,为了解决(d1)覆盖问题，raft <strong>不允许</strong> commit 前一个term的log entry;</p></li></ul><p>选举出来的leader可能不包含已经提交过的log，raft针对这个做出了一个限制：</p><ul><li>log的提交不能直接提交之前term的已经过半的entry，意思是如果遇到这些term过半的entry就视为未提交的其原因就是，raft选举永远是单向的</li></ul><blockquote><blockquote><p>This means that log entries only flow in one direction, from leaders to followers, and leaders never overwrite existing entries in their logs</p></blockquote></blockquote><p>解决这个问题，都很明显，双向确认即可，Zookeeper即是采用该手段，每次选举完leader后，都会更新follower的log，所以每一轮大家的数据都会保持一致(???具体代码)</p><h5 id="投票次数">投票次数</h5><p>Raft每个server每一轮只投一次，一般来讲哪些candidate先RequestVote就会先获得投票，这样的结果是可能会造成所有candidate都没有收到过半的票然后重试；raft解决这个方法就是随机 + - 时间来发起投票;</p><p>Zookeeper每个server在某个electionEpoch内，可以投多次票，只要遇到更大的票就更新，然后再分发新的票给所有server，这样不会造成raft投票不成功的现象，同时也可以选出含有log更多的server(???)，但是明显时间就会花费更多;</p><h5 id="重启server加入集群中">重启server加入集群中</h5><p>Raft启动后，会收到leader的appendEntries；Zookeeper的server启动后，会向所有server发送投票通知，这个时候收到处在LOOKING，FOLLOWING的server的投票，则该server放弃自己的投票（？？？？）</p>]]></content>
    
    
    
    <tags>
      
      <tag>Distributed</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang type</title>
    <link href="/2020/06/24/Go/type/"/>
    <url>/2020/06/24/Go/type/</url>
    
    <content type="html"><![CDATA[<p>//todo</p><a id="more"></a><p>类型</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// a copy of runtime.typeAlg</span><span class="hljs-keyword">type</span> typeAlg <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">// function for hashing objects of this type</span>    <span class="hljs-comment">// (ptr to object, seed) -&gt; hash</span>    <span class="hljs-comment">//用作识别</span>hash <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(unsafe.Pointer, <span class="hljs-keyword">uintptr</span>)</span> <span class="hljs-title">uintptr</span></span><span class="hljs-comment">// function for comparing objects of this type</span>    <span class="hljs-comment">// (ptr to object A, ptr to object B) -&gt; ==?</span>    <span class="hljs-comment">//用作表明该类型是不是可比较的(string就是不可比较的,</span>    <span class="hljs-comment">//context.WithValue传入的key就是要求要是可比较的)</span>equal <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(unsafe.Pointer, unsafe.Pointer)</span> <span class="hljs-title">bool</span></span>&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang指针</title>
    <link href="/2020/05/03/Go/Pointer/"/>
    <url>/2020/05/03/Go/Pointer/</url>
    
    <content type="html"><![CDATA[<p>比较容易混淆三种值:</p><a id="more"></a><p>指针值(Pointer value):比如stirng,int这种其实是一种指针值</p><p>指针(Pointer)</p><p>uintptr</p><div class="hljs"><pre><code class="hljs go"> <span class="hljs-comment">// Pointer represents a pointer to an arbitrary type. There are four special operations</span><span class="hljs-comment">// available for type Pointer that are not available for other types:</span><span class="hljs-comment">//- A pointer value of any type can be converted to a Pointer.</span><span class="hljs-comment">//gc的时候会有write barrier</span>unsafe.Pointer(&amp;a)<span class="hljs-comment">//- A Pointer can be converted to a pointer value of any type.</span>(*<span class="hljs-keyword">string</span>)(unsafe.Pointer(somePointer))<span class="hljs-comment">//- A uintptr can be converted to a Pointer.</span>unsafe.Pointer(<span class="hljs-keyword">uintptr</span>(somePointer)+unsafe.sizeof(&amp;a))<span class="hljs-comment">//- A Pointer can be converted to a uintptr.</span><span class="hljs-keyword">uintptr</span>(unsafe.Pointer(&amp;a))</code></pre></div><p>因为指针可以随意读取内存而不经过go自己的type系统，要谨慎使用，注释里面有写到不可用作临时变量，如下：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">//错误！</span>tmp := <span class="hljs-keyword">uintptr</span>(unsafe.Pointer(&amp;x)) + unsafe.Offsetof(x.b)pb := (*<span class="hljs-keyword">int16</span>)(unsafe.Pointer(tmp))*pb = <span class="hljs-number">42</span></code></pre></div><p>这里主要跟gc的实现有关系，有时候垃圾回收器会移动（整理）一些变量来降低碎片度；变量被移动后当然其地址也会被改变，这个指针就要指向新地址。</p><p>而上面这段代码中unsafe.Pointer就是一个<strong>指向变量的指针</strong>，被移动后就要改变，但是tmp实际在这段代码中却是作为一个<strong>普通的整数</strong>，值不应该被改变!</p><p>因为垃圾回收器<strong>识别不出</strong>上面tmp其实是一个<strong>指向x的指针</strong>，当到第二行时，可能x地址已经被转移，tmp此时就不会是这个地址了，第三行可能向一个不知道什么地址赋值，肯定会出错。</p><p>还有一些:</p><div class="hljs"><pre><code class="hljs go">pT := <span class="hljs-keyword">uintptr</span>(unsafe.Pointer(<span class="hljs-built_in">new</span>(T))) <span class="hljs-comment">// 提示: 错误!</span></code></pre></div><p>这里new(T)创建后并没有指针引用，这行跑完后垃圾回收器可能会立即回收掉内存空间，所以pT得到的就是无效的地址</p><p>比较常见的</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Bytes2String</span><span class="hljs-params">(b []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">string</span></span>&#123;    <span class="hljs-keyword">return</span> *(*<span class="hljs-keyword">string</span>)(unsafe.Pointer(&amp;b))&#125;</code></pre></div><h2 id="uinputr">uinputr</h2><p>uintptr是一个整数，但是它没有指针的语义，即使它有保存某个对象的地址，但是垃圾回收器在这个对象转移的时候也不会更新uintptr的值，除非重新声明这个对象（很自然就不会有写屏障)</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// A uintptr is an integer, not a reference.</span><span class="hljs-comment">// Converting a Pointer to a uintptr creates an integer value</span><span class="hljs-comment">// with no pointer semantics.</span><span class="hljs-comment">// Even if a uintptr holds the address of some object,</span><span class="hljs-comment">// the garbage collector will not update that uintptr's value</span><span class="hljs-comment">// if the object moves, nor will that uintptr keep the object</span><span class="hljs-comment">// from being reclaimed.</span><span class="hljs-comment">//</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL InnoDB Ｂ+tree</title>
    <link href="/2020/04/03/MySQL/btree/"/>
    <url>/2020/04/03/MySQL/btree/</url>
    
    <content type="html"><![CDATA[<p>我们都知道计算机在存储数据的时候，有最小存储单元;</p><p>在计算机中磁盘(机械硬盘)存储数据最小单元是<strong>扇区</strong>，一个扇区的大小是512字节，而文件系统（例如XFS/EXT4）他的最小单元是块，一个块的大小是4k，而对于我们的InnoDB存储引擎也有自己的最小储存单元——页（Page），一个页的大小是16K。</p>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang Reflection</title>
    <link href="/2020/03/26/Go/Reflect/"/>
    <url>/2020/03/26/Go/Reflect/</url>
    
    <content type="html"><![CDATA[<h2 id="reflect-package">Reflect Package</h2><a id="more"></a><h3 id="1-reflect-type">1. reflect.Type</h3><div class="hljs"><pre><code class="hljs go"></code></pre></div><h3 id="2-reflect-kind">2. reflect.Kind</h3><h2 id="interface">Interface{}</h2><p>接下来说一说经常用到的 interface{} 结构体，传参的时候如果接收参数是interface{}，其实就用到隐式的反射，但是这个interface{}本身的属性也比较特殊；</p><p>我们可以先看一个问题:</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">interface</span>&#123;    Walk()&#125;<span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cat)</span> <span class="hljs-title">Walk</span><span class="hljs-params">()</span></span>&#123;    log.Println(<span class="hljs-string">"walking! cat"</span>)&#125;<span class="hljs-keyword">type</span> i2 <span class="hljs-keyword">interface</span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">var</span> t1 i1    <span class="hljs-keyword">var</span> t2 i2    <span class="hljs-keyword">if</span> t1==t2&#123;        log.Println(<span class="hljs-string">"equal!"</span>)    &#125;<span class="hljs-keyword">else</span>&#123;        log.Println(<span class="hljs-string">"nope!"</span>)    &#125;&#125;</code></pre></div><p>除了反射其还可以当做原本的用途： 多态 （OOP）的特征之一，只是golang是ducktype类型，实现多态的几个要求：</p><ol><li>有interface接口和方法，有子类把那个接口的方法都实现了，编译器就会自动认为这个结构体就是使用了这个接口</li><li>父类指针指向子类的具体对象</li></ol><p>满足以上就可以实现<strong>多态</strong></p><p>一般有两种写法：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">//方法内嵌</span><span class="hljs-keyword">type</span> doInterfaceWithMethod <span class="hljs-keyword">interface</span>&#123;    Do1(<span class="hljs-keyword">string</span>) <span class="hljs-keyword">string</span>&#125;<span class="hljs-comment">//方法放在外面</span><span class="hljs-keyword">type</span> doInterfaceWithoutMethod <span class="hljs-keyword">interface</span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *doInterfaceWithoutMethod)</span> <span class="hljs-title">Do1</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span>&#123;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang sync.Pool</title>
    <link href="/2020/03/24/Go/syncPool/"/>
    <url>/2020/03/24/Go/syncPool/</url>
    
    <content type="html"><![CDATA[<p>golang进程池</p><a id="more"></a><h1>Sync.Pool</h1><p>这个是1.13后的大改进，大幅度削减开销;首先明确一个<strong>目标</strong>就是：</p><p>池类技术都是为了减少资源的多次分配，在这里就是<strong>减少GC</strong>的压力，以及提高缓存命中率</p><h2 id="结构">结构</h2><p>相关内容主要在 sync/pool.go 和 sync/poolqueue.go上</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Pool <span class="hljs-keyword">struct</span> &#123;noCopy noCopy <span class="hljs-comment">//这个是一个保证了第一次使用不会被copy的结构,防止被复制，很多结构也有用到这个，比如syncgroup等</span><span class="hljs-comment">//本地per-P的固定大小的pool，具体结构其实是[P]poolLocal</span>local     unsafe.Pointer <span class="hljs-comment">// local fixed-size per-P pool, actual type is [P]poolLocal</span>localSize <span class="hljs-keyword">uintptr</span>        <span class="hljs-comment">// size of the local array</span>  <span class="hljs-comment">//1.13的重要更新！！！这个东西实际上在gc用到（会将其保存下来避免gc），后面再说</span>    victim     unsafe.Pointer <span class="hljs-comment">// local from previous cycle</span>victimSize <span class="hljs-keyword">uintptr</span>        <span class="hljs-comment">// size of victims array</span><span class="hljs-comment">// New optionally specifies a function to generate</span><span class="hljs-comment">// a value when Get would otherwise return nil.</span><span class="hljs-comment">// It may not be changed concurrently with calls to Get.</span>New <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">interface</span></span>&#123;&#125;&#125;<span class="hljs-keyword">type</span> poolLocal <span class="hljs-keyword">struct</span> &#123;poolLocalInternal<span class="hljs-comment">// Prevents false sharing on widespread platforms with</span><span class="hljs-comment">// 128 mod (cache line size) = 0 .</span>pad [<span class="hljs-number">128</span> - unsafe.Sizeof(poolLocalInternal&#123;&#125;)%<span class="hljs-number">128</span>]<span class="hljs-keyword">byte</span>&#125;<span class="hljs-comment">// Local per-P Pool appendix.</span><span class="hljs-keyword">type</span> poolLocalInternal <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">//不为空可以复用，如果为空则要从shared队列拿对象</span>private <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// Can be used only by the respective P.</span>shared  poolChain   <span class="hljs-comment">// Local P can pushHead/popHead; any P can popTail.</span>&#125;</code></pre></div><p>容易想到池类技术多用队列来实现;</p><p>但是这里使用了让人感叹“喵啊喵啊”的结构：<strong>环式队列</strong></p><h3 id="pooldequeue">poolDequeue</h3><h4 id="基本结构">基本结构</h4><p>poolDequeue是一个无锁，固定大小，单生产者，多消费者的一个环形队列，生产者可以在head或者tail加上元素，但是消费者只能在tail消费</p><p>其特点就是会将<strong>不使用的slots设为nil</strong>，这一点咋一看不是觉得应该这样做嘛，但细节上还是有点复杂,下面先看一下基本结构</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> poolDequeue <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">// headTail packs together a 32-bit head index and a 32-bit</span><span class="hljs-comment">// tail index. Both are indexes into vals modulo len(vals)-1.</span><span class="hljs-comment">//</span><span class="hljs-comment">// tail = index of oldest data in queue</span><span class="hljs-comment">// head = index of next slot to fill</span><span class="hljs-comment">//头部，生产者放入data</span><span class="hljs-comment">// Slots in the range [tail, head) are owned by consumers.</span><span class="hljs-comment">//消费者只消费tail</span><span class="hljs-comment">// A consumer continues to own a slot outside this range until</span><span class="hljs-comment">// it nils the slot, at which point ownership passes to the</span><span class="hljs-comment">// producer.</span><span class="hljs-comment">//</span><span class="hljs-comment">// The head index is stored in the most-significant bits so</span><span class="hljs-comment">// that we can atomically add to it and the overflow is</span><span class="hljs-comment">// harmless.</span>headTail <span class="hljs-keyword">uint64</span><span class="hljs-comment">// vals is a ring buffer of interface&#123;&#125; values stored in this</span><span class="hljs-comment">// dequeue. The size of this must be a power of 2.</span><span class="hljs-comment">//</span><span class="hljs-comment">//vals就是这个环形buffer，长度是2的幂次</span><span class="hljs-comment">// vals[i].typ is nil if the slot is empty and non-nil</span><span class="hljs-comment">// otherwise. A slot is still in use until *both* the tail</span><span class="hljs-comment">// index has moved beyond it and typ has been set to nil. This</span><span class="hljs-comment">// is set to nil atomically by the consumer and read</span><span class="hljs-comment">// atomically by the producer.</span>vals []eface&#125; <span class="hljs-comment">// 类似于没有方法 interface&#123;&#125;</span><span class="hljs-keyword">type</span> eface <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">//这个slot是空的话，typ将会=nil；</span><span class="hljs-comment">//而且每次读写改变slot状态都会是原子性操作</span>typ, val unsafe.Pointer&#125;<span class="hljs-comment">//还有一些定义</span><span class="hljs-comment">// dequeueLimit is the maximum size of a poolDequeue.</span><span class="hljs-comment">//</span><span class="hljs-comment">// This must be at most (1&lt;&lt;dequeueBits)/2 because detecting fullness</span><span class="hljs-comment">// depends on wrapping around the ring buffer without wrapping around</span><span class="hljs-comment">// the index. We divide by 4 so this fits in an int on 32-bit.</span><span class="hljs-keyword">const</span> dequeueLimit = (<span class="hljs-number">1</span> &lt;&lt; dequeueBits) / <span class="hljs-number">4</span></code></pre></div><p>先回答一下之前的问题：</p><ul><li>vals[i].typ如果是nil = 该slot为空否则一定为空(必要条件)</li><li>判断slot是否还在被使用要结合index(已经移到前面即为空)和vals[i].typ是否为空来决定</li><li>消费者设置其为nil以及生产者读取都是<strong>原子操作</strong></li></ul><p>还有可以看到上面规定了dequeue的最大limit，为什么呢？上面的解释是 检测是否队列满取决于该ring buffer而不是其index，理解&gt;???</p><h4 id="pushhead">pushHead</h4><p>队列，由 <strong>单个</strong> 生产者推入head，如果满了就返回false;</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">const</span> dequeueBits = <span class="hljs-number">32</span><span class="hljs-comment">// pushHead adds val at the head of the queue. It returns false if the</span><span class="hljs-comment">// queue is full. It must only be called by a single producer.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *poolDequeue)</span> <span class="hljs-title">pushHead</span><span class="hljs-params">(val <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span> &#123;ptrs := atomic.LoadUint64(&amp;d.headTail)<span class="hljs-comment">//根据headTail计算出真正的head和tail</span>head, tail := d.unpack(ptrs) <span class="hljs-comment">//这里的dequeueBits</span><span class="hljs-comment">//const dequeueBits = 32</span><span class="hljs-comment">//这里判断???  </span><span class="hljs-keyword">if</span> (tail+<span class="hljs-keyword">uint32</span>(<span class="hljs-built_in">len</span>(d.vals)))&amp;(<span class="hljs-number">1</span>&lt;&lt;dequeueBits<span class="hljs-number">-1</span>) == head &#123;<span class="hljs-comment">// Queue is full.</span><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;slot := &amp;d.vals[head&amp;<span class="hljs-keyword">uint32</span>(<span class="hljs-built_in">len</span>(d.vals)<span class="hljs-number">-1</span>)]<span class="hljs-comment">// Check if the head slot has been released by popTail.</span>typ := atomic.LoadPointer(&amp;slot.typ)<span class="hljs-keyword">if</span> typ != <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">// Another goroutine is still cleaning up the tail, so</span><span class="hljs-comment">// the queue is actually still full.</span><span class="hljs-comment">//其他goroutine正在清除(consume)tail</span><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<span class="hljs-comment">// The head slot is free, so we own it.</span><span class="hljs-keyword">if</span> val == <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">//这里实际上是*struct&#123;&#125;类型，代表interface&#123;&#125;(nil)，因为我们使用nil来代表空的slot，所以要一种sentinel value (可以理解为标记值) 来代表nil</span>val = dequeueNil(<span class="hljs-literal">nil</span>)&#125;<span class="hljs-comment">//slot是eface类型，slot转为interface&#123;&#125;，val就可以直接赋值给slot，又因为eface是interface&#123;&#125;其中一种实现，slot.typ和slot.val则不为空, 这里其实也是之前判断是否满队列的原因</span>*(*<span class="hljs-keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot)) = val<span class="hljs-comment">// Increment head. This passes ownership of slot to popTail</span><span class="hljs-comment">// and acts as a store barrier for writing the slot.</span><span class="hljs-comment">//插入后head +1 </span>atomic.AddUint64(&amp;d.headTail, <span class="hljs-number">1</span>&lt;&lt;dequeueBits)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-comment">//计算head和tail的index</span><span class="hljs-comment">//实际前32位是head，后32位是tail</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *poolDequeue)</span> <span class="hljs-title">unpack</span><span class="hljs-params">(ptrs <span class="hljs-keyword">uint64</span>)</span> <span class="hljs-params">(head, tail <span class="hljs-keyword">uint32</span>)</span></span> &#123;<span class="hljs-comment">//dequeueBits = 32</span><span class="hljs-keyword">const</span> mask = <span class="hljs-number">1</span>&lt;&lt;dequeueBits - <span class="hljs-number">1</span>head = <span class="hljs-keyword">uint32</span>((ptrs &gt;&gt; dequeueBits) &amp; mask)tail = <span class="hljs-keyword">uint32</span>(ptrs &amp; mask)<span class="hljs-keyword">return</span>&#125;</code></pre></div><h4 id="poptail">PopTail</h4><p>这个就是消费者(<strong>多个</strong>)所用的，pop出队列尾的元素</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *poolDequeue)</span> <span class="hljs-title">popTail</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-keyword">bool</span>)</span></span> &#123;<span class="hljs-keyword">var</span> slot *eface<span class="hljs-keyword">for</span> &#123;ptrs := atomic.LoadUint64(&amp;d.headTail)head, tail := d.unpack(ptrs)<span class="hljs-comment">//同样，先判断是否为空</span><span class="hljs-keyword">if</span> tail == head &#123;<span class="hljs-comment">// Queue is empty.</span><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>&#125;<span class="hljs-comment">// Confirm head and tail (for our speculative check</span><span class="hljs-comment">// above) and increment tail. If this succeeds, then</span><span class="hljs-comment">// we own the slot at tail.</span>ptrs2 := d.pack(head, tail+<span class="hljs-number">1</span>)<span class="hljs-keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;<span class="hljs-comment">// Success.</span>slot = &amp;d.vals[tail&amp;<span class="hljs-keyword">uint32</span>(<span class="hljs-built_in">len</span>(d.vals)<span class="hljs-number">-1</span>)]<span class="hljs-keyword">break</span>&#125;&#125;<span class="hljs-comment">// We now own slot.</span>val := *(*<span class="hljs-keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot))<span class="hljs-keyword">if</span> val == dequeueNil(<span class="hljs-literal">nil</span>) &#123;val = <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// Tell pushHead that we're done with this slot. Zeroing the</span><span class="hljs-comment">// slot is also important so we don't leave behind references</span><span class="hljs-comment">// that could keep this object live longer than necessary.</span><span class="hljs-comment">//</span><span class="hljs-comment">// We write to val first and then publish that we're done with</span><span class="hljs-comment">// this slot by atomically writing to typ.</span><span class="hljs-comment">//将当前的slot设为空</span>slot.val = <span class="hljs-literal">nil</span>atomic.StorePointer(&amp;slot.typ, <span class="hljs-literal">nil</span>)<span class="hljs-comment">// At this point pushHead owns the slot.</span><span class="hljs-keyword">return</span> val, <span class="hljs-literal">true</span>&#125;</code></pre></div><h4 id="pophead">PopHead</h4><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// popHead removes and returns the element at the head of the queue.</span><span class="hljs-comment">// It returns false if the queue is empty. It must only be called by a</span><span class="hljs-comment">// single producer.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *poolDequeue)</span> <span class="hljs-title">popHead</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-keyword">bool</span>)</span></span> &#123;<span class="hljs-keyword">var</span> slot *eface<span class="hljs-keyword">for</span> &#123;ptrs := atomic.LoadUint64(&amp;d.headTail)<span class="hljs-comment">//解析出head，tail</span>head, tail := d.unpack(ptrs)<span class="hljs-keyword">if</span> tail == head &#123;<span class="hljs-comment">// Queue is empty.</span><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>&#125;<span class="hljs-comment">// Confirm tail and decrement head. We do this before</span><span class="hljs-comment">// reading the value to take back ownership of this</span><span class="hljs-comment">// slot.</span><span class="hljs-comment">//pophead即是head--，然后再用pack计算出pophead之后的ptr2，然后用原子方法设置ptr为ptr2,放回d.headTail,并取出其slot</span>head--ptrs2 := d.pack(head, tail)<span class="hljs-keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;<span class="hljs-comment">//成功更新该slot，跳出循环</span><span class="hljs-comment">// We successfully took back slot.</span>slot = &amp;d.vals[head&amp;<span class="hljs-keyword">uint32</span>(<span class="hljs-built_in">len</span>(d.vals)<span class="hljs-number">-1</span>)]<span class="hljs-keyword">break</span>&#125;<span class="hljs-comment">//如果失败了，重新进行</span><span class="hljs-comment">//失败的情况可能是更新失败，</span>&#125;val := *(*<span class="hljs-keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot))<span class="hljs-keyword">if</span> val == dequeueNil(<span class="hljs-literal">nil</span>) &#123;val = <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// Zero the slot. Unlike popTail, this isn't racing with</span><span class="hljs-comment">// pushHead, so we don't need to be careful here.</span>*slot = eface&#123;&#125;<span class="hljs-keyword">return</span> val, <span class="hljs-literal">true</span>&#125;</code></pre></div><ul><li>注意： 至于为什么要先设置headTail，再取slot，目的是可能其他P会在当前P steal对象，多个P调用本地P的popTail的时候，race现象就变严重，这样做让某个P如果拿到了，其他P就无法再拿到对应的对象（因为headtail改变了，位置不一样）</li></ul><h3 id="poolchain">PoolChain</h3><p>其中还有一个结构是配合pooldequeue实现了双线链表的poolChain可以看做poolchain实际上就是一个<strong>动态大小</strong>版本的poolDeque</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// poolChain is a dynamically-sized version of poolDequeue.</span><span class="hljs-comment">//poolchain实际上就是一个动态大小版本的poolDeque</span><span class="hljs-comment">// This is implemented as a doubly-linked list queue of poolDequeues</span><span class="hljs-comment">// where each dequeue is double the size of the previous one. Once a</span><span class="hljs-comment">// dequeue fills up, this allocates a new one and only ever pushes to</span><span class="hljs-comment">// the latest dequeue. Pops happen from the other end of the list and</span><span class="hljs-comment">// once a dequeue is exhausted, it gets removed from the list.</span><span class="hljs-comment">//这个poolchain实际就是有双倍长度的poolDequeue，当其中一个dequeue被填充数据，其会分配一个新的dequeue，且把这个填充数据放入最新的一个dequeue上；</span><span class="hljs-keyword">type</span> poolChain <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">//因为只被生产者所用(推入)，不保证顺序，所以不必要保证串行性</span><span class="hljs-comment">// head is the poolDequeue to push to. This is only accessed</span><span class="hljs-comment">// by the producer, so doesn't need to be synchronized.</span>head *poolChainElt<span class="hljs-comment">// tail is the poolDequeue to popTail from. This is accessed</span><span class="hljs-comment">// by consumers, so reads and writes must be atomic.</span>tail *poolChainElt&#125;<span class="hljs-keyword">type</span> poolChainElt <span class="hljs-keyword">struct</span> &#123;poolDequeue<span class="hljs-comment">// next and prev link to the adjacent poolChainElts in this</span><span class="hljs-comment">// poolChain.</span><span class="hljs-comment">//这里的next和prev指向相邻的poolChain元素,其中next是被生产者所写，消费者读取，只能从nil变为non-nil,prev则刚好相反</span><span class="hljs-comment">// next is written atomically by the producer and read</span><span class="hljs-comment">// atomically by the consumer. It only transitions from nil to</span><span class="hljs-comment">// non-nil.</span><span class="hljs-comment">//</span><span class="hljs-comment">// prev is written atomically by the consumer and read</span><span class="hljs-comment">// atomically by the producer. It only transitions from</span><span class="hljs-comment">// non-nil to nil.</span>next, prev *poolChainElt&#125;</code></pre></div><p>同理，同poolDequeue一样,包裹着它的poolChaint也有一样的方法：</p><h4 id="pushhead-v2">pushHead</h4><p>生产者增加元素,注意在当前ring buffer满了之后会初始化一个新的poolChainElt，其中poolDequque大小为原来的2倍</p><ul><li>该链表poolChain的初始化大小为8</li><li>每次增多一个poolDequeue是前一个的2倍，且一定是2的幂次</li><li>poolDequeue的最大的长度是2^30，再多的poolDequeue也不会变</li></ul><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *poolChain)</span> <span class="hljs-title">pushHead</span><span class="hljs-params">(val <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;d := c.head<span class="hljs-keyword">if</span> d == <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">// Initialize the chain.</span><span class="hljs-keyword">const</span> initSize = <span class="hljs-number">8</span> <span class="hljs-comment">// Must be a power of 2</span>d = <span class="hljs-built_in">new</span>(poolChainElt)d.vals = <span class="hljs-built_in">make</span>([]eface, initSize)c.head = dstorePoolChainElt(&amp;c.tail, d)&#125;<span class="hljs-comment">//先把该val插入到pooldeqeue中</span><span class="hljs-keyword">if</span> d.pushHead(val) &#123;<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// The current dequeue is full. Allocate a new one of twice</span><span class="hljs-comment">// the size.</span><span class="hljs-comment">//当前pooldequeue满了,则设置一个新的poolDeque,!!!</span><span class="hljs-comment">//且新大小为前一次pooldequeue的两倍</span>newSize := <span class="hljs-built_in">len</span>(d.vals) * <span class="hljs-number">2</span><span class="hljs-comment">//dequeueLimit为最大的size，</span><span class="hljs-comment">//const dequeueLimit = (1&lt;&lt;dequeueBits)/4 = 2^30</span><span class="hljs-keyword">if</span> newSize &gt;= dequeueLimit &#123;<span class="hljs-comment">// Can't make it any bigger.</span>newSize = dequeueLimit&#125;d2 := &amp;poolChainElt&#123;prev: d&#125;d2.vals = <span class="hljs-built_in">make</span>([]eface, newSize)c.head = d2<span class="hljs-comment">//实际就是将d.next指向新的一个ring buffer(poolChainElt),其结构体下面有</span>storePoolChainElt(&amp;d.next, d2)d2.pushHead(val)&#125;</code></pre></div><h4 id="poptail-v2">popTail</h4><p>消费者消费队列</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *poolChain)</span> <span class="hljs-title">popTail</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-keyword">bool</span>)</span></span> &#123;d := loadPoolChainElt(&amp;c.tail)<span class="hljs-keyword">if</span> d == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>&#125;<span class="hljs-keyword">for</span> &#123;<span class="hljs-comment">// It's important that we load the next pointer</span><span class="hljs-comment">// *before* popping the tail. In general, d may be</span><span class="hljs-comment">// transiently empty, but if next is non-nil before</span><span class="hljs-comment">// the pop and the pop fails, then d is permanently</span><span class="hljs-comment">// empty, which is the only condition under which it's</span><span class="hljs-comment">// safe to drop d from the chain.</span>d2 := loadPoolChainElt(&amp;d.next)<span class="hljs-keyword">if</span> val, ok := d.popTail(); ok &#123;<span class="hljs-keyword">return</span> val, ok&#125;<span class="hljs-keyword">if</span> d2 == <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">// This is the only dequeue. It's empty right</span><span class="hljs-comment">// now, but could be pushed to in the future.</span><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>&#125;<span class="hljs-comment">// The tail of the chain has been drained, so move on</span><span class="hljs-comment">// to the next dequeue. Try to drop it from the chain</span><span class="hljs-comment">// so the next pop doesn't have to look at the empty</span><span class="hljs-comment">// dequeue again.</span><span class="hljs-comment">//这里注意</span><span class="hljs-keyword">if</span> atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;c.tail)), unsafe.Pointer(d), unsafe.Pointer(d2)) &#123;<span class="hljs-comment">// We won the race. Clear the prev pointer so</span><span class="hljs-comment">// the garbage collector can collect the empty</span><span class="hljs-comment">// dequeue and so popHead doesn't back up</span><span class="hljs-comment">// further than necessary.</span>storePoolChainElt(&amp;d2.prev, <span class="hljs-literal">nil</span>)&#125;d = d2&#125;&#125;</code></pre></div><ul><li>！！！！注意到上面有一段原子操作，主要可能有<strong>消费者是其他P</strong>的情况下， <strong>popTail</strong> 明显就与popHead以及pushHead有race</li></ul><h4 id="pophead-v2">popHead</h4><p>逻辑比较简单，一个个pooldequeue去找，找完就往前一个元素继续</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *poolChain)</span> <span class="hljs-title">popHead</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-keyword">bool</span>)</span></span> &#123;d := c.head<span class="hljs-keyword">for</span> d != <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">//首先从pooldequeue中pophead</span><span class="hljs-keyword">if</span> val, ok := d.popHead(); ok &#123;<span class="hljs-keyword">return</span> val, ok&#125;<span class="hljs-comment">// There may still be unconsumed elements in the</span><span class="hljs-comment">// previous dequeue, so try backing up.</span><span class="hljs-comment">//pop完当前的pooldequeue则load前面的poolChainElt</span>d = loadPoolChainElt(&amp;d.prev)&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>&#125;</code></pre></div><p>综合上面的各个结构，大概画了<img src="/img/syncpool.png" srcset="/img/loading.gif" alt="一个图"></p><p>看到这里可能就有点疑问了，<strong>为啥有popTail，又要有popHead呢？？？</strong>这也是其设计的 “喵啊喵啊” 之处，具体可以继续看下面的**Get()**方法</p><h3 id="由功能出发-猜结构">由功能出发，猜结构</h3><p>上面谈到的两种结构都有点印象了，下面就是真正如何使用:池类技术不用问，get，set(put)各一个，还有超过了size之后的清空</p><h4 id="put">Put</h4><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// Put adds x to the pool.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span> <span class="hljs-title">Put</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">if</span> race.Enabled &#123;<span class="hljs-keyword">if</span> fastrand()%<span class="hljs-number">4</span> == <span class="hljs-number">0</span> &#123;<span class="hljs-comment">// Randomly drop x on floor.</span><span class="hljs-keyword">return</span>&#125;race.ReleaseMerge(poolRaceAddr(x))race.Disable()    &#125;    <span class="hljs-comment">//这里pin</span>l, _ := p.pin()<span class="hljs-keyword">if</span> l.private == <span class="hljs-literal">nil</span> &#123;l.private = xx = <span class="hljs-literal">nil</span>&#125;<span class="hljs-keyword">if</span> x != <span class="hljs-literal">nil</span> &#123;l.shared.pushHead(x)&#125;runtime_procUnpin()<span class="hljs-keyword">if</span> race.Enabled &#123;race.Enable()&#125;&#125;</code></pre></div><p>这里的 l, _ := p.pin() <strong>pin()</strong> 函数就值得深入看一下:</p><ol><li>大概意思就是，这个pin函数会pin住当前goroutine，<strong>防止抢占</strong>(可以看一下goroutines一节)</li><li>原子性操作atomic.LoadUintPtr()保证不会同步问题</li><li>返回值是本地poolLocal pool(poolChain和private)的指针，和这个p的id</li></ol><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// pin pins the current goroutine to P, disables preemption and</span><span class="hljs-comment">// returns poolLocal pool for the P and the P's id.</span><span class="hljs-comment">// Caller must call runtime_procUnpin() when done with the pool.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span> <span class="hljs-title">pin</span><span class="hljs-params">()</span> <span class="hljs-params">(*poolLocal, <span class="hljs-keyword">int</span>)</span></span> &#123;pid := runtime_procPin()<span class="hljs-comment">// In pinSlow we store to local and then to localSize, here we load in opposite order.</span><span class="hljs-comment">// Since we've disabled preemption, GC cannot happen in between.</span><span class="hljs-comment">// Thus here we must observe local at least as large localSize.</span><span class="hljs-comment">// We can observe a newer/larger local, it is fine (we must observe its zero-initialized-ness).</span><span class="hljs-comment">//获取localsize，锁住</span>s := atomic.LoadUintptr(&amp;p.localSize) <span class="hljs-comment">// load-acquire</span><span class="hljs-comment">//</span>l := p.local                          <span class="hljs-comment">// load-consume</span><span class="hljs-keyword">if</span> <span class="hljs-keyword">uintptr</span>(pid) &lt; s &#123;<span class="hljs-keyword">return</span> indexLocal(l, pid), pid&#125;<span class="hljs-keyword">return</span> p.pinSlow()&#125;</code></pre></div><p>注意: 可以看一下这个<strong>runtime_procPin()</strong>，是runtime的汇编代码用来锁住调度过程(禁止抢占),这里主要是要获得当前P的id，如果被抢占可能P的id会变化;一定要配合runtime_procUnpin()解锁;</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span> <span class="hljs-title">pinSlow</span><span class="hljs-params">()</span> <span class="hljs-params">(*poolLocal, <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-comment">// Retry under the mutex.</span><span class="hljs-comment">// Can not lock the mutex while pinned.</span>runtime_procUnpin()allPoolsMu.Lock()<span class="hljs-keyword">defer</span> allPoolsMu.Unlock()pid := runtime_procPin()<span class="hljs-comment">// poolCleanup won't be called while we are pinned.</span>s := p.localSizel := p.local<span class="hljs-comment">//uintptr(pid)小于[]localpool的size，则一定在[]localpool里面，直接进去拿</span><span class="hljs-keyword">if</span> <span class="hljs-keyword">uintptr</span>(pid) &lt; s &#123;<span class="hljs-keyword">return</span> indexLocal(l, pid), pid&#125;<span class="hljs-keyword">if</span> p.local == <span class="hljs-literal">nil</span> &#123;allPools = <span class="hljs-built_in">append</span>(allPools, p)&#125;<span class="hljs-comment">// If GOMAXPROCS changes between GCs, we re-allocate the array and lose the old one.</span>size := runtime.GOMAXPROCS(<span class="hljs-number">0</span>)<span class="hljs-comment">//创建新的local</span>local := <span class="hljs-built_in">make</span>([]poolLocal, size)atomic.StorePointer(&amp;p.local, unsafe.Pointer(&amp;local[<span class="hljs-number">0</span>])) <span class="hljs-comment">// store-release</span>atomic.StoreUintptr(&amp;p.localSize, <span class="hljs-keyword">uintptr</span>(size))         <span class="hljs-comment">// store-release</span><span class="hljs-keyword">return</span> &amp;local[pid], pid&#125;</code></pre></div><ul><li>接下来，在p.pinSlow()还会进行一些判断,首先，在解锁了抢占然后再次调用runtime_ProcPin()为的就是获取最新的P的id;</li></ul><p><strong>目的</strong>: 个人理解是尽量减少 <strong>p.local([]poolLocal)</strong> 的创建，因为在解绑runtime_unProcPin()与下一次绑定之间可能P的id会变化，可以先检查切换的新的这个P的id里面是不是已经有 <strong>p.local([]poolLocal)</strong></p><ul><li>如果没有p.local没有对象就会创建新的一个 <strong>[]poollocal</strong> ，旧的poolocal就会进入GC</li></ul><h4 id="get">Get</h4><p>与set有一定的相似</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span> <span class="hljs-title">Get</span><span class="hljs-params">()</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<span class="hljs-keyword">if</span> race.Enabled &#123;race.Disable()    &#125;    <span class="hljs-comment">//与set一样，都要先"锁住"当前goroutine</span>l, pid := p.pin()<span class="hljs-comment">//获得可复用的private对象</span>x := l.privatel.private = <span class="hljs-literal">nil</span><span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">//private无复用的对象，只能从shared []poollocal拿</span><span class="hljs-comment">// Try to pop the head of the local shard. We prefer</span><span class="hljs-comment">// the head over the tail for temporal locality of</span><span class="hljs-comment">// reuse.</span><span class="hljs-comment">//首先会从本地的sharedpopHead</span>x, _ = l.shared.popHead()<span class="hljs-comment">//如果没有，就会进行getSlow()</span><span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> &#123;x = p.getSlow(pid)&#125;&#125;runtime_procUnpin()<span class="hljs-keyword">if</span> race.Enabled &#123;race.Enable()<span class="hljs-keyword">if</span> x != <span class="hljs-literal">nil</span> &#123;race.Acquire(poolRaceAddr(x))&#125;&#125;<span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> &amp;&amp; p.New != <span class="hljs-literal">nil</span> &#123;x = p.New()&#125;<span class="hljs-keyword">return</span> x&#125;</code></pre></div><p>这里就可以回答上面的问题了（<strong>为啥有popTail，又要有popHead呢？？？</strong>)：</p><ul><li>首先会从本地的sharedpopHead</li><li>如果在poollocal中找不到对象，则要调用**getSlow()**获得对象,getslow()代码如下</li><li>下面代码中 <strong>l.shared.popTail()</strong> 就发现是从其他P steal <strong>尾部</strong>获得poolChain</li></ul><p>这里都可以解释为什么有些地方不用锁:</p><blockquote><blockquote><blockquote><p>本地的就从head取对象，steal其他的P的对象就从其他P的tail取对象</p></blockquote></blockquote></blockquote><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span> <span class="hljs-title">getSlow</span><span class="hljs-params">(pid <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<span class="hljs-comment">// See the comment in pin regarding ordering of the loads.</span>size := atomic.LoadUintptr(&amp;p.localSize) <span class="hljs-comment">// load-acquire</span>locals := p.local                        <span class="hljs-comment">// load-consume</span><span class="hljs-comment">// Try to steal one element from other procs.</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">int</span>(size); i++ &#123;l := indexLocal(locals, (pid+i+<span class="hljs-number">1</span>)%<span class="hljs-keyword">int</span>(size))<span class="hljs-comment">//从其他P的tail获得对象</span><span class="hljs-keyword">if</span> x, _ := l.shared.popTail(); x != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> x&#125;&#125;<span class="hljs-comment">// Try the victim cache. We do this after attempting to steal</span><span class="hljs-comment">// from all primary caches because we want objects in the</span><span class="hljs-comment">// victim cache to age out if at all possible.</span>size = atomic.LoadUintptr(&amp;p.victimSize)<span class="hljs-keyword">if</span> <span class="hljs-keyword">uintptr</span>(pid) &gt;= size &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;locals = p.victiml := indexLocal(locals, pid)<span class="hljs-keyword">if</span> x := l.private; x != <span class="hljs-literal">nil</span> &#123;l.private = <span class="hljs-literal">nil</span><span class="hljs-keyword">return</span> x&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">int</span>(size); i++ &#123;l := indexLocal(locals, (pid+i)%<span class="hljs-keyword">int</span>(size))<span class="hljs-keyword">if</span> x, _ := l.shared.popTail(); x != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> x&#125;&#125;<span class="hljs-comment">// Mark the victim cache as empty for future gets don't bother</span><span class="hljs-comment">// with it.</span>atomic.StoreUintptr(&amp;p.victimSize, <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre></div><ul><li>因为本地P无对象，会尝试从其他p中steal对象</li><li><strong>victime cache</strong> (1.13新增！！！)(其实属于计算机架构设计里面的词)代码中拿到其他p的时候，会先从victim cache中获取对象 (locals []poolChain)，然后定位slot，如果该slot的private为空则又从shared里面poptail拿到对象</li><li>最后还要注意，如果找不到对象，会将victim cache设置为空 (设置victimSize=0) ，防止下一次再次从victim里面查找</li></ul><h3 id="victimcache">VictimCache</h3><p>涉及了gc</p><p>在pool包初始化时即注册了poolCleanUp()函数,该函数用于初始化victimcache字段</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;runtime_registerPoolCleanup(poolCleanup)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">poolCleanup</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// This function is called with the world stopped, at the beginning of a garbage collection.</span><span class="hljs-comment">// It must not allocate and probably should not call any runtime functions.</span><span class="hljs-comment">// Because the world is stopped, no pool user can be in a</span><span class="hljs-comment">// pinned section (in effect, this has all Ps pinned).</span><span class="hljs-comment">// Drop victim caches from all pools.</span><span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> oldPools &#123;p.victim = <span class="hljs-literal">nil</span>p.victimSize = <span class="hljs-number">0</span>&#125;<span class="hljs-comment">// Move primary cache to victim cache.</span><span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> allPools &#123;p.victim = p.localp.victimSize = p.localSizep.local = <span class="hljs-literal">nil</span>p.localSize = <span class="hljs-number">0</span>&#125;<span class="hljs-comment">// The pools with non-empty primary caches now have non-empty</span><span class="hljs-comment">// victim caches and no pools have primary caches.</span>oldPools, allPools = allPools, <span class="hljs-literal">nil</span>&#125;</code></pre></div><ul><li>该函数在stw的时候会被调用(在gc开始的时候),其不能分配也不应该调用任何runtime的函数，原因是防止？？？如果gc发生在goorutine与 shared.poolChain 进行 put/get时，会保留整个pool，下一次gc就会浪费多一倍内存</li><li>因为stw，所有pool的user不能在pinned的部分</li><li>首先会将所有当前的pools(oldPools) victim cache置为0</li><li>然后将主要的cache(allPools里面的locals([]poolLocal)字段)移到当前的victim字段</li><li>更新oldPools和allPools</li></ul><p>可以对比一下1.12的poolCleanUp</p><p><strong>1.12的poolCleanup</strong></p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">poolCleanup</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// 该函数会注册到运行时 GC 阶段(前)，此时为 STW 状态，不需要加锁</span><span class="hljs-comment">// 它必须不处理分配且不调用任何运行时函数，防御性的将一切归零，有以下两点原因:</span><span class="hljs-comment">// 1. 防止整个 Pool 的 false retention???</span><span class="hljs-comment">// 2. 如果 GC 发生在当有 goroutine 与 l.shared 进行 Put/Get 时，它会保留整个 Pool.</span><span class="hljs-comment">//   那么下个 GC 周期的内存消耗将会翻倍。</span><span class="hljs-comment">// 遍历所有 Pool 实例，接触相关引用，交由 GC 进行回收</span><span class="hljs-keyword">for</span> i, p := <span class="hljs-keyword">range</span> allPools &#123;allPools[i] = <span class="hljs-literal">nil</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">int</span>(p.localSize); i++ &#123;l := indexLocal(p.local, i)l.private = <span class="hljs-literal">nil</span><span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> l.shared &#123;l.shared[j] = <span class="hljs-literal">nil</span>&#125;l.shared = <span class="hljs-literal">nil</span>&#125;p.local = <span class="hljs-literal">nil</span>p.localSize = <span class="hljs-number">0</span>&#125;allPools = []*Pool&#123;&#125;&#125;</code></pre></div><ul><li>其每次gc stw都遍历allPools并清空local，private,shared，导致的结果就是时间gc消耗的时间变长，以及下一次进行分配的时候时间变长，以及下一次内存的消耗也会增多(虽然总的来讲是不变)</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis basis</title>
    <link href="/2020/03/01/redis/basic/"/>
    <url>/2020/03/01/redis/basic/</url>
    
    <content type="html"><![CDATA[<h1>直接从几道常见的面试题出发</h1><a id="more"></a><p>以下相关代码都是redis5.0版本</p><h2 id="1-支持的数据类型">1. 支持的数据类型</h2><h3 id="基本数据结构">基本数据结构</h3><h4 id="1-string">1. string</h4><p>sds大概的结构如下:</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sds</span>&#123;</span>    <span class="hljs-keyword">int</span> len <span class="hljs-comment">//含有数据的长度</span>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">free</span><span class="hljs-comment">//空的长度</span>    <span class="hljs-keyword">byte</span>[] arr<span class="hljs-comment">//底层数组</span>&#125;</code></pre></div><h4 id="2-dict">2. dict</h4><h4 id="3-list">3. list</h4><h4 id="4-set">4. set</h4><h4 id="5-sortedset">5. sortedSet</h4><h3 id="redisobject">redisObject</h3><h2 id="2-持久化">2. 持久化</h2><h2 id="3-redis常用命令">3. redis常用命令</h2><h2 id="4-redis内存淘汰机制">4. redis内存淘汰机制</h2><p>lru-volatilelru-allkeyslru-randomkeys</p><h2 id="5-redis持久化">5. redis持久化</h2><ul><li><p>RDB</p></li><li><p>AOF</p></li></ul><h2 id="6-redis作为队列？？？">6. redis作为队列？？？</h2><p>优点：</p><ol><li>天生数据结构,接口支持</li><li></li></ol><p>缺点：</p><ol><li>持久化</li></ol><p>注意点：</p><h2 id="7-redis架构模式">7. redis架构模式</h2><ul><li><p>Reactor</p></li><li></li></ul><h2 id="8-缓存相关">8. 缓存相关</h2><ul><li><p>缓存穿透热点数据击穿解决：锁住资源</p></li><li><p>缓存雪崩同一时间大量失效解决：random keys</p></li></ul><h2 id="9-分布式锁">9. 分布式锁</h2><h3 id="基本版本">基本版本</h3><ul><li><p>set key -n -x [time]</p></li><li></li></ul><h2 id="10-单线程支撑高并发原理">10. 单线程支撑高并发原理</h2><h2 id="11-并发竞争问题的解决">11. 并发竞争问题的解决</h2>]]></content>
    
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang Garbage Collection</title>
    <link href="/2020/02/24/Go/gc/"/>
    <url>/2020/02/24/Go/gc/</url>
    
    <content type="html"><![CDATA[<p>看了下runtime的<s>代码</s>（注释），总结一哈</p><a id="more"></a><h2 id="目的">目的</h2><p>对于所有的垃圾回收器的目的（指标）无非就是以下几个：</p><ol><li>所占用程序的时间，停顿时间</li><li>频率</li><li>CPU占比</li><li>内存占比（堆开销）</li><li>内存的分配方式（碎片化程度）</li><li>内存释放方式</li><li>并发效果</li><li>是否智能化（根据某些系统条件进行调节）</li><li>是否可以自定义化参数</li></ol><h2 id="现在有的比较流行的gc">现在有的比较流行的GC</h2><ol><li><p>简单的refcount，比如redis，即 引用多一个，refcount就+1</p></li><li><p>mark &amp; sweep，标记然后用监视内存的程序或者lazy清理（这个一般不会），golang现在用的就是这种</p></li><li><p>比较牛批的分代收集，如JAVA，什么新生代，老年代，eden等；不过这些都是</p></li></ol><h2 id="go的gc">Go的GC</h2><h3 id="步骤">步骤</h3><h4 id="触发">触发</h4><p>触发gc可以由runtime.GC()(不一定,会判定是否执行)</p><p>提供了两个参数来控制GC</p><h4 id="1-gcpercent">1.GCPercent</h4><blockquote><blockquote><p>The first one is GCPercent. Basically this is a knob that adjusts how much CPU you want to use and how much memory you want to use. The default is 100 which means that half the heap is dedicated to live memory and half the heap is dedicated to allocation. You can modify this in either direction.</p></blockquote></blockquote><p>代码在runtime/mgc.go中:</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// Initialized from $GOGC.  GOGC=off means no GC.</span><span class="hljs-keyword">var</span> gcpercent <span class="hljs-keyword">int32</span>......<span class="hljs-comment">//go:linkname setGCPercent runtime/debug.setGCPercent</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setGCPercent</span><span class="hljs-params">(in <span class="hljs-keyword">int32</span>)</span> <span class="hljs-params">(out <span class="hljs-keyword">int32</span>)</span></span> &#123;<span class="hljs-comment">// Run on the system stack since we grab the heap lock.</span>systemstack(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;lock(&amp;mheap_.lock)out = gcpercent<span class="hljs-keyword">if</span> in &lt; <span class="hljs-number">0</span> &#123;in = <span class="hljs-number">-1</span>&#125;gcpercent = inheapminimum = defaultHeapMinimum * <span class="hljs-keyword">uint64</span>(gcpercent) / <span class="hljs-number">100</span><span class="hljs-comment">// Update pacing in response to gcpercent change.</span>gcSetTriggerRatio(memstats.triggerRatio)unlock(&amp;mheap_.lock)&#125;)<span class="hljs-comment">// Pacing changed, so the scavenger should be awoken.</span>wakeScavenger()<span class="hljs-comment">// If we just disabled GC, wait for any concurrent GC mark to</span><span class="hljs-comment">// finish so we always return with no GC running.</span><span class="hljs-keyword">if</span> in &lt; <span class="hljs-number">0</span> &#123;gcWaitOnMark(atomic.Load(&amp;work.cycles))&#125;<span class="hljs-keyword">return</span> out&#125;</code></pre></div><ul><li>默认值是100，意味着一半的堆会用于实时内存，另一半的堆会用来分配</li><li></li></ul><h4 id="2-maxheap">2.Maxheap</h4><blockquote><blockquote><p>MaxHeap, which is not yet released but is being used and evaluated internally, lets the programmer set what the maximum heap size should be. Out of memory, OOMs, are tough on Go; temporary spikes in memory usage should be handled by increasing CPU costs, not by aborting. Basically if the GC sees memory pressure it informs the application that it should shed load. Once things are back to normal the GC informs the application that it can go back to its regular load. MaxHeap also provides a lot more flexibility in scheduling. Instead of always being paranoid about how much memory is available the runtime can size the heap up to the MaxHeap.</p></blockquote></blockquote><ul><li>还在实验中… 最主要提供一些监控，会提示程序内存不足；还会使调度更加灵活；</li></ul><h4 id="方法">方法</h4><p>golang现在使用的是叫 <strong>三色回收</strong>的东西：比较旧的版本:大概步骤：</p><ol><li>所有对象初始都设为 <strong>白色</strong></li><li>从RootSet出发（即堆里面的对象，比如全局变量，所有的栈对象等），标记第一次所有可达到的对象为<strong>灰色</strong> ,这个过程,这里会stop the world;</li><li>然后紧接着在第一个发现的各个对象上继续寻找引用这些对象的对象们，找到后（或者在这些基础上已经找不到了）就把第一次所有可达的对象转为<strong>黑色</strong>,这时会start the world;而这些找到的对象们就标为<strong>灰色</strong> ;</li><li>重复第二,三步,直到所有</li></ol><div class="hljs"><pre><code class="hljs golang"></code></pre></div><h3 id="做过的一些优化">做过的一些优化</h3><h4 id="size-segregated-span-分片隔离">size segregated span （分片隔离）</h4><ol><li>garbage collector要快速地找到object的开始位置，如果能知道在某个span中的object的大小，就可以直接往下舍入查找到位置</li><li>更小的碎片化</li><li>内部结构化？</li><li></li></ol><h3 id="调查一下其他部分">调查一下其他部分</h3><p>有这个一个变量： <strong>gcphase</strong></p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// Garbage collector phase.</span><span class="hljs-comment">// Indicates to write barrier and synchronization task to perform.</span><span class="hljs-keyword">var</span> gcphase <span class="hljs-keyword">uint32</span></code></pre></div><p>write barrier写屏障</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// The compiler knows about this variable.</span><span class="hljs-comment">// If you change it, you must change builtin/runtime.go, too.</span><span class="hljs-comment">// If you change the first four bytes, you must also change the write</span><span class="hljs-comment">// barrier insertion code.</span><span class="hljs-keyword">var</span> writeBarrier <span class="hljs-keyword">struct</span> &#123;enabled <span class="hljs-keyword">bool</span>    <span class="hljs-comment">// compiler emits a check of this before calling write barrier</span>pad     [<span class="hljs-number">3</span>]<span class="hljs-keyword">byte</span> <span class="hljs-comment">// compiler uses 32-bit load for "enabled" field</span>needed  <span class="hljs-keyword">bool</span>    <span class="hljs-comment">// whether we need a write barrier for current GC phase</span>cgo     <span class="hljs-keyword">bool</span>    <span class="hljs-comment">// whether we need a write barrier for a cgo check</span>alignme <span class="hljs-keyword">uint64</span>  <span class="hljs-comment">// guarantee alignment so that compiler can use a 32 or 64-bit load</span>&#125;</code></pre></div><h3 id="具体实现">具体实现</h3><ol><li>bitmap/runtime/mbitmap.go使用bitmap</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang Memory Allocator</title>
    <link href="/2020/02/24/Go/memManage/"/>
    <url>/2020/02/24/Go/memManage/</url>
    
    <content type="html"><![CDATA[<h1>golang内存管理</h1><a id="more"></a><p>go的内存管理是基于tcmalloc，<a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html" target="_blank" rel="noopener">这个连接</a>看详情</p><p>任何大小的内存页可以被分割成<strong>一系列同样大小的object</strong>,这些规定的大小size则被定义在<a href="#sizetoclass">sizetoclass</a>,然后被一个<strong>bitmap</strong>管理</p><h2 id="基本数据结构">基本数据结构</h2><p>类似于<a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html" target="_blank" rel="noopener">TCMalloc</a></p><p>大概概括:其目的是 减少多线程对内存请求时候的锁竞争，在对小内存的申请时甚至可以无锁操作，获取大内存时用spinlocks；但是其在TLS会预分配一部分空间，所以启动时相比dlmalloc等其他内存分配器空间较大，但是最终会接近;</p><p><strong>class_to_allocnpages</strong>总共有67个范围</p><p>栈的分配也是多层次和多class的</p><ul><li><p>mspan (主要使用该机制减少碎片):</p><p>被内存堆管理的的页面，至少一个页(8KB)，用于范围分配内存，比如16-32B则分配32B,112~128则分配128B的span</p></li><li><p>mcentral</p><p>全局有 67 × 2 (?) 个对应不同size的span <strong>后备</strong>mcentral收集所有特定size的span，如果也被用完，则再次转向mheap申请</p></li></ul><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> mheap <span class="hljs-keyword">struct</span>&#123;...<span class="hljs-comment">// central free lists for small size classes.</span><span class="hljs-comment">// the padding makes sure that the mcentrals are</span><span class="hljs-comment">// spaced CacheLinePadSize bytes apart, so that each mcentral.lock</span><span class="hljs-comment">// gets its own cache line.</span><span class="hljs-comment">// central is indexed by spanClass.</span><span class="hljs-comment">//numSpanClasses = _NumSizeClasses &lt;&lt; 1 = 134</span>central [numSpanClasses]<span class="hljs-keyword">struct</span> &#123;mcentral <span class="hljs-keyword">type</span> mcentral <span class="hljs-keyword">struct</span> &#123;lock      mutexspanclass spanClassnonempty  mSpanList <span class="hljs-comment">// list of spans with a free object, ie a nonempty free list</span>empty     mSpanList <span class="hljs-comment">// list of spans with no free objects (or cached in an mcache)</span><span class="hljs-comment">// nmalloc is the cumulative count of objects allocated from</span><span class="hljs-comment">// this mcentral, assuming all spans in mcaches are</span><span class="hljs-comment">// fully-allocated. Written atomically, read under STW.</span>nmalloc <span class="hljs-keyword">uint64</span>&#125;pad      [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral&#123;&#125;)%cpu.CacheLinePadSize]<span class="hljs-keyword">byte</span>&#125;....&#125;</code></pre></div><p>代码中的pad是用作分割多个mcentral，以CacheLinePadSize个Bytes分割开，所以每一个mcentral的lock可以得到自己的cache line我认为可以看做是内存对齐的一种方法(???是不是捏)</p><ul><li><p>mcache</p><p>多层次的cache用来减少分配冲突，mcache是per-P的，所以无锁，mspan的每个P(process)下的可用cache空间；小于16B直接使用P中的macache</p></li></ul><div class="hljs"><pre><code class="hljs golang"><span class="hljs-comment">// Per-thread (in Go, per-P) cache for small objects.</span><span class="hljs-comment">// No locking needed because it is per-thread (per-P).</span><span class="hljs-comment">//</span><span class="hljs-comment">// mcaches are allocated from non-GC'd memory, so any heap pointers</span><span class="hljs-comment">// must be specially handled.</span><span class="hljs-comment">//</span><span class="hljs-comment">//因为只用作local P，所以自然无锁</span><span class="hljs-comment">//go:notinheap</span><span class="hljs-comment">//这个标志说明了不在heap中，也可以理解，per - P好明显不在公共heap中</span><span class="hljs-keyword">type</span> mcache <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">// The following members are accessed on every malloc,</span><span class="hljs-comment">// so they are grouped here for better caching.</span>next_sample <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// trigger heap sample after allocating this many bytes</span>local_scan  <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// bytes of scannable heap allocated</span><span class="hljs-comment">// Allocator cache for tiny objects w/o pointers.</span><span class="hljs-comment">// See "Tiny allocator" comment in malloc.go.</span><span class="hljs-comment">//具体可以见下面的tiny allocator分配器</span><span class="hljs-comment">// tiny points to the beginning of the current tiny block, or</span><span class="hljs-comment">// nil if there is no current tiny block.</span><span class="hljs-comment">//</span><span class="hljs-comment">// tiny is a heap pointer. Since mcache is in non-GC'd memory,</span><span class="hljs-comment">// we handle it by clearing it in releaseAll during mark</span><span class="hljs-comment">// termination.</span>tiny             <span class="hljs-keyword">uintptr</span>tinyoffset       <span class="hljs-keyword">uintptr</span>local_tinyallocs <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// number of tiny allocs not counted in other stats</span><span class="hljs-comment">// The rest is not accessed on every malloc.</span>alloc [numSpanClasses]*mspan <span class="hljs-comment">// spans to allocate from, indexed by spanClass</span>stackcache [_NumStackOrders]stackfreelist<span class="hljs-comment">// Local allocator stats, flushed during GC.</span>local_largefree  <span class="hljs-keyword">uintptr</span>                  <span class="hljs-comment">// bytes freed for large objects (&gt;maxsmallsize)</span>local_nlargefree <span class="hljs-keyword">uintptr</span>                  <span class="hljs-comment">// number of frees for large objects (&gt;maxsmallsize)</span>local_nsmallfree [_NumSizeClasses]<span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// number of frees for small objects (&lt;=maxsmallsize)</span><span class="hljs-comment">// flushGen indicates the sweepgen during which this mcache</span><span class="hljs-comment">// was last flushed. If flushGen != mheap_.sweepgen, the spans</span><span class="hljs-comment">// in this mcache are stale and need to the flushed so they</span><span class="hljs-comment">// can be swept. This is done in acquirep.</span>flushGen <span class="hljs-keyword">uint32</span>&#125;</code></pre></div><ul><li>fixalloc</li></ul><p>一个不定长度的列表，用来管理<strong>不在堆上</strong>的固定的对象，这些对象都是runtime上大小固定的结构，比如mspan，mcache</p><ul><li><p>mheap:</p><p>全局只有一个内存堆，以页为粒度(8KB)进行管理,结构体为treap，维护空闲连续page，归还内存到heap中时，连续地址会合并；大于32KB内存申请直接从mheap中拿，剩下的则先使用当前P的mcache中对应的size class分配，如果其对应的span已经无可用的块，则向mcentral请求，如果没有则在mheap申请，如果还不够则要向操作系统申请;</p></li><li><p>mstatisitc</p><p>提供管理信息</p></li></ul><h3 id="mspan的结构体">mspan的结构体</h3><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> mspan <span class="hljs-keyword">struct</span> &#123;next *mspan     <span class="hljs-comment">// next span in list, or nil if none</span>prev *mspan     <span class="hljs-comment">// previous span in list, or nil if none</span>list *mSpanList <span class="hljs-comment">// For debugging. <span class="hljs-doctag">TODO:</span> Remove.</span>startAddr <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// address of first byte of span aka s.base()</span>npages    <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// number of pages in span</span>manualFreeList gclinkptr <span class="hljs-comment">// list of free objects in mSpanManual spans</span><span class="hljs-comment">// freeindex is the slot index between 0 and nelems at which to begin scanning</span><span class="hljs-comment">// for the next free object in this span.</span><span class="hljs-comment">// Each allocation scans allocBits starting at freeindex until it encounters a 0</span><span class="hljs-comment">// indicating a free object. freeindex is then adjusted so that subsequent scans begin</span><span class="hljs-comment">// just past the newly discovered free object.</span><span class="hljs-comment">//</span><span class="hljs-comment">// If freeindex == nelem, this span has no free objects.</span><span class="hljs-comment">//</span><span class="hljs-comment">// allocBits is a bitmap of objects in this span.</span><span class="hljs-comment">// If n &gt;= freeindex and allocBits[n/8] &amp; (1&lt;&lt;(n%8)) is 0</span><span class="hljs-comment">// then object n is free;</span><span class="hljs-comment">// otherwise, object n is allocated. Bits starting at nelem are</span><span class="hljs-comment">// undefined and should never be referenced.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Object n starts at address n*elemsize + (start &lt;&lt; pageShift).</span>freeindex <span class="hljs-keyword">uintptr</span><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Look up nelems from sizeclass and remove this field if it</span><span class="hljs-comment">// helps performance.</span>nelems <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// number of object in the span.</span><span class="hljs-comment">// Cache of the allocBits at freeindex. allocCache is shifted</span><span class="hljs-comment">// such that the lowest bit corresponds to the bit freeindex.</span><span class="hljs-comment">// allocCache holds the complement of allocBits, thus allowing</span><span class="hljs-comment">// ctz (count trailing zero) to use it directly.</span><span class="hljs-comment">// allocCache may contain bits beyond s.nelems; the caller must ignore</span><span class="hljs-comment">// these.</span>allocCache <span class="hljs-keyword">uint64</span><span class="hljs-comment">// allocBits and gcmarkBits hold pointers to a span's mark and</span><span class="hljs-comment">// allocation bits. The pointers are 8 byte aligned.</span><span class="hljs-comment">// There are three arenas where this data is held.</span><span class="hljs-comment">// free: Dirty arenas that are no longer accessed</span><span class="hljs-comment">//       and can be reused.</span><span class="hljs-comment">// next: Holds information to be used in the next GC cycle.</span><span class="hljs-comment">// current: Information being used during this GC cycle.</span><span class="hljs-comment">// previous: Information being used during the last GC cycle.</span><span class="hljs-comment">// A new GC cycle starts with the call to finishsweep_m.</span><span class="hljs-comment">// finishsweep_m moves the previous arena to the free arena,</span><span class="hljs-comment">// the current arena to the previous arena, and</span><span class="hljs-comment">// the next arena to the current arena.</span><span class="hljs-comment">// The next arena is populated as the spans request</span><span class="hljs-comment">// memory to hold gcmarkBits for the next GC cycle as well</span><span class="hljs-comment">// as allocBits for newly allocated spans.</span><span class="hljs-comment">//</span><span class="hljs-comment">// The pointer arithmetic is done "by hand" instead of using</span><span class="hljs-comment">// arrays to avoid bounds checks along critical performance</span><span class="hljs-comment">// paths.</span><span class="hljs-comment">// The sweep will free the old allocBits and set allocBits to the</span><span class="hljs-comment">// gcmarkBits. The gcmarkBits are replaced with a fresh zeroed</span><span class="hljs-comment">// out memory.</span>allocBits  *gcBitsgcmarkBits *gcBits<span class="hljs-comment">// sweep generation:</span><span class="hljs-comment">// if sweepgen == h-&gt;sweepgen - 2, the span needs sweeping</span><span class="hljs-comment">// if sweepgen == h-&gt;sweepgen - 1, the span is currently being swept</span><span class="hljs-comment">// if sweepgen == h-&gt;sweepgen, the span is swept and ready to use</span><span class="hljs-comment">// if sweepgen == h-&gt;sweepgen + 1, the span was cached before sweep began and is still cached, and needs sweeping</span><span class="hljs-comment">// if sweepgen == h-&gt;sweepgen + 3, the span was swept and then cached and is still cached</span><span class="hljs-comment">// h-&gt;sweepgen is incremented by 2 after every GC</span>sweepgen    <span class="hljs-keyword">uint32</span>divMul      <span class="hljs-keyword">uint16</span>     <span class="hljs-comment">// for divide by elemsize - divMagic.mul</span>baseMask    <span class="hljs-keyword">uint16</span>     <span class="hljs-comment">// if non-0, elemsize is a power of 2, &amp; this will get object allocation base</span>allocCount  <span class="hljs-keyword">uint16</span>     <span class="hljs-comment">// number of allocated objects</span>spanclass   spanClass  <span class="hljs-comment">// size class and noscan (uint8)</span>state       mSpanState <span class="hljs-comment">// mspaninuse etc</span>needzero    <span class="hljs-keyword">uint8</span>      <span class="hljs-comment">// needs to be zeroed before allocation</span>divShift    <span class="hljs-keyword">uint8</span>      <span class="hljs-comment">// for divide by elemsize - divMagic.shift</span>divShift2   <span class="hljs-keyword">uint8</span>      <span class="hljs-comment">// for divide by elemsize - divMagic.shift2</span>scavenged   <span class="hljs-keyword">bool</span>       <span class="hljs-comment">// whether this span has had its pages released to the OS</span>elemsize    <span class="hljs-keyword">uintptr</span>    <span class="hljs-comment">// computed from sizeclass or from npages</span>limit       <span class="hljs-keyword">uintptr</span>    <span class="hljs-comment">// end of data in span</span>speciallock mutex      <span class="hljs-comment">// guards specials list</span>specials    *special   <span class="hljs-comment">// linked list of special records sorted by offset.</span>&#125;</code></pre></div><p>主要的字段:</p><ul><li><p>elementsize: slot大小，B为单位</p></li><li><p>freeindex，&lt;该值的已经被分配，&gt;=该位置的可能未被分配，需要配合allocCache查找,每次分配后，freeindex设置为分配的slot+1</p></li><li><p>allocBits表示上一次GC之后哪一些slot被使用，0未使用或释放，1已分配</p></li><li><p>allocCache表示从freeindex开始的64个slot的分配情况，1为未分配，0为已分配，使用ctz(Count trailing zeros指令)找到第一个非0位，使用完了就从allocBits加载，取反；</p></li><li><p>每次gc完的sweep阶段，将allocBits设置为gcmarkbits</p></li></ul><h2 id="内存总体结构">内存总体结构</h2><p>暂时将linux amd64作为例子</p><ul><li><p>1.10以前，内存不是初始化就分配虚拟内存arena大小为512G，为了方便将其分为一个个page，所以总共也有512G/8KB = 65536个page</p><p>span区域存放指向span的指针，表示arena区域page所属的span，所以其大小即为 512GB/8KB* 8B(指针大小) = 512M</p><p>bitmap主要用于GC，两个bit表示arena中一个字的可用状态，所以表示为 (512GB/ 8(8个byte一个字，即指令长度)) * 2 /8 (8个bit一个byte) = 16G 长度</p></li><li><p>1.11以后改成两阶段稀疏索引方式，内存允许超过512G，也可以允许不连续内存mheap中的arenas字段实际是一个指针数组，每个heapArena管理一个64MB的内存bitmap和spans功能不变</p></li></ul><h2 id="go的分配内存策略：">go的分配内存策略：</h2><h3 id="小对象-小于32k-和大对象的不同">小对象（小于32K）和大对象的不同</h3><ol><li>小于32KB的小对象时，会直接去 P (process)的cache的list里面拿，大于32KB的才去堆拿;拿的过程会roundup一下大小，然后在当前P的mcachexmspan</li></ol><div class="hljs"><pre><code class="hljs golang"><span class="hljs-comment">// Allocate an object of size bytes.</span><span class="hljs-comment">// Small objects are allocated from the per-P cache's free lists.</span><span class="hljs-comment">// Large objects (&gt; 32 kB) are allocated straight from the heap.</span><span class="hljs-comment">//typ有两种，一种noscan，一种是scan，表示分配对象是否包含指针</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mallocgc</span><span class="hljs-params">(size <span class="hljs-keyword">uintptr</span>, typ *_type, needzero <span class="hljs-keyword">bool</span>)</span> <span class="hljs-title">unsafe</span>.<span class="hljs-title">Pointer</span></span> &#123;<span class="hljs-keyword">if</span> gcphase == _GCmarktermination &#123;throw(<span class="hljs-string">"mallocgc called with gcphase == _GCmarktermination"</span>)&#125;<span class="hljs-keyword">if</span> size == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> unsafe.Pointer(&amp;zerobase)&#125;......<span class="hljs-comment">// assistG is the G to charge for this allocation, or nil if</span><span class="hljs-comment">// GC is not currently active.</span><span class="hljs-keyword">var</span> assistG *g<span class="hljs-keyword">if</span> gcBlackenEnabled != <span class="hljs-number">0</span> &#123;<span class="hljs-comment">// Charge the current user G for this allocation.</span>assistG = getg()<span class="hljs-keyword">if</span> assistG.m.curg != <span class="hljs-literal">nil</span> &#123;assistG = assistG.m.curg&#125;<span class="hljs-comment">// Charge the allocation against the G. We'll account</span><span class="hljs-comment">// for internal fragmentation at the end of mallocgc.</span>assistG.gcAssistBytes -= <span class="hljs-keyword">int64</span>(size)<span class="hljs-keyword">if</span> assistG.gcAssistBytes &lt; <span class="hljs-number">0</span> &#123;<span class="hljs-comment">// This G is in debt. Assist the GC to correct</span><span class="hljs-comment">// this before allocating. This must happen</span><span class="hljs-comment">// before disabling preemption.</span>gcAssistAlloc(assistG)&#125;&#125;<span class="hljs-comment">// Set mp.mallocing to keep from being preempted by GC.</span>mp := acquirem()<span class="hljs-keyword">if</span> mp.mallocing != <span class="hljs-number">0</span> &#123;throw(<span class="hljs-string">"malloc deadlock"</span>)&#125;<span class="hljs-keyword">if</span> mp.gsignal == getg() &#123;throw(<span class="hljs-string">"malloc during signal"</span>)&#125;mp.mallocing = <span class="hljs-number">1</span>shouldhelpgc := <span class="hljs-literal">false</span>dataSize := sizec := gomcache()<span class="hljs-keyword">var</span> x unsafe.Pointernoscan := typ == <span class="hljs-literal">nil</span> || typ.ptrdata == <span class="hljs-number">0</span><span class="hljs-keyword">if</span> size &lt;= maxSmallSize &#123;...<span class="hljs-comment">//tiny allocator分配方式的代码</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">var</span> s *mspanshouldhelpgc = <span class="hljs-literal">true</span>systemstack(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;s = largeAlloc(size, needzero, noscan)&#125;)s.freeindex = <span class="hljs-number">1</span>s.allocCount = <span class="hljs-number">1</span>x = unsafe.Pointer(s.base())size = s.elemsize&#125;<span class="hljs-keyword">var</span> scanSize <span class="hljs-keyword">uintptr</span><span class="hljs-keyword">if</span> !noscan &#123;<span class="hljs-comment">// If allocating a defer+arg block, now that we've picked a malloc size</span><span class="hljs-comment">// large enough to hold everything, cut the "asked for" size down to</span><span class="hljs-comment">// just the defer header, so that the GC bitmap will record the arg block</span><span class="hljs-comment">// as containing nothing at all (as if it were unused space at the end of</span><span class="hljs-comment">// a malloc block caused by size rounding).</span><span class="hljs-comment">// The defer arg areas are scanned as part of scanstack.</span><span class="hljs-keyword">if</span> typ == deferType &#123;dataSize = unsafe.Sizeof(_defer&#123;&#125;)&#125;heapBitsSetType(<span class="hljs-keyword">uintptr</span>(x), size, dataSize, typ)<span class="hljs-keyword">if</span> dataSize &gt; typ.size &#123;<span class="hljs-comment">// Array allocation. If there are any</span><span class="hljs-comment">// pointers, GC has to scan to the last</span><span class="hljs-comment">// element.</span><span class="hljs-keyword">if</span> typ.ptrdata != <span class="hljs-number">0</span> &#123;scanSize = dataSize - typ.size + typ.ptrdata&#125;&#125; <span class="hljs-keyword">else</span> &#123;scanSize = typ.ptrdata&#125;c.local_scan += scanSize&#125;<span class="hljs-comment">// Ensure that the stores above that initialize x to</span><span class="hljs-comment">// type-safe memory and set the heap bits occur before</span><span class="hljs-comment">// the caller can make x observable to the garbage</span><span class="hljs-comment">// collector. Otherwise, on weakly ordered machines,</span><span class="hljs-comment">// the garbage collector could follow a pointer to x,</span><span class="hljs-comment">// but see uninitialized memory or stale heap bits.</span>publicationBarrier()<span class="hljs-comment">// Allocate black during GC.</span><span class="hljs-comment">// All slots hold nil so no scanning is needed.</span><span class="hljs-comment">// This may be racing with GC so do it atomically if there can be</span><span class="hljs-comment">// a race marking the bit.</span><span class="hljs-keyword">if</span> gcphase != _GCoff &#123;gcmarknewobject(<span class="hljs-keyword">uintptr</span>(x), size, scanSize)&#125;<span class="hljs-keyword">if</span> raceenabled &#123;racemalloc(x, size)&#125;<span class="hljs-keyword">if</span> msanenabled &#123;msanmalloc(x, size)&#125;mp.mallocing = <span class="hljs-number">0</span>releasem(mp)<span class="hljs-keyword">if</span> debug.allocfreetrace != <span class="hljs-number">0</span> &#123;tracealloc(x, size, typ)&#125;<span class="hljs-keyword">if</span> rate := MemProfileRate; rate &gt; <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">if</span> rate != <span class="hljs-number">1</span> &amp;&amp; size &lt; c.next_sample &#123;c.next_sample -= size&#125; <span class="hljs-keyword">else</span> &#123;mp := acquirem()profilealloc(mp, x, size)releasem(mp)&#125;&#125;<span class="hljs-keyword">if</span> assistG != <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">// Account for internal fragmentation in the assist</span><span class="hljs-comment">// debt now that we know it.</span>assistG.gcAssistBytes -= <span class="hljs-keyword">int64</span>(size - dataSize)&#125;<span class="hljs-keyword">if</span> shouldhelpgc &#123;<span class="hljs-keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerHeap&#125;); t.test() &#123;gcStart(t)&#125;&#125;<span class="hljs-keyword">return</span> x&#125;</code></pre></div><h3 id="各种分配器">各种分配器</h3><h4 id="tinyallocator">TinyAllocator</h4><p>上面的源代码中，当size&lt;=maxSmallSize时，实际上调用了一种tinyAllocator的分配器</p><p>该分配是 <strong>会结合多个申请内存请求 成为 申请一个内存块的请求(即合并小对象存储下来)</strong>；所以当所有的子对象都不可达时，这个内存块才会被释放（同时这些对象一定不含指针，这个很好理解，有指针又要从指针处进行可达性查询）作用是<strong>避免可能内存浪费</strong></p><p>其中这个maxTinySize是可调整的，调整成8bytes就一定不会浪费任何内存（一个页就8B），但是这样就没什么意义（不用combine）照这个道理，16bytes就可能会造成2× 最坏情况的内存浪费，32B就会造成4×最坏情况的内存浪费</p><ul><li><p>其中从tinyallocator分配的对象不能被显式释放(?)，所以每次我们显式释放对象的时候，自然的要保证这个对象是大于maxTinySize</p></li><li><p>主要的对象是一些小字符串和一些独立的变量，json的benchmark使用了这个分配器，减少了20%的堆size</p></li></ul><p>其结构<img src="/img/tinyObjects.png" srcset="/img/loading.gif" alt="如图"></p><ul><li>每个P在本地维护了专门的memory block来存储tinyObject，分配时根据tinyoffset和需要的size及对齐来判断该block是否容纳该object，如果可以就返回地址</li></ul><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mallocgc</span><span class="hljs-params">(size <span class="hljs-keyword">uintptr</span>, typ *_type, needzero <span class="hljs-keyword">bool</span>)</span> <span class="hljs-title">unsafe</span>.<span class="hljs-title">Pointer</span></span> &#123;....<span class="hljs-comment">//maxSmallsize = 32786</span><span class="hljs-keyword">if</span> size&lt;=maxSmallSize &#123;<span class="hljs-comment">//申请对象不含指针且小于16B则会调用tiny allocator</span><span class="hljs-keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123;<span class="hljs-comment">// Tiny allocator.</span><span class="hljs-comment">//</span><span class="hljs-comment">//一种分配器</span><span class="hljs-comment">// Tiny allocator combines several tiny allocation requests</span><span class="hljs-comment">// into a single memory block. The resulting memory block</span><span class="hljs-comment">// is freed when all subobjects are unreachable. The subobjects</span><span class="hljs-comment">// must be noscan (don't have pointers), this ensures that</span><span class="hljs-comment">// the amount of potentially wasted memory is bounded.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Size of the memory block used for combining (maxTinySize) is tunable.</span><span class="hljs-comment">// Current setting is 16 bytes, which relates to 2x worst case memory</span><span class="hljs-comment">// wastage (when all but one subobjects are unreachable).</span><span class="hljs-comment">// 8 bytes would result in no wastage at all, but provides less</span><span class="hljs-comment">// opportunities for combining.</span><span class="hljs-comment">// 32 bytes provides more opportunities for combining,</span><span class="hljs-comment">// but can lead to 4x worst case wastage.</span><span class="hljs-comment">// The best case winning is 8x regardless of block size.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Objects obtained from tiny allocator must not be freed explicitly.</span><span class="hljs-comment">// So when an object will be freed explicitly, we ensure that</span><span class="hljs-comment">// its size &gt;= maxTinySize.</span><span class="hljs-comment">//</span><span class="hljs-comment">// SetFinalizer has a special case for objects potentially coming</span><span class="hljs-comment">// from tiny allocator, it such case it allows to set finalizers</span><span class="hljs-comment">// for an inner byte of a memory block.</span><span class="hljs-comment">//</span><span class="hljs-comment">// The main targets of tiny allocator are small strings and</span><span class="hljs-comment">// standalone escaping variables. On a json benchmark</span><span class="hljs-comment">// the allocator reduces number of allocations by ~12% and</span><span class="hljs-comment">// reduces heap size by ~20%.</span>off := c.tinyoffset<span class="hljs-comment">// Align tiny pointer for required (conservative) alignment.</span><span class="hljs-keyword">if</span> size&amp;<span class="hljs-number">7</span> == <span class="hljs-number">0</span> &#123;off = round(off, <span class="hljs-number">8</span>)&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> size&amp;<span class="hljs-number">3</span> == <span class="hljs-number">0</span> &#123;off = round(off, <span class="hljs-number">4</span>)&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> size&amp;<span class="hljs-number">1</span> == <span class="hljs-number">0</span> &#123;off = round(off, <span class="hljs-number">2</span>)&#125;<span class="hljs-keyword">if</span> off+size &lt;= maxTinySize &amp;&amp; c.tiny != <span class="hljs-number">0</span> &#123;<span class="hljs-comment">// The object fits into existing tiny block.</span><span class="hljs-comment">//该对象适合于已有的tinyblock</span>x = unsafe.Pointer(c.tiny + off)c.tinyoffset = off + sizec.local_tinyallocs++mp.mallocing = <span class="hljs-number">0</span>releasem(mp)<span class="hljs-keyword">return</span> x&#125;<span class="hljs-comment">// Allocate a new maxTinySize block.</span>span := c.alloc[tinySpanClass]v := nextFreeFast(span)<span class="hljs-keyword">if</span> v == <span class="hljs-number">0</span> &#123;v, _, shouldhelpgc = c.nextFree(tinySpanClass)&#125;x = unsafe.Pointer(v)(*[<span class="hljs-number">2</span>]<span class="hljs-keyword">uint64</span>)(x)[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>(*[<span class="hljs-number">2</span>]<span class="hljs-keyword">uint64</span>)(x)[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><span class="hljs-comment">// See if we need to replace the existing tiny block with the new one</span><span class="hljs-comment">// based on amount of remaining free space.</span><span class="hljs-keyword">if</span> size &lt; c.tinyoffset || c.tiny == <span class="hljs-number">0</span> &#123;c.tiny = <span class="hljs-keyword">uintptr</span>(x)c.tinyoffset = size&#125;size = maxTinySize&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//在32KB以内，16B以上的</span><span class="hljs-keyword">var</span> sizeclass <span class="hljs-keyword">uint8</span><span class="hljs-comment">//smallSizeMax = 1024</span><span class="hljs-keyword">if</span> size &lt;= smallSizeMax<span class="hljs-number">-8</span> &#123;sizeclass = size_to_class8[(size+smallSizeDiv<span class="hljs-number">-1</span>)/smallSizeDiv]&#125; <span class="hljs-keyword">else</span> &#123;sizeclass = size_to_class128[(size-smallSizeMax+largeSizeDiv<span class="hljs-number">-1</span>)/largeSizeDiv]&#125;size = <span class="hljs-keyword">uintptr</span>(class_to_size[sizeclass])spc := makeSpanClass(sizeclass, noscan)span := c.alloc[spc]v := nextFreeFast(span)<span class="hljs-keyword">if</span> v == <span class="hljs-number">0</span> &#123;v, span, shouldhelpgc = c.nextFree(spc)&#125;x = unsafe.Pointer(v)<span class="hljs-keyword">if</span> needzero &amp;&amp; span.needzero != <span class="hljs-number">0</span> &#123;memclrNoHeapPointers(unsafe.Pointer(v), size)&#125;&#125;&#125;<span class="hljs-keyword">else</span>&#123;....&#125;....&#125;</code></pre></div><h4 id="fixalloc">fixAlloc</h4><p>因为我们的都知道go分配对象是在go gc heap中，并且由mspan，mcache，mcentral这些结构管理，但是这些结构的对象又是在哪里管理和分配呢？</p><p>fixalloc就是做这个的：前面讲到fixalloc都是mheap中固定的结构</p><ul><li>主要目的就是一次性分配一大块内存(注意persistentalloc方法，使用是mmap，不指定地址，分配内存不再arena范围内，从进程空间获得可能百来KB)，每次请求对应的结构体大小，释放时就放在list链表中</li></ul><p>大概的分配有以下集中</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> mheap <span class="hljs-keyword">struct</span>&#123;...spanalloc             fixalloc <span class="hljs-comment">// allocator for span*</span>cachealloc            fixalloc <span class="hljs-comment">// allocator for mcache*</span>treapalloc            fixalloc <span class="hljs-comment">// allocator for treapNodes*</span>specialfinalizeralloc fixalloc <span class="hljs-comment">// allocator for specialfinalizer*</span>specialprofilealloc   fixalloc <span class="hljs-comment">// allocator for specialprofile*</span>speciallock           mutex    <span class="hljs-comment">// lock for special record allocators.</span>arenaHintAlloc        fixalloc <span class="hljs-comment">// allocator for arenaHints</span>...&#125;</code></pre></div><h4 id="stackcache">stackCache</h4><p>在mcache结构上</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// Number of orders that get caching. Order 0 is FixedStack</span><span class="hljs-comment">// and each successive order is twice as large.</span><span class="hljs-comment">// We want to cache 2KB, 4KB, 8KB, and 16KB stacks. Larger stacks</span><span class="hljs-comment">// will be allocated directly.</span><span class="hljs-comment">// Since FixedStack is different on different systems, we</span><span class="hljs-comment">// must vary NumStackOrders to keep the same maximum cached size.</span><span class="hljs-comment">//   OS               | FixedStack | NumStackOrders</span><span class="hljs-comment">//   -----------------+------------+---------------</span><span class="hljs-comment">//   linux/darwin/bsd | 2KB        | 4</span><span class="hljs-comment">//   windows/32       | 4KB        | 3</span><span class="hljs-comment">//   windows/64       | 8KB        | 2</span><span class="hljs-comment">//   plan9            | 4KB        | 3</span>_NumStackOrders = <span class="hljs-number">4</span> - sys.PtrSize/<span class="hljs-number">4</span>*sys.GoosWindows - <span class="hljs-number">1</span>*sys.GoosPlan9<span class="hljs-keyword">type</span> mcache <span class="hljs-keyword">struct</span>&#123;...stackcache [_NumStackOrders]stackfreelist ...&#125;<span class="hljs-keyword">type</span> stackfreelist <span class="hljs-keyword">struct</span> &#123;list gclinkptr <span class="hljs-comment">// linked list of free stacks</span>size <span class="hljs-keyword">uintptr</span>   <span class="hljs-comment">// total size of stacks in list</span>&#125;</code></pre></div><p>大概结构<img src="/img/stackCache.png" srcset="/img/loading.gif" alt="如图"></p><p>stackCache是per-P的，在另外一篇文章<a href="../goroutine.html">goroutine</a>上讲过，主要用于分配goroutine的stack，同普通内存一样其分为多个segment，class, linux就分为2KB,4KB,8KB,16KB等级</p><p>其中 &gt; 16K的直接从全局stacklarge分配否则按照先从P的stackcache分配=&gt; 如果无法分配 =&gt; 从全局stackpool分配一批stack(stackpoolalloc)，赋给该p的stackcache，再从local stackcache分配</p><h3 id="一些重要参数">一些重要参数</h3><ul><li><p>go_memstats_sys_bytes: 进程从操作系统获得内存的总字节数，包含了go运行的stack，heap还有其他数据结构相关的虚拟地址空间</p></li><li><p>go_memstats_heap_inuse_bytes: 在span中真正被使用的字节数；其中不包括可能已经返回到操作系统，或者可以重用进行对分配、可以将作为堆栈内存重用的字节 (?)</p></li><li><p>go_memstats_heap_idle_bytes: 在span中空闲的字节数;</p></li><li><p>go_memstats_stack_sys_bytes: 栈内存字节数；主要用于goroutine栈内存的分配;</p></li></ul><p>由以上参数结合代码其实可以知道大概span在内存中有几种状态:</p><ol><li><p>idle不包含对象或者其他数据，空闲的物理内存可以释放回OS（虚拟地址不会释放！！！），或者将其转换成inuse状态或者stack span</p></li><li><p>inuse,至少包含一个mheap，并且可能有空闲空间分配更多堆对象</p></li><li><p>stack span，只会在堆或者是栈内存其中之一</p></li></ol><h2 id="内存对齐以及一些分配规则-补充前面的tcmalloc">内存对齐以及一些分配规则(补充前面的tcmalloc)</h2><p>runtime/msize.go</p><div class="hljs"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">roundupsize</span><span class="hljs-params">(size <span class="hljs-keyword">uintptr</span>)</span> <span class="hljs-title">uintptr</span></span> &#123;<span class="hljs-comment">//size&lt;32768</span><span class="hljs-keyword">if</span> size &lt; _MaxSmallSize &#123;<span class="hljs-keyword">if</span> size &lt;= smallSizeMax<span class="hljs-number">-8</span> &#123;<span class="hljs-comment">//这里面的字段是go对特定class设定的对应大小</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">uintptr</span>(class_to_size[size_to_class8[(size+smallSizeDiv<span class="hljs-number">-1</span>)/smallSizeDiv]])&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">uintptr</span>(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv<span class="hljs-number">-1</span>)/largeSizeDiv]])&#125;&#125;<span class="hljs-comment">//size为负数,_PageSize=1&lt;&lt;13 </span><span class="hljs-keyword">if</span> size+_PageSize &lt; size &#123;<span class="hljs-keyword">return</span> size&#125;<span class="hljs-keyword">return</span> round(size, _PageSize)&#125;<span class="hljs-comment">//该运算在下面会提到</span><span class="hljs-comment">// round n up to a multiple of a.  a must be a power of 2.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">round</span><span class="hljs-params">(n, a <span class="hljs-keyword">uintptr</span>)</span> <span class="hljs-title">uintptr</span></span> &#123;<span class="hljs-keyword">return</span> (n + a - <span class="hljs-number">1</span>) &amp;^ (a - <span class="hljs-number">1</span>)&#125;</code></pre></div><p>注意到<strong>class_to_size</strong>和<strong>size_to_class</strong>等等字段</p><p><a id="sizetoclass">[sizetoclass]</a>实际上在runtime/sizeclasses.go里面可以体现出go对不同大小的class设置的size：每个span都带有一个sizeclass，即表明该span的page应该被怎么用；PS: <strong>可以参照tcmalloc 实现思想基本一直</strong></p><blockquote><blockquote><p>class0表示单独分配一个&gt;32KB对象的span，有67个size，每个size有两种，分配用于有指针和无指针对象，所以有个67*2= 134个class (即上面提到的numSpanClasses)</p></blockquote></blockquote><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// class  bytes/obj  bytes/span  objects  tail waste  max waste</span><span class="hljs-comment">//     1          8        8192     1024           0     87.50%</span><span class="hljs-comment">//     2         16        8192      512           0     43.75%</span><span class="hljs-comment">//     3         32        8192      256           0     46.88%</span><span class="hljs-comment">//     4         48        8192      170          32     31.52%</span><span class="hljs-comment">//     5         64        8192      128           0     23.44%</span><span class="hljs-comment">//     6         80        8192      102          32     19.07%</span><span class="hljs-comment">//     7         96        8192       85          32     15.95%</span><span class="hljs-comment">//     8        112        8192       73          16     13.56%</span><span class="hljs-comment">//     9        128        8192       64           0     11.72%</span><span class="hljs-comment">//    10        144        8192       56         128     11.82%</span><span class="hljs-comment">//    11        160        8192       51          32      9.73%</span>......<span class="hljs-comment">//    60      19072       57344        3         128      3.57%</span><span class="hljs-comment">//    61      20480       40960        2           0      6.87%</span><span class="hljs-comment">//    62      21760       65536        3         256      6.25%</span><span class="hljs-comment">//    63      24576       24576        1           0     11.45%</span><span class="hljs-comment">//    64      27264       81920        3         128     10.00%</span><span class="hljs-comment">//    65      28672       57344        2           0      4.91%</span><span class="hljs-comment">//    66      32768       32768        1           0     12.50%</span></code></pre></div><p>可以看到bytes/obj一栏，就是go预定义object大小，最小是8B，最大是32KB（注意这里只是在32KB以内，还有大于32KB以外的），所以都可以解释到<strong>slice</strong>在扩容的时候可能会不遵守*2和1.25倍扩容的规则；</p><p>相关的main方法可以在classToSize的转换runtime/mksizeclass.go中找到</p><h3 id="golang的位运算">golang的位运算</h3><p>有时候会经常看见会用一些全局常量：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">//指针大小,一般64位就是8</span><span class="hljs-keyword">const</span> PtrSize = <span class="hljs-number">4</span> &lt;&lt; (^<span class="hljs-keyword">uintptr</span>(<span class="hljs-number">0</span>) &gt;&gt; <span class="hljs-number">63</span>) <span class="hljs-comment">//8</span></code></pre></div><p>sys.PtrSize, sys.RegSize等等</p><h4 id="1-运算">1. ^运算</h4><ul><li>用作单目运算时， ^ 指的就是取反,等于一些语言的 ~ 符号（这里注意都一样取补码）</li></ul><p>ps: 这里复习一下，</p><p>正数取反：化为二进制，得到补码(正数补码和原码一样)，再对补码每位取反</p><p>负数取反：化为二进制，得到补码(所有除符号位的每位取反，+1)，然后再对补码全部每位取反</p><div class="hljs"><pre><code class="hljs go">x:=^<span class="hljs-number">3</span><span class="hljs-comment">//3=》 0011=》 1100=-4 </span>log.Printf(<span class="hljs-string">"%d"</span>,x)<span class="hljs-comment">//-4</span>x:=^(<span class="hljs-number">-3</span>)<span class="hljs-comment">//-3=》 1011 =》 1100 =》 1101 =》 0010=2</span>log.Printf(<span class="hljs-string">"%d"</span>,x)<span class="hljs-comment">//2</span></code></pre></div><p>也可以用比较直接的方法：^a= -(a+1)</p><ul><li>用作双目运算符时则为异或（XOR）相同为0，相异为1</li></ul><h4 id="2-运算">2. &amp;^运算</h4><p>将运算符号左边数据相异保留，相同置为0;</p><p>符合：</p><ul><li>右侧为0，左侧数不变，</li><li>右侧是1，左侧清零</li><li>符合结合法即 a&amp;^b=a&amp;(^b)</li></ul><p>经常用该符号作内存对齐如runtime/stubs.go里面</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// round n up to a multiple of a.  a must be a power of 2.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">round</span><span class="hljs-params">(n, a <span class="hljs-keyword">uintptr</span>)</span> <span class="hljs-title">uintptr</span></span> &#123;<span class="hljs-keyword">return</span> (n + a - <span class="hljs-number">1</span>) &amp;^ (a - <span class="hljs-number">1</span>)&#125;<span class="hljs-comment">//可以有这种说法：</span><span class="hljs-comment">//找到最大位为１的位数，然后用１左移该位数即是roundup后的结果,</span><span class="hljs-comment">//比如6 : 110,最大为为1的是在第三位，1&lt;&lt;3 = 1000 = 8,即十进制的8</span><span class="hljs-comment">// n=6,a=2 : 110 =&gt; (6+2-1) = 111 &amp;^ 001 = 110</span></code></pre></div><p>runtime/malloc.go</p>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Consensus</title>
    <link href="/2020/02/10/Comcon/consensus/"/>
    <url>/2020/02/10/Comcon/consensus/</url>
    
    <content type="html"><![CDATA[<p>基本的共识思想</p><a id="more"></a><p>想象一下在单机事务一般需要满足的是ACID特性，但是在多机系统中呢？</p><h2 id="在raft和paxos等共识算法之前">在Raft和paxos等共识算法之前</h2><h3 id="2pc">2PC</h3><p>假设 A1, A2, A3三台机子，</p><p>A：atomic原子性，明显不满足（线性）</p><p>C：一致性，共识算法I: 隔离性D：持久性，可以回滚</p><h3 id="线性全序广播">线性全序广播</h3><p>这个话题可以分为两个部分：1.线性 2.全序广播</p><h4 id="1-线性">1. 线性</h4><p>上面说过，线性化指的就是对于一个系统，操作呈现原子性，</p>]]></content>
    
    
    
    <tags>
      
      <tag>Distributed</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS basis</title>
    <link href="/2020/02/03/Comcon/os/"/>
    <url>/2020/02/03/Comcon/os/</url>
    
    <content type="html"><![CDATA[<p>一些乱糟糟的笔记</p><a id="more"></a><h2 id="虚拟内存">虚拟内存</h2><p>段页式以页为单位替换，以段为单位使用。</p><h2 id="进程">进程</h2><p>资源调度的基本单位</p><p>结合golang调度器的一系列思考：</p><h3 id="1-为什么要多个进程">1. 为什么要多个进程</h3><p>多任务处理</p><h3 id="2-为什么不可以在进程之间切换-还要加上线程？">2. 为什么不可以在进程之间切换，还要加上线程？</h3><p>回顾一下进程的定义，创建，销毁</p><ul><li><p>定义</p><p>就是运行期间的程序以及相关资源的集合体，多个进程可以共享一类资源，或者多个进程可以运行一个程序</p></li><li><p>创建</p><p>linux上是由系统fork()(其实通过clone()来实现) init进程（或者现有进程）来创建一个新进程，注意这里会返回两次值，一次回到父进程，一次回到新的子进程，其<strong>开销</strong>其实就是复制父进程页表以及给子进程创建唯一task_struct，说多点这里，也不会一下子复制所有信息，采用copy on write，写时复制;</p><ul><li><p>详情同样是在linux下，fork()后 通过slab分配到task_struct()，其会有用到对象着色以及缓存着色（有点像进程池？？？)</p><ol><li><p>fork()内会调用copy_process()方法，首先会调用dup_task_struct()创建一个<strong>内核栈</strong>,<strong>thread_info结构</strong>和<strong>task_struct</strong>，这些值都与<strong>当前进程(父进程)的值相同</strong></p></li><li><p>检查并确保新创建该子进程后，再检查当前进程数(默认short int 32768，当然你可以自己改/proc/sys/kernel/pid_max，忘了是不是这个了)</p></li><li><p>子进程就开始将一些值清零或者设为默认初始值来区分开，但都是一些统计信息(非继承的task_struct成员),task_struct的值大多数都没有变</p></li><li><p>子进程状态设置为<strong>TASK_UNINTERRUPTABLE</strong>，保证不被运行</p></li><li><p>copy_flags()更新flags成员。清零PF_SUPERPRIV(是否是超级root)。设置PF_FORKNOEXEC()(表明进程还未被调用exec())</p></li><li><p>调用alloc_pid()为新进程分配一个有效pid</p></li><li><p>根据传给clone()的参数，copy_process()copy或者共享打开的文件，文件系统信息，信号处理函数，进程地址空间，命名空间等;</p></li><li><p>最后copy_process()返回一个指向子进程的指针;</p></li></ol></li><li><p>相关命令clone(CLONE_VM | CLONE_FS| CLONE_FILES| CLONE_SIGHAND, 0)</p></li><li><p>额外还有一个vfork，不copy父进程的页面，其余同fork一样</p></li></ul></li><li><p>执行调用exec()函数分配到相应的地址空间，然后将程序放入，</p></li><li><p>销毁调用exit()，这时候会将所有资源释放，父进程可以通过wait4()检查子进程是否被终结，还需要调用wait()或waitip(),否则子进程进入zombie状态</p></li></ul><ol start="3"><li>进程之间如何调度</li></ol><ul><li>分清楚目的：I/O bound 还是 CPU bound ?</li><li>手段<ol><li>优先级？nice值？</li><li>时间片为基本单位</li></ol></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang timer</title>
    <link href="/2020/02/03/Go/timer/"/>
    <url>/2020/02/03/Go/timer/</url>
    
    <content type="html"><![CDATA[<p>//TODO</p><a id="more"></a><p>我们比较熟悉的时间包：</p><h2 id="定义">定义</h2><ol><li>timer.C 是 一个channel，在timer过期后，这个只读chan会有一个值</li><li>除了AfterFunc方法外，一个timer一定要由NewTimer创建</li></ol><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// The Timer type represents a single event.</span><span class="hljs-comment">// When the Timer expires, the current time will be sent on C,</span><span class="hljs-comment">// unless the Timer was created by AfterFunc.</span><span class="hljs-comment">// A Timer must be created with NewTimer or AfterFunc.</span><span class="hljs-keyword">type</span> Timer <span class="hljs-keyword">struct</span> &#123;C &lt;-<span class="hljs-keyword">chan</span> Time <span class="hljs-comment">//一个channel，在timer过期后，这个只读chan会有一个值</span>r runtimeTimer&#125;</code></pre></div><p>runtimeTimer结构:是一个接口</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// Interface to timers implemented in package runtime.</span><span class="hljs-comment">// Must be in sync with ../runtime/time.go:/^type timer</span><span class="hljs-keyword">type</span> runtimeTimer <span class="hljs-keyword">struct</span> &#123;tb <span class="hljs-keyword">uintptr</span>i  <span class="hljs-keyword">int</span>when   <span class="hljs-keyword">int64</span>period <span class="hljs-keyword">int64</span>f      <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-keyword">uintptr</span>)</span> // <span class="hljs-title">NOTE</span>: <span class="hljs-title">must</span> <span class="hljs-title">not</span> <span class="hljs-title">be</span> <span class="hljs-title">closure</span>,不能是闭包？？？，初始化计时器</span>arg    <span class="hljs-keyword">interface</span>&#123;&#125;seq    <span class="hljs-keyword">uintptr</span>&#125;</code></pre></div><h4 id="reset-d-duration-方法">Reset(d Duration)方法</h4><ol><li>返回true，如果这个timer被激活；返回false如果这个timer被停止或者过期(返回值最主要用来保持兼容性)</li><li>Reset只能被 停止或者过期的带有空(队列已经为空)channels的timers 调用</li><li></li></ol><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// Reset changes the timer to expire after duration d.</span><span class="hljs-comment">// It returns true if the timer had been active, false if the timer had</span><span class="hljs-comment">// expired or been stopped.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Reset should be invoked only on stopped or expired timers with drained channels.</span><span class="hljs-comment">// If a program has already received a value from t.C, the timer is known</span><span class="hljs-comment">// to have expired and the channel drained, so t.Reset can be used directly.</span><span class="hljs-comment">// If a program has not yet received a value from t.C, however,</span><span class="hljs-comment">// the timer must be stopped and—if Stop reports that the timer expired</span><span class="hljs-comment">// before being stopped—the channel explicitly drained:</span><span class="hljs-comment">//</span><span class="hljs-comment">// if !t.Stop() &#123;</span><span class="hljs-comment">// &lt;-t.C</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// t.Reset(d)</span><span class="hljs-comment">//</span><span class="hljs-comment">// This should not be done concurrent to other receives from the Timer's</span><span class="hljs-comment">// channel.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Note that it is not possible to use Reset's return value correctly, as there</span><span class="hljs-comment">// is a race condition between draining the channel and the new timer expiring.</span><span class="hljs-comment">// Reset should always be invoked on stopped or expired channels, as described above.</span><span class="hljs-comment">// The return value exists to preserve compatibility with existing programs.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Timer)</span> <span class="hljs-title">Reset</span><span class="hljs-params">(d Duration)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">if</span> t.r.f == <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">"time: Reset called on uninitialized Timer"</span>)&#125;w := when(d)active := stopTimer(&amp;t.r)t.r.when = wstartTimer(&amp;t.r)<span class="hljs-keyword">return</span> active&#125;</code></pre></div><h2 id="引出">引出</h2><h3 id="race-detector-竞态条件检测">Race Detector(竞态条件检测)</h3><p>很简单:</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">go</span> run -race main.<span class="hljs-keyword">go</span> <span class="hljs-keyword">go</span> build -race mycmd   <span class="hljs-comment">// build the command</span><span class="hljs-keyword">go</span> install -race mypkg <span class="hljs-comment">// install the package</span></code></pre></div><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">//官网的例子：</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;     start := time.Now()    <span class="hljs-keyword">var</span> t *time.Timer     t = time.AfterFunc(randomDuration(), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">//这里的t是写入</span>         fmt.Println(time.Now().Sub(start))         t.Reset(randomDuration()) <span class="hljs-comment">//这里的t是读取，可能在一定情况下，randomDuration使得在这里读取前将t置为nil，所以读取了空值，会报nil pointer错误</span>     &#125;)     time.Sleep(<span class="hljs-number">5</span> * time.Second) &#125;  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">randomDuration</span><span class="hljs-params">()</span> <span class="hljs-title">time</span>.<span class="hljs-title">Duration</span></span> &#123;     <span class="hljs-keyword">return</span> time.Duration(rand.Int63n(<span class="hljs-number">1e9</span>)) &#125;</code></pre></div><p>改成以下版本:主要是让t变量只能从main的goroutine中读取和写入</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    start := time.Now()    reset := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>)    <span class="hljs-keyword">var</span> t *time.Timer    t = time.AfterFunc(randomDuration(), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;        fmt.Println(time.Now().Sub(start))        reset &lt;- <span class="hljs-literal">true</span>    &#125;)    <span class="hljs-keyword">for</span> time.Since(start) &lt; <span class="hljs-number">5</span>*time.Second &#123;        &lt;-reset        t.Reset(randomDuration())    &#125;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Reviews on I/O design</title>
    <link href="/2020/01/30/Comcon/DesignIO/"/>
    <url>/2020/01/30/Comcon/DesignIO/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="i-o设计模式">I/O设计模式</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Design Pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO Model</title>
    <link href="/2020/01/15/Comcon/IOModel/"/>
    <url>/2020/01/15/Comcon/IOModel/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="io模型归纳">IO模型归纳</h2><p>我们暂时只以网络IO为例子;我们先从硬件层面进行流程分析:</p><h3 id="1-硬件层面">1. 硬件层面</h3><h4 id="网卡">网卡</h4><p>网卡等于一种可以接收外面数据流的一种设备；</p><ol><li>网卡会先从网线处（或者无线）接收里面的数据</li><li>以某种方式<strong>写入到内存</strong>中</li></ol><p>其中涉及DMA，IO通路选择等硬件问题，我们暂时忽略</p><h4 id="cpu">CPU</h4><p>接着，我们都知道一般操作系统针对一些比较紧急的操作会进行<strong>中断(软，硬)</strong>，当网卡来数据的时候，明显就是比较紧急的事情（如果忽略不管，就会造成内存爆炸或者数据丢失）；</p><p>所以，数据从网卡接收到，会立即发送一个信号到CPU，网卡的中断程序就会被调用去处理数据；</p><h4 id="操作系统调度">操作系统调度</h4><h3 id="2-模型选择">2. 模型选择</h3>]]></content>
    
    
    
    <tags>
      
      <tag>networking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Notes about Strings</title>
    <link href="/2019/08/18/Comcon/StringCompare/"/>
    <url>/2019/08/18/Comcon/StringCompare/</url>
    
    <content type="html"><![CDATA[<p>今天改同事的代码，在匹配字符串方面发现了点东西：levenshtein算法</p><a id="more"></a><h2 id="levenshtein">Levenshtein</h2><p>levenshtein距离指的就是从一个字符串到另外一个字符串中编辑单个字符所需要的次数（删除，更改，插入）举个 :chestnut: :cat --&gt; cite 的levenshtein是2</p><ol><li>cat–&gt; cit (a–&gt;i)</li><li>cit–&gt; cite (_ --&gt;e)</li></ol><h3 id="why">why?</h3><p>为啥子是这样呢，我们可以从矩阵的可视化来讲解:</p><h3 id="normalized-edit-distance">Normalized Edit distance</h3><p>Given two strings X and Y over a finite alphabet, the normalized edit distance between X and Y, d( X , Y ) is defined as the minimum of W( P ) / L ( P )w, here P is an editing path between X and Y , W ( P ) is the sum of the weights of the elementary edit operations of P, and L§ is the number of these operations (length of P).</p><h2 id="jaro-wrinkler">Jaro Wrinkler</h2><p>详细解释可见![wiki]<a href="https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Jaro–Winkler_distance</a></p><p>同样也是计算两个字符串的相似程度,但偏向于单词的前缀匹配</p>]]></content>
    
    
    
    <tags>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Goroutine Notes</title>
    <link href="/2019/07/09/Go/Goroutine/"/>
    <url>/2019/07/09/Go/Goroutine/</url>
    
    <content type="html"><![CDATA[<p>Goroutine 的模型，调度等，它与普通thread有何区别？先留个坑</p><a id="more"></a><h2 id="为什么有这个东西？">为什么有这个东西？</h2><ol><li><p>传统OS自带的线程一个占栈1MB，明显大的过分，所以编程语言自身得另外实现一些小的线程, 而goroutines一般就4KB左右，当然这个数值是可以调整的；</p></li><li><p>切换上下文的时候一般一个线程就消耗1μs,但是goroutine的切换则仅仅有0.2μs左右，大约快了80%;（里面避免了内核和用户态上的切换）</p></li></ol><h3 id="引用">引用</h3><p>《 Scalable Go Scheduler Design Doc》中有描述</p><blockquote><p>Goroutines are part of making concurrency easy to use. The idea, which has been around for a while, is to multiplex independently    executing functions—coroutines—onto a set of threads. When a coroutine blocks, such as by calling a blocking system call, the run-time automatically moves other coroutines on the same operating system thread to a different, runnable thread so they won’t be blocked. The programmer sees none of this, which is the point. The result, which we call goroutines, can be very cheap: unless they spend a lot of time in long-running system calls, they cost little more than the memory for the stack, which is just a few kilobytes.</p></blockquote><p>大概意思就是 当系统调用阻塞，runtime环境会自动把被阻塞在当前线程内的coroutines移到另一个线程，这种在go里面就叫goroutines;</p><p>而针对goroutines的大小，也做了如下设计:</p><blockquote><p>To make the stacks small, Go’s run-time uses segmented stacks. A newly minted goroutine is given a few kilobytes, which is almost always enough. When it isn’t, the run-time allocates (and frees) extension segments automatically. The overhead averages about three cheap instructions per function call. It is practical to create hundreds of thousands of goroutines in the same address space. If goroutines were just threads, system resources would run out at a much smaller number.</p></blockquote><p>然后对于goroutine的栈设计，使用了<strong>分段</strong>的栈， 而且对于分段的栈增加了灵活性，当空间不足的话就会自动分配更多的空间，而且因为这个不涉及内核层面，不用保存过多信息，所以你可以在同一个地址空间里创建上千个goroutines</p><ul><li><p>这些分段栈的基本功能</p><ol><li>保护回复上下文的函数</li><li>运行队列processQueue</li></ol></li></ul><p>要时刻明白对于线程来讲，其<strong>阻塞指的是切换了调度队列</strong>，不再进行当前的<strong>数据控制流</strong>，如果其他流满足条件，则会移出当前队列，调度会之前的数据流。同理goroutine也只是一个结构，记录了运行的函数，运行的位置等</p><h2 id="调度模型">调度模型</h2><p>一般来说多线程调度模型有 work-sharing 和 work-stealing模型</p><p>go采用了后者，可以看看有关<a href="http://supertech.csail.mit.edu/papers/steal.pdf" target="_blank" rel="noopener">work-stealing的论文</a></p><p>架构：GPM</p><ul><li>G（goroutine）指的是go语言的goroutine（有些人叫它为协程，但其实跟coroutine有一点区别，因为coroutine单纯在用户态使用）</li></ul><h3 id="调度时机">调度时机</h3><ol><li>Channel,mutex之类同步操作发生阻塞</li><li>time.sleep</li><li>主动调用runtime.GoSched()</li><li>网络IO阻塞</li><li>gc</li><li>运行过久或者系统调用过久</li></ol><h3 id="scheduler调度过程">Scheduler调度过程</h3><h4 id="大概流程">大概流程</h4><p>调度前的检查:</p><ol><li>是否分配有gc mark，如果有则要做gc mark</li><li>检查有无localq，有就运行</li><li>没有则看globalq</li><li>看一下net中有无poll的出来</li><li>从其他的p 偷一部分</li></ol><h4 id="相关状态转换">相关状态转换</h4><p><img src="/img/gstatus.png" srcset="/img/loading.gif" alt="一个状态图"></p><p>当有新的Goroutine被创建或者是现存的goroutine更新为runnable状态，它会被push到当前P的runnable goroutine list里面，当P完成了执行goroutine，它会</p><ul><li>首先从自己的runnable g list里面pop一个goroutine，如果list是空的，它会随机选取其他P，并且偷取其list的一半runnable goroutine</li></ul><p>当M 创建了新的goroutine，它要保证有其他M执行这个goroutine同样的，如果M进入了syscall阶段，它也要保证有其他M可以执行这个goroutine</p><p>禁止抢占:</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runtime_procPin</span><span class="hljs-params">()</span> <span class="hljs-title">int</span> //标记当前<span class="hljs-title">G</span>在<span class="hljs-title">M</span>上不会被抢占，并返回当前<span class="hljs-title">P</span>的<span class="hljs-title">ID</span></span></code></pre></div><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runtime_procUnpin</span><span class="hljs-params">()</span> //解除抢占标志</span></code></pre></div><p>这里我们有两种方法：我们可以立即block或unblock多个M，或使其自旋；但这里会有性能损耗和花费不必要的cpu周期，方法是使用自旋而且burn CPU cycles(???)然而，这不应该影响在GOMAXPROCS=1的程序（command line，appengine这些）</p><p>自旋有两个等级：</p><ol><li>一个已经附着了一个P的idle M 会不断自旋寻找新的Goroutines</li><li>一个已经附着了一个P的M 自旋等待其他可用的P以上中，最多有GOMAXPROCS个自旋的goroutines， 等级（1）的idle M 不会阻塞 即使有等级（2）的idle M；当新的goroutine被创建或者M进入syscall或者M从idle变成busy，它会保证至少存在一个自旋M （或者所有P是busy），</li><li>这就保证了不会有当前运行着的Goroutines被其他 M 运行</li><li>也避免了过多的 M 同时 阻塞和释放阻塞</li></ol><h3 id="sysmon">Sysmon</h3><p>sysmon是在<strong>runtime初始化之后，执行代码之前</strong>，由runtime启动且不与任何P绑定直接由一个M执行的协程，类似于linux的一些系统任务内核线程</p><p>具体设置如<img src="/img/sysmon.png" srcset="/img/loading.gif" alt="sysmon状态转换图"></p><h3 id="各个结构体">各个结构体</h3><ul><li>g (goroutine)</li></ul><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> g <span class="hljs-keyword">struct</span> &#123;goid           <span class="hljs-keyword">int64</span><span class="hljs-comment">// Stack parameters.</span><span class="hljs-comment">// stack describes the actual stack memory: [stack.lo, stack.hi).</span><span class="hljs-comment">// stackguard0 is the stack pointer compared in the Go stack growth prologue.</span><span class="hljs-comment">//stackguard0用作栈的指针</span><span class="hljs-comment">// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.</span><span class="hljs-comment">// stackguard1 is the stack pointer compared in the C stack growth prologue.</span><span class="hljs-comment">// It is stack.lo+StackGuard on g0 and gsignal stacks.</span><span class="hljs-comment">// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).</span>stack       stack   <span class="hljs-comment">// offset known to runtime/cgo</span><span class="hljs-comment">//栈空间[lo,hi)</span><span class="hljs-comment">//type stack struct &#123;</span><span class="hljs-comment">//lo uintptr</span><span class="hljs-comment">//hi uintptr</span><span class="hljs-comment">//&#125;</span>stackguard0 <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// offset known to liblink</span>stackguard1 <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// offset known to liblink</span>    ...m              *m      <span class="hljs-comment">// current m; offset known to arm liblink</span><span class="hljs-comment">//调度器,上下文保存的信息所在地</span>sched          gobuf    ...param          unsafe.Pointer <span class="hljs-comment">// passed parameter on wakeup</span>...schedlink      guintptrwaitsince      <span class="hljs-keyword">int64</span>      <span class="hljs-comment">// approx time when the g become blocked</span>waitreason     waitReason <span class="hljs-comment">// if status==Gwaiting</span>preempt        <span class="hljs-keyword">bool</span>       <span class="hljs-comment">// preemption signal, duplicates stackguard0 = stackpreempt</span>...preemptscan    <span class="hljs-keyword">bool</span>       <span class="hljs-comment">// preempted g does scan for gc</span>gcscandone     <span class="hljs-keyword">bool</span>       <span class="hljs-comment">// g has scanned stack; protected by _Gscan bit in status</span>gcscanvalid    <span class="hljs-keyword">bool</span>       <span class="hljs-comment">// false at start of gc cycle, true if G has not run since last scan; <span class="hljs-doctag">TODO:</span> remove?</span>...raceignore     <span class="hljs-keyword">int8</span>       <span class="hljs-comment">// ignore race detection events</span>sysblocktraced <span class="hljs-keyword">bool</span>       <span class="hljs-comment">// StartTrace has emitted EvGoInSyscall about this goroutine</span>sysexitticks   <span class="hljs-keyword">int64</span>      <span class="hljs-comment">// cputicks when syscall has returned (for tracing)</span>traceseq       <span class="hljs-keyword">uint64</span>     <span class="hljs-comment">// trace event sequencer</span>tracelastp     puintptr   <span class="hljs-comment">// last P emitted an event for this goroutine</span>    lockedm        muintptr        <span class="hljs-comment">//本身的寄存器状态</span>sig            <span class="hljs-keyword">uint32</span>writebuf       []<span class="hljs-keyword">byte</span>sigcode0       <span class="hljs-keyword">uintptr</span>sigcode1       <span class="hljs-keyword">uintptr</span>sigpc          <span class="hljs-keyword">uintptr</span>    gopc           <span class="hljs-keyword">uintptr</span>         <span class="hljs-comment">// pc of go statement that created this goroutine</span>    ....startpc        <span class="hljs-keyword">uintptr</span>         <span class="hljs-comment">// pc of goroutine function</span>racectx        <span class="hljs-keyword">uintptr</span>waiting        *sudog         <span class="hljs-comment">// sudog structures this g is waiting on (that have a valid elem ptr); in lock order</span>.....<span class="hljs-comment">// Per-G GC state</span><span class="hljs-comment">// gcAssistBytes is this G's GC assist credit in terms of</span><span class="hljs-comment">// bytes allocated. If this is positive, then the G has credit</span><span class="hljs-comment">// to allocate gcAssistBytes bytes without assisting. If this</span><span class="hljs-comment">// is negative, then the G must correct this by performing</span><span class="hljs-comment">// scan work. We track this in bytes to make it fast to update</span><span class="hljs-comment">// and check for debt in the malloc hot path. The assist ratio</span><span class="hljs-comment">// determines how this corresponds to scan work debt.</span>gcAssistBytes <span class="hljs-keyword">int64</span>&#125;</code></pre></div><ul><li>M（machine）指的就是OS原生线程，是真正调度资源的单位，M是idle或者syscall中，需要P的调度</li></ul><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> m <span class="hljs-keyword">struct</span> &#123;id            <span class="hljs-keyword">int64</span>    <span class="hljs-comment">//g0是一个调用栈</span>g0      *g     <span class="hljs-comment">// goroutine with scheduling stack</span>morebuf gobuf  <span class="hljs-comment">// gobuf arg to morestack</span>procid        <span class="hljs-keyword">uint64</span>       <span class="hljs-comment">// for debuggers, but offset not hard-coded</span><span class="hljs-comment">//底层的线程id</span>    ...    <span class="hljs-comment">//这个信号处理的goroutines</span>gsignal       *g           <span class="hljs-comment">// signal-handling g</span>goSigStack    gsignalStack <span class="hljs-comment">// Go-allocated signal handling stack</span>    sigmask       sigset       <span class="hljs-comment">// storage for saved signal mask</span><span class="hljs-comment">//TLS启动时候要使用</span><span class="hljs-comment">//传给FS寄存器的局部变量</span>tls           [<span class="hljs-number">6</span>]<span class="hljs-keyword">uintptr</span>   <span class="hljs-comment">// thread-local storage (for x86 extern register)</span><span class="hljs-comment">//m启动时的函数，会传给clone</span>mstartfn      <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;&#125;  <span class="hljs-comment">//当前运行的goroutine,&#123;&#125;在语法中是错误的，这里为了使markdown解析而加上</span><span class="hljs-comment">//当前运行代码的g</span>    curg          *g       <span class="hljs-comment">// current running goroutine</span>    caughtsig     guintptr <span class="hljs-comment">// goroutine running during fatal signal</span>    p             puintptr <span class="hljs-comment">// attached p for executing go code (nil if not executing go code)</span>    nextp         puintptr    oldp          puintptr <span class="hljs-comment">// the p that was attached before executing a syscall</span>mallocing     <span class="hljs-keyword">int32</span>    throwing      <span class="hljs-keyword">int32</span>    <span class="hljs-comment">//如果不等于"",没有发生抢占</span>    preemptoff    <span class="hljs-keyword">string</span> <span class="hljs-comment">// if != "", keep curg running on this m</span>    locks         <span class="hljs-keyword">int32</span>....        <span class="hljs-comment">//m正在自旋，寻找可以attach的工作对象(P), m找不到可运行的g</span>spinning      <span class="hljs-keyword">bool</span> <span class="hljs-comment">// m is out of work and is actively looking for work</span>blocked       <span class="hljs-keyword">bool</span> <span class="hljs-comment">// m is blocked on a note</span>    .....    <span class="hljs-comment">//如果=0，则可以清空g0以及清除该m，是原子性的操作</span>freeWait      <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// if == 0, safe to free g0 and delete m (atomic)</span>fastrand      [<span class="hljs-number">2</span>]<span class="hljs-keyword">uint32</span>needextram    <span class="hljs-keyword">bool</span>    traceback     <span class="hljs-keyword">uint8</span>...<span class="hljs-comment">//里面一些cgo的代码</span>park          note    alllink       *m <span class="hljs-comment">// on allm</span>    <span class="hljs-comment">//调度链，是一个m的指针</span>    schedlink     muintptr<span class="hljs-comment">//每一个P(Per-thread)的用于存储小对象的cache,没有锁，因为都在一个P内，运行代码时绑定的p中的mcache</span>    mcache        *mcache    <span class="hljs-comment">//goroutine的指针,uintptr可以避过写屏障, 主要用于Gobuf goroutine状态或者是那些不经过P的调度列表</span><span class="hljs-comment">//是否与某个g一直绑定</span>    lockedg       guintptr    <span class="hljs-comment">//创建当前thread的栈</span>createstack   [<span class="hljs-number">32</span>]<span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// stack that created this thread.</span>        ...<span class="hljs-comment">//track用</span>    <span class="hljs-comment">//下一个等待锁的M</span>nextwaitm     muintptr    <span class="hljs-comment">// next m waiting for lock</span>    <span class="hljs-comment">//一些锁的操作</span>    waitunlockf   <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*g, unsafe.Pointer)</span> <span class="hljs-title">bool</span></span>waitlock      unsafe.Pointerwaittraceev   <span class="hljs-keyword">byte</span>waittraceskip <span class="hljs-keyword">int</span>startingtrace <span class="hljs-keyword">bool</span>syscalltick   <span class="hljs-keyword">uint32</span>thread        <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// thread handle</span>freelink      *m      <span class="hljs-comment">// on sched.freem</span>    ...    <span class="hljs-comment">//debug</span>dlogPerM    <span class="hljs-comment">//表明操作系统相关</span>mOS&#125;</code></pre></div><ul><li>P（Process）指的是go语言中的调度器，M就是用P才能调度G可以看到P是内嵌于 M 和 G 之间的，</li></ul><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> p <span class="hljs-keyword">struct</span> &#123;    <span class="hljs-comment">//每一个p都有自己的id</span>    id          <span class="hljs-keyword">int32</span>    <span class="hljs-comment">//状态，有_Pidle ,_Prunning,_Psyscall, _Pgcstop, _Pdead</span>    status      <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// one of pidle/prunning/...</span>        link        puintptr        <span class="hljs-comment">//每次调度都会自增</span>schedtick   <span class="hljs-keyword">uint32</span>     <span class="hljs-comment">// incremented on every scheduler call</span>    syscalltick <span class="hljs-keyword">uint32</span>     <span class="hljs-comment">// incremented on every system call</span>    <span class="hljs-comment">//go程序启动时候的sysmon用</span>    sysmontick  sysmontick <span class="hljs-comment">// last tick observed by sysmon</span>    <span class="hljs-comment">//指的是后面指针连接的一个m,同时该m也有一个指针连向自己 ???</span>    m           muintptr   <span class="hljs-comment">// back-link to associated m (nil if idle)</span>    <span class="hljs-comment">//</span>mcache      *mcacheraceprocctx <span class="hljs-keyword">uintptr</span>    <span class="hljs-comment">//defer的池,defer函数，结构在此</span>deferpool    [<span class="hljs-number">5</span>][]*_defer <span class="hljs-comment">// pool of available defer structs of different sizes (see panic.go)</span>deferpoolbuf [<span class="hljs-number">5</span>][<span class="hljs-number">32</span>]*_defer    <span class="hljs-comment">//goroutine的id生成，能平均分到每一个idgen中</span><span class="hljs-comment">// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.</span>goidcache    <span class="hljs-keyword">uint64</span>goidcacheend <span class="hljs-keyword">uint64</span>    <span class="hljs-comment">//这个就是连接的可运行的goroutines队列,可以不加锁访问（都在一个P里面，没必要加锁）</span><span class="hljs-comment">// Queue of runnable goroutines. Accessed without lock.</span>runqhead <span class="hljs-keyword">uint32</span>runqtail <span class="hljs-keyword">uint32</span>runq     [<span class="hljs-number">256</span>]guintptr<span class="hljs-comment">// runnext, if non-nil, is a runnable G that was ready'd by</span><span class="hljs-comment">// the current G and should be run next instead of what's in</span><span class="hljs-comment">// runq if there's time remaining in the running G's time</span><span class="hljs-comment">// slice. It will inherit the time left in the current time</span><span class="hljs-comment">// slice. If a set of goroutines is locked in a</span><span class="hljs-comment">// communicate-and-wait pattern, this schedules that set as a</span><span class="hljs-comment">// unit and eliminates the (potentially large) scheduling</span><span class="hljs-comment">// latency that otherwise arises from adding the ready'd</span><span class="hljs-comment">// goroutines to the end of the run queue.</span><span class="hljs-comment">//如果runnext非空，则是一个runnable状态的g，如果在当前时间片中还有剩余，则runnext指向的就是下一个应该运行的g而不使用runq里面的g，其会继承剩下的时间；</span>runnext guintptr<span class="hljs-comment">// Available G's (status == Gdead)</span>gFree <span class="hljs-keyword">struct</span> &#123;gListn <span class="hljs-keyword">int32</span>&#125;    <span class="hljs-comment">//sudog相关</span>sudogcache []*sudogsudogbuf   [<span class="hljs-number">128</span>]*sudog...<span class="hljs-comment">//trace的一些东西</span>palloc persistentAlloc <span class="hljs-comment">// per-P to avoid mutex</span>    <span class="hljs-comment">//用作优化内存对齐</span>_ <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// Alignment for atomic fields below</span><span class="hljs-comment">// Per-P GC state</span>gcAssistTime         <span class="hljs-keyword">int64</span>    <span class="hljs-comment">// Nanoseconds in assistAlloc</span>gcFractionalMarkTime <span class="hljs-keyword">int64</span>    <span class="hljs-comment">// Nanoseconds in fractional mark worker (atomic)</span>gcBgMarkWorker       guintptr <span class="hljs-comment">// (atomic)</span>gcMarkWorkerMode     gcMarkWorkerMode<span class="hljs-comment">// gcMarkWorkerStartTime is the nanotime() at which this mark</span><span class="hljs-comment">// worker started.</span>gcMarkWorkerStartTime <span class="hljs-keyword">int64</span><span class="hljs-comment">// gcw is this P's GC work buffer cache. The work buffer is</span><span class="hljs-comment">// filled by write barriers, drained by mutator assists, and</span><span class="hljs-comment">// disposed on certain GC state transitions.</span>gcw gcWork<span class="hljs-comment">// wbBuf is this P's GC write barrier buffer.</span><span class="hljs-comment">//</span><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Consider caching this in the running G.</span>wbBuf wbBufrunSafePointFn <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// if 1, run sched.safePointFn at next safe point</span>pad cpu.CacheLinePad&#125;</code></pre></div><ul><li>SchedDt 调度结构</li></ul><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> schedt <span class="hljs-keyword">struct</span>&#123;lock mutex<span class="hljs-comment">//锁用于调用globalq的时候使用</span><span class="hljs-comment">// When increasing nmidle, nmidlelocked, nmsys, or nmfreed, be</span><span class="hljs-comment">// sure to call checkdead().</span><span class="hljs-comment">//空闲的m</span>midle        muintptr <span class="hljs-comment">// idle m's waiting for work</span>nmidle       <span class="hljs-keyword">int32</span>    <span class="hljs-comment">// number of idle m's waiting for work</span>nmidlelocked <span class="hljs-keyword">int32</span>    <span class="hljs-comment">// number of locked m's waiting for work</span>mnext        <span class="hljs-keyword">int64</span>    <span class="hljs-comment">// number of m's that have been created and next M ID</span>maxmcount    <span class="hljs-keyword">int32</span>    <span class="hljs-comment">// maximum number of m's allowed (or die)</span>nmsys        <span class="hljs-keyword">int32</span>    <span class="hljs-comment">// number of system m's not counted for deadlock</span>nmfreed      <span class="hljs-keyword">int64</span>    <span class="hljs-comment">// cumulative number of freed m's</span>ngsys <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// number of system goroutines; updated atomically</span><span class="hljs-comment">//空闲的p</span>pidle      puintptr <span class="hljs-comment">// idle p's</span>npidle     <span class="hljs-keyword">uint32</span><span class="hljs-comment">//在spinning状态的m的数量</span>nmspinning <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// See "Worker thread parking/unparking" comment in proc.go.</span><span class="hljs-comment">// Global runnable queue.</span><span class="hljs-comment">//可运行 的globalq</span>runq     gQueuerunqsize <span class="hljs-keyword">int32</span><span class="hljs-comment">// disable controls selective disabling of the scheduler.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Use schedEnableUser to control this.</span><span class="hljs-comment">//</span><span class="hljs-comment">// disable is protected by sched.lock.</span>disable <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">// user disables scheduling of user goroutines.</span>user     <span class="hljs-keyword">bool</span>runnable gQueue <span class="hljs-comment">// pending runnable Gs</span>n        <span class="hljs-keyword">int32</span>  <span class="hljs-comment">// length of runnable</span>&#125;<span class="hljs-comment">// Global cache of dead G's.</span><span class="hljs-comment">//全局空余剩下的g</span>gFree <span class="hljs-keyword">struct</span> &#123;lock    mutexstack   gList <span class="hljs-comment">// Gs with stacks</span>noStack gList <span class="hljs-comment">// Gs without stacks</span>n       <span class="hljs-keyword">int32</span>&#125;&#125;</code></pre></div><p>相关结构可以在runtime/runtime2.go 中找到</p><p>P在GOMAXPROCS中，所有的P被组织成一个数组，当GOMAXPROCS改变时会触发 stop the world来重新调整P 数组的长度一些变量会从sched中分离出到P中</p><h3 id="死锁检测和终止">死锁检测和终止</h3><p>当所有P是idle的时候进行检测（全局idle P的原子计数）</p><p>旋转态-&gt;不旋态的转换中，可能和创建一个新的goroutine和创建一部分或其他需要unpark的工作线程 的时候发生竞态条件如果转换和创建都失败，我们就可以以半静态cpu未充分利用结束；goroutine 准备步骤是：提交一个goroutine去local queue，store-style memory 屏障，检查sched.nmspinning</p><p>不旋态-&gt;旋转态是： 减少nmspinning，store-style memory 屏障，检查新的work的所有per-P work queue而且以上都不适用于global run queue</p><h3 id="协作式抢占">协作式抢占</h3><p>retake() 调用preemptone()将被抢占的G的stackguard0 设为stackPreempt，被设置标志的G下一次进行函数调用的时候，检查栈空间失败。然后会触发morestack() (汇编代码,asm_xxx.s)然后进行一连串的函数调用大概流程</p><p>morestack()–&gt; newstack()–&gt; gopreempt_m() --&gt; goschedImpl() --&gt; schedule()</p><h2 id="补充：">补充：</h2><p>网上的经验：</p><p>这个goroutine类似于线程池管理(c++线程池原理相似)，</p><ol><li>遇到阻塞的情况，怎么扩展进程池，使其不会因为任务阻塞或者同步独占线程</li></ol><ol start="2"><li><p>goroutine类似green threads（Green threads），是application自己维护的执行过程；很多goroutines实际上被有限个操作系统管理的threads执行;</p></li><li><p>goroutine的调度往往发生在I/O和系统调用的时候。如果创建的goroutines都是跑for循环做纯计算（没有I/O），那就需要我们自己时不常的调用 runtime.Gosched()，否则那几个在thread上跑的goroutines会霸占着threads，不让其他goroutines有机会跑起来;</p></li><li><p>用户代码造成的协程同步造成的阻塞，只是切换(gopark)协程，而不是阻塞线程，<strong>m和p仍结合</strong>，去寻找新的可执行的g;</p></li><li><p>上层封装了epoll，网络fd会设置成NonBlocking模式，返回EAGAIN则gopark当前goroutine，在m调度，sysmon中，gc start the world等阶段均会poll出ready的goroutine进行运行或者添加到全局runq中</p></li></ol><p><strong>一些小细节</strong>代码经常发现一些编辑器生成的//go:nosplit字样</p><blockquote><blockquote><p>The //go:nosplit directive specifies that the next function declared in the file must not include a stack overflow check. This is most commonly used by low-level runtime sources invoked at times when it is unsafe for the calling goroutine to be preempted.</p></blockquote></blockquote><p>大意即为这个生成函数不能含有检查栈溢出的代码，即会跳过栈溢出检查（why???个人认为是设计问题，就不允许有检查栈移除代码），有时goroutine要被抢占陷入不安全情况时，被底层runtime调用</p><h2 id="systemstack">SystemStack</h2><p>SystemStack(fn func())系统栈 被不同地方调用会有不同的表现方式：</p><ul><li><p>直接调用fn并返回 需要满足：</p><ul><li><p>被 单个线程的g0 stack调用    或</p></li><li><p>被信号处理的栈(gsignal)调用,m中有个gsinal字段 ???</p></li></ul></li><li><p>否则，都从一个普通的goroutine的有限的stack中调用</p><p>表现： 会先切去线程的栈，调用fn，然后切回来该goroutine的栈</p></li></ul><div class="hljs"><pre><code class="hljs golang"><span class="hljs-comment">// systemstack runs fn on a system stack.</span><span class="hljs-comment">// If systemstack is called from the per-OS-thread (g0) stack, or</span><span class="hljs-comment">// if systemstack is called from the signal handling (gsignal) stack,</span><span class="hljs-comment">// systemstack calls fn directly and returns.</span><span class="hljs-comment">// Otherwise, systemstack is being called from the limited stack</span><span class="hljs-comment">// of an ordinary goroutine. In this case, systemstack switches</span><span class="hljs-comment">// to the per-OS-thread stack, calls fn, and switches back.</span><span class="hljs-comment">// It is common to use a func literal as the argument, in order</span><span class="hljs-comment">// to share inputs and outputs with the code around the call</span><span class="hljs-comment">// to system stack:</span><span class="hljs-comment">//</span><span class="hljs-comment">//... set up y ...</span><span class="hljs-comment">//systemstack(func() &#123;</span><span class="hljs-comment">//x = bigcall(y)</span><span class="hljs-comment">//&#125;)</span><span class="hljs-comment">//... use x ...</span><span class="hljs-comment">//</span><span class="hljs-comment">//go:noescape</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">systemstack</span><span class="hljs-params">(fn <span class="hljs-keyword">func</span>()</span>)</span></code></pre></div><h3 id="一个大概的go程序启动流程">一个大概的go程序启动流程</h3><p>golang注释中有大概写明:</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// The bootstrap sequence is:</span><span class="hljs-comment">//</span><span class="hljs-comment">//call osinit</span><span class="hljs-comment">//call schedinit</span><span class="hljs-comment">//make &amp; queue new G</span><span class="hljs-comment">//call runtime·mstart</span><span class="hljs-comment">// The new G calls runtime·main.</span></code></pre></div><p><img src="/img/" srcset="/img/loading.gif" alt="大概的流程图"></p><p>go程序的入口点是runtime.rt0_go, 流程是:</p><ol><li>分配栈空间, 需要2个本地变量+2个函数参数, 然后向8对齐</li></ol><p>把传入的argc和argv保存到栈上(rdx寄存器通常用作上下文存储)</p><p>更新g0中的stackguard的值, stackguard用于检测栈空间是否不足, 需要分配新的栈空间(栈扩展会申请多一块栈空间并把现在的复制过去)</p><p>获取当前cpu的信息并保存到各个全局变量</p><p>调用_cgo_init如果函数存在</p><ol start="2"><li>初始化当前线程的TLS(thread-local-storage), 设置FS寄存器为m0.tls+8(获取时会-8)这里跟SP寄存器有关(伪的SP寄存器的地址 = 硬件SP寄存器+8，64位机)</li></ol><p>测试TLS是否工作</p><p>设置g0到TLS中, 表示当前的g是g0</p><p>设置m0.g0 = g0</p><p>设置g0.m = m0</p><h4 id="特殊的m0和g0">特殊的m0和g0</h4><ul><li><p>M0 是启动程序后的编号为 0 的主线程，这个 M 对应的实例会在全局变量 runtime.m0 中，不需要在 heap 上分配，M0 负责执行初始化操作和启动第一个 G， 在之后 M0 就和其他的 M 一样了。</p></li><li><p>G0 是每次启动一个 M 都会第一个创建的 gourtine，G0 仅用于负责调度的 G，G0 不指向任何可执行的函数，每个 M 都会有一个自己的 G0。在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0。</p></li></ul><ol start="3"><li>调用runtime.check做一些检查</li></ol><p>调用runtime.args保存传入的argc和argv到全局变量</p><p>调用runtime.osinit根据系统执行不同的初始化</p><p>这里(linux x64)设置了全局变量ncpu等于cpu核心数量</p><ol start="4"><li>调用**runtime.schedinit()**执行共同的初始化</li></ol><p>这里的处理比较多:</p><ul><li><p>首先会调用raceinit()检查race condition</p></li><li><p>然后进接这tracebackinit()和moduledateverify()，分别为一些变量提前初始化和包的验证</p></li></ul><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tracebackinit</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// Go variable initialization happens late during runtime startup.</span><span class="hljs-comment">// Instead of initializing the variables above in the declarations,</span><span class="hljs-comment">// schedinit calls this function so that the variables are</span><span class="hljs-comment">// initialized and available earlier in the startup sequence.</span>skipPC = funcPC(skipPleaseUseCallersFrames)&#125;</code></pre></div><ul><li>会初始化栈空间分配器(stackinit)</li></ul><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stackinit</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">//// Per-P, per order stack segment cache size.</span><span class="hljs-comment">//_StackCacheSize = 32 * 1024</span><span class="hljs-comment">// stack的分段大小一定要是pagesize的倍数（容易理解，方便对齐）</span><span class="hljs-comment">//_PageShift = 13</span><span class="hljs-comment">//_PageSize = 1 &lt;&lt; _PageShift = 8192</span><span class="hljs-comment">//_PageMask = _PageSize - 1</span><span class="hljs-keyword">if</span> _StackCacheSize&amp;_PageMask != <span class="hljs-number">0</span> &#123;throw(<span class="hljs-string">"cache size must be a multiple of page size"</span>)&#125;<span class="hljs-comment">//stackpool就是一个span的双向链表</span><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> stackpool &#123;stackpool[i].init()&#125;<span class="hljs-comment">// stackLarge的free是一个list ， 大小为 log_2(s.npages)</span><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> stackLarge.free &#123;stackLarge.free[i].init()&#125;&#125;</code></pre></div><p>这里插入一副<s>盗</s>借来的<img src="/img/mheap.png" srcset="/img/loading.gif" alt="图">更加明确发现一些奇怪的特点</p><ul><li><p>mallocinit()</p><ol><li>这个最主要是检查page，huge page大小是不是2的倍数以及是不是大于最小页大小(4KB)</li><li>然后就初始化 heap，在memManage 那篇文章有讲到,会初始化多个fixalloc，包括treap，span，cache，specialfinalizer，specialprofile，arenaHint还有getg()获得当前g的指针，以及初始化当前mcache(allocmcache())</li><li>创建初始化的arena区域(即是heap)的增长规则,注意在64bit机器中，其做了一些优化:从中间空间开始分配,如上面的图一样，<ul><li>可以更加容易地增长连续空间</li><li>使其更加容易debug</li><li>为了gccgo区别于其他数据</li><li>UTF8编码</li></ul></li></ol></li></ul><ul><li><p>mcommoninit(<em>g</em>.m),这里是一些公共初始化主要对_g_.m即自己的m进行一些初始化</p></li><li><p>按cpu核心数量或GOMAXPROCS的值生成P(cpuinit)</p></li></ul><div class="hljs"><pre><code class="hljs go">cpuinit()       <span class="hljs-comment">// must run before alginit</span></code></pre></div><ul><li>alginit</li></ul><div class="hljs"><pre><code class="hljs go">alginit()       <span class="hljs-comment">// maps must not be used before this call</span></code></pre></div><ul><li>生成P的处理在procresize中</li></ul><p>更改了P的数目，期间stop the world并锁住sched，返回本地的所有p</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">schedinit</span><span class="hljs-params">()</span></span>&#123;...sched.lastpoll = <span class="hljs-keyword">uint64</span>(nanotime())procs := ncpu<span class="hljs-keyword">if</span> n, ok := atoi32(gogetenv(<span class="hljs-string">"GOMAXPROCS"</span>)); ok &amp;&amp; n &gt; <span class="hljs-number">0</span> &#123;procs = n&#125;<span class="hljs-keyword">if</span> procresize(procs) != <span class="hljs-literal">nil</span> &#123;throw(<span class="hljs-string">"unknown runnable goroutine during bootstrap"</span>)&#125;...&#125;<span class="hljs-comment">// Change number of processors. The world is stopped, sched is locked.</span><span class="hljs-comment">// gcworkbufs are not being modified by either the GC or</span><span class="hljs-comment">// the write barrier code.</span><span class="hljs-comment">// Returns list of Ps with local work, they need to be scheduled by the caller.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">procresize</span><span class="hljs-params">(nprocs <span class="hljs-keyword">int32</span>)</span> *<span class="hljs-title">p</span></span> &#123; ... &#125;</code></pre></div><ol start="5"><li><p>调用runtime.newproc创建一个新的goroutine, 指向的是runtime.mainruntime.newproc这个函数在创建普通的goroutine时也会使用;</p></li><li><p>调用runtime·mstart启动m0</p><ul><li>启动后m0会不断从运行队列获取G并运行, runtime.mstart调用后不会返回</li><li>runtime.mstart这个函数是m的入口点(不仅仅是m0), 在下面的&quot;调度器的实现&quot;中会详细讲解</li></ul></li></ol><h3 id="runtime-main之后">runtime.main之后</h3><p>第一个被调度的G会运行runtime.main, 流程是:</p><p>标记主函数已调用, 设置mainStarted = true</p><p>启动一个新的M执行sysmon函数, 这个函数会监控全局的状态并对运行时间过长的G进行抢占</p><p>要求G必须在当前M(系统主线程)上执行</p><p>调用runtime_init函数</p><p>调用gcenable函数</p><p>调用main.init函数, 如果函数存在</p><p>不再要求G必须在当前M上运行</p><p>如果程序是作为c的类库编译的, 在这里返回</p><p>调用main.main函数</p><p>如果当前发生了panic, 则等待panic处理</p><p>调用exit(0)退出程序</p><h2 id="defer函数">Defer函数</h2><p>平常用的</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">do</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">defer</span> done()&#125;</code></pre></div><p>其结构在 runtime2.go 结构体g中</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> g <span class="hljs-keyword">struct</span>&#123;goid <span class="hljs-keyword">int64</span>...<span class="hljs-comment">//其结构有些在stack中有些在heap中，但是逻辑上都属于stack，所以写屏障是没有必要的;</span>_defer *<span class="hljs-keyword">defer</span>&#123;siz     <span class="hljs-keyword">int32</span> <span class="hljs-comment">// includes both arguments and results</span>started <span class="hljs-keyword">bool</span>heap    <span class="hljs-keyword">bool</span>sp      <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// sp at time of defer</span>pc      <span class="hljs-keyword">uintptr</span>fn      *funcval <span class="hljs-comment">//调用的函数</span>_panic  *_panic <span class="hljs-comment">// panic that is running defer</span>link    *_defer&#125; ...&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Notes about MySQL indexing</title>
    <link href="/2019/07/03/MySQL/MySQLIndexing/"/>
    <url>/2019/07/03/MySQL/MySQLIndexing/</url>
    
    <content type="html"><![CDATA[<p>一些注意事项</p><a id="more"></a><h2 id="主键的问题">主键的问题</h2><h3 id="复合主键和单个主键">复合主键和单个主键</h3><h4 id="复合主键">复合主键</h4><p>好处显而易见，可以依据多个列进行排序，但明显地，字符类的列相比int会比较复杂</p><h3 id="自增主键和自定义主键">自增主键和自定义主键</h3><h4 id="自增主键">自增主键</h4><p>好处：</p><ol><li>由系统生成，顺序递增，速度肯定快</li><li>int占用空间小，易排序</li></ol><p>缺点：</p><ol><li>自增主键可能不连续</li><li>水平分片架构会出问题，全局不能保证唯一</li></ol><h4 id="自定义主键">自定义主键</h4><p>好处：</p><ol><li>水平分片</li></ol><p>缺点：</p><ol><li>随机I/O，影响查找等操作</li></ol><h2 id="聚簇索引">聚簇索引</h2><ul><li><p>当表有聚簇索引的时候，它的数据行实际上存放在索引的叶子页（leaf page）上聚簇代表了数据行和相邻的键值紧凑地存储在一起</p></li><li><p>InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p></li></ul><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p><h2 id="大数据问题">大数据问题</h2><h3 id="1-一次性插入大量数据">1. 一次性插入大量数据</h3><p>MySQL 5.7 Refman官方文件给出的提示：8.2.4.1 Optimizing INSERT operation8.5.5 Bulk data loading in INNODB</p><blockquote><blockquote><p>To optimize insert speed, combine many small operations into a single large operation. Ideally, you make a single connection, send the data for many new rows at once, and delay all index updates and consistency checking until the very end.</p></blockquote></blockquote><blockquote><blockquote><p>If you are inserting many rows from the same client at the same time, use INSERT statements with multiple VALUES lists to insert several rows at a time. This is considerably faster (many times faster in some cases) than using separate single-row INSERT statements. If you are adding data to a nonempty table, you can tune the bulk_insert_buffer_size variable to make data insertion even faster. See Section 5.1.7, “Server System Variables”.</p></blockquote></blockquote><blockquote><blockquote><p>When loading a table from a text file, use LOAD DATA. This is usually 20 times faster than using INSERT statements. See Section 13.2.6, “LOAD DATA Syntax”.</p></blockquote></blockquote><blockquote><blockquote><p>Take advantage of the fact that columns have default values. Insert values explicitly only when the value to be inserted differs from the default. This reduces the parsing that MySQL must do and improves the insert speed.</p></blockquote></blockquote><h4 id="如果是从一个客户端同时插入多行">如果是从一个客户端同时插入多行</h4><ol><li>就是要合并多个插入操作成一个，如：</li></ol><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> table1(<span class="hljs-string">`id`</span>,<span class="hljs-string">`name`</span>,<span class="hljs-string">`sex`</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">"a"</span>,<span class="hljs-number">1</span>)<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> table1(<span class="hljs-string">`id`</span>,<span class="hljs-string">`name`</span>,<span class="hljs-string">`sex`</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">"b"</span>,<span class="hljs-number">1</span>)<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> table1(<span class="hljs-string">`id`</span>,<span class="hljs-string">`name`</span>,<span class="hljs-string">`sex`</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">"c"</span>,<span class="hljs-number">0</span>)</code></pre></div><p>改为</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> table1(<span class="hljs-string">`id`</span>,<span class="hljs-string">`name`</span>,<span class="hljs-string">`sex`</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">"a"</span>,<span class="hljs-number">1</span>),                                            (<span class="hljs-number">2</span>,<span class="hljs-string">"b"</span>,<span class="hljs-number">1</span>),                                            (<span class="hljs-number">3</span>,<span class="hljs-string">"c"</span>,<span class="hljs-number">0</span>);</code></pre></div><ol start="2"><li>开启 <strong>bulk_insert_buffer_size</strong> 更加加速插入</li></ol><h4 id="从文件中导入数据">从文件中导入数据</h4><p>使用 <strong>LOAD DATA</strong></p><h4 id="利用default-value">利用default value</h4><p>每当插入数据不同于default值的时候再插入，使用ignore</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">ignore</span> <span class="hljs-keyword">into</span> table1 <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>,<span class="hljs-string">'a'</span>，<span class="hljs-number">1</span>);</code></pre></div><p>甚至还区分了 InnoDB引擎和MyISAM引擎的做法：</p><h4 id="innodb：">InnoDB：</h4><ol><li>关闭autocommit，因为每次插入，InnoDB都会写log;</li><li>如果有unqiue 限制插入的列，可以暂时关闭 unique_checks;</li><li>如果有外键在列，可以暂时关闭外键约束foreign_key_checks;</li><li>插入数据的时候，如果数据能按照primary key的顺序插入，会大大加快速度（因为主键是聚簇索引）</li><li>数据有自增主键的时候，把innodb_autoinc_lock_mode从1改为2（14.6.1.4)</li></ol><h4 id="myisam">MyISAM</h4><p>//todo</p><h2 id="log">Log</h2><p>Undo日志记录某数据被修改前的值，可以用来在事务失败时进行回滚；Redo日志记录某数据块被修改后的值，可以用来恢复未写入data file的已成功事务更新的数据。</p><h2 id="查询">查询</h2><h3 id="in-查询">in 查询</h3><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> table_a <span class="hljs-keyword">where</span> A <span class="hljs-keyword">in</span> () <span class="hljs-keyword">AND</span> B <span class="hljs-keyword">in</span> ()</code></pre></div><p>其实际会先从A筛选in出来再回一次表筛选B</p><p>可以改写为</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> table_a <span class="hljs-keyword">where</span> (A,B) <span class="hljs-keyword">in</span> ((<span class="hljs-number">1.</span>..n),(<span class="hljs-number">2.</span>..m))</code></pre></div><h3 id="order-by">order by</h3><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb1 <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> idx1 <span class="hljs-keyword">limit</span> <span class="hljs-number">4</span>,<span class="hljs-number">1</span>;<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb1 <span class="hljs-keyword">force</span> <span class="hljs-keyword">index</span>(idx1) <span class="hljs-keyword">limit</span> <span class="hljs-number">4</span>,<span class="hljs-number">1</span>;</code></pre></div><p>某种情况下得到不同结果;</p><p>具体使用哪一种排序方式是优化器决定的，总的说来如下：</p><p>直接利用索引避免排序：用于有索引且回表效率高的情况下</p><p>快速排序算法：如果没有索引大量排序的情况下</p><p>堆排序算法：如果没有索引排序量不大的情况下</p><p>快排和堆排不稳定，</p><h3 id="index">Index</h3><h4 id="coveringindex-覆盖索引">coveringIndex(覆盖索引)</h4><ol><li>索引项通常比记录要小，所以MySQL访问更少的数据</li><li>索引都按值的大小顺序存储，相对于随机访问记录，需要更少的I/O</li><li>大多数据引擎能更好的缓存索引，比如MyISAM只缓存索引</li><li>覆盖索引对于InnoDB表尤其有用，因为InnoDB使用聚集索引组织数据，如果二级索引中包含查询所需的数据，就不再需要在聚集索引中查找了</li></ol><p><strong>重要!!!</strong></p><ul><li><p>select只能select在索引上的值（由定义可知道，索引保存的值即是你需要的值，否则又tm要回表查一次）</p></li><li><p>一个覆盖索必须满足查询中给定表用到的所有的列仅仅是个前提条件，这个索引还必须包含指定表上包括WHERE子句, ORDER BY, GROUP BY子句等等</p></li></ul><p>重复的index还会把覆盖索引给覆盖掉:</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment">#创建了联合的覆盖索引后</span>index idx_n_id(name,id)<span class="hljs-comment">## 再单独创建一个索引在name上</span>index idx_n(name)<span class="hljs-comment"># 会将之前的索引覆盖掉</span></code></pre></div><h3 id="唯一索引和普通索引">唯一索引和普通索引</h3><ol><li><p>唯一索引<strong>搜索</strong>满足的第一条记录会立马返回，通知检索（因为唯一性的保证）。但是这个区别并没有很大的性能区别，因为Innodb是按照页（默认16KB）读写的，读数据的时候是从B+树的根节点开始搜索，搜索的时候将整个页从硬盘加载到内存。</p></li><li><p>唯一索引在<strong>插入</strong>的时候会多做些判断，想要做这个判断就必须先把数据页读入内存。但是普通索引不需要做这个判断，就可以把需要更新的数据做判断：</p><ul><li>如果数据在内存则直接更新；</li><li>如果不在也不加载内存，而是先写入change buffer，等下次查询的时候再执行change buffer。</li></ul></li></ol><p>这样看来普通索引会相对性能好一些。</p><p>但是注意：如果业务场景是写入后立马有查询，其实还是会立马需要把数据页加载到内存，这样的情况下其实并不能带来优化IO的操作。</p><h3 id="最左匹配原则">最左匹配原则</h3><p>``sqlindex id_key1_key2_key3()</p><div class="hljs"><pre><code>针对上面的index，根据该原则，业务上各个列的使用频率和重要性应该是key1&gt;key2&gt;key3- 而且只有key1在条件内才会用到该索引- id_key1_key2_key3 等于创建了 id_key1, id_key1_key2, id_key1_key2_key3三个索引- 在该索引内使用范围查找会使其失效（in 属于精确查找）</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Something about Software Enginnering</title>
    <link href="/2019/07/02/Comcon/SoftwareEngineer/"/>
    <url>/2019/07/02/Comcon/SoftwareEngineer/</url>
    
    <content type="html"><![CDATA[<p>软件工程的通用概念！//todo留坑</p><a id="more"></a><h2 id="fan-in-fan-out">fan-in , fan-out</h2><p>扇入，扇出fan-in: 指一个模块调用多个模块fan-out:指一个模块被多个模块调用</p><p>fan-out影响I/O</p>]]></content>
    
    
    
    <tags>
      
      <tag>se</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Something about Networking</title>
    <link href="/2019/07/02/Comcon/somethingAboutTcp/"/>
    <url>/2019/07/02/Comcon/somethingAboutTcp/</url>
    
    <content type="html"><![CDATA[<p>记录了一些很基础的但经常被问到的问题</p><a id="more"></a><h3 id="1-为什么多个tcp连接会比单个tcp连接快？-tmd面试傻了-居然没答出来这个">1. 为什么多个tcp连接会比单个tcp连接快？（tmd面试傻了，居然没答出来这个）</h3><p>一开始看见，这不是显而易见的吗？？？</p><p>后来发现，其实他想听到的答案是：</p><ol><li>tcp的流量窗口rwnd(接收方),拥塞控制cwnd(发送方)如下图(盗图)：<img src="/img/tcpWindow.jpg" srcset="/img/loading.gif" alt="tcpwindow">绿色为 发送者发送，且接收者acked黄色为 发送者发送，接收者未确认（in-flight）蓝色为 可用但为发送</li></ol><p>cwnd= width（in-flight）+width（not sent）</p><p>发送速率：<strong>rate = cwnd / RTT byte/sec</strong>即发送速率在RTT（往返时延）一定的情况下，只受cwnd影响</p><ol start="2"><li>慢启动，拥塞避免</li></ol><p>tcp会进行<strong>慢启动</strong>直到丢包,每接到一个ack就会把窗口（cwnd）×2，超过ssThreshold就进行拥塞避免只增加 1/cwnd;</p><p>当出现丢包的，有以下两种状况：</p><ul><li>接收者发送给发送者的ACK丢失，会导致 timeout</li><li>发送者发送给接收者的数据丢失，发送者会收到接受者的重复ACK，如果收到三个重复的ACK，可以确认为丢包</li></ul><ol start="3"><li>路由器（多个TCP有拥塞控制）给出带宽为R，有K个连接经过最后每个连接平均分的都会是 R/K</li></ol><p>终上：</p><p>一个tcp连接很可能不能把当前路由的带宽都用完，而且连接也有重传的情况，所以多个tcp连接可以最大保证速率</p><p><strong><em>但是这个问题在HTTP/2则不是一回事了，因为其靠帧来实现有序性，而且是连接复用(同域名下)，所以多个连接反而会浪费资源</em></strong></p><h3 id="总结">总结</h3><p>回答问题，要从特么原理开始一步步推导来說，不能想当然</p><h3 id="2-各种握手挥手-我求求我自己把这些gdx记得滚瓜烂熟-每次都漏一点点">2. 各种握手挥手（我求求我自己把这些gdx记得滚瓜烂熟，每次都漏一点点）</h3><h4 id="tcp三次握手连接-three-way-handshake">TCP三次握手连接(three-way handshake)</h4><p>直接上他🐎图：<img src="/img/TCPshakeFhand.jpg" srcset="/img/loading.gif" alt="tcpconn"></p><ol><li>client发送server<br><strong>SYN=1</strong>（同步位，这种报文不能携带数据，但要<strong>消耗一个序号</strong>）自己的序号 <strong>Seq=client_w ( isn )</strong> 给 server （期间client从CLOSED到SYN-SENT状态，server从CLOSED到LISTEN状态）</li></ol><blockquote><blockquote><p>ps: <strong>isn</strong>泛指一种计算序号的算法，有一种是每4μs+1，直到2^32归零,因为2MSL的限制，所以几乎不可能重复；</p></blockquote></blockquote><ol start="2"><li>server收到报文，把确认报文段中的SYN和ACK都设为1<strong>SYN=1</strong>(同理<strong>要消耗一个序号</strong>) 和 <strong>ACK=1</strong>自己的序号 Seq=server_w, ack= client_w + 1 到client （期间client仍然是SYN-SENT状态，server从LISTEN状态到SYN-RCVD状态）</li><li>client收到确认报文后，还要给server发送确认收到。把<strong>确认ACK=1</strong>,ack=server_w+1(之前SYN消耗了序号)自己的序号Seq=client_w+1 (因为没有SYN，所以可以携带数据,<strong>但如果不携带数据则不消耗序号</strong>，这里携带了数据，所以Seq是上一次的序号+1);（client端进入established状态）</li><li>server收到确认报文后，进入established状态，全部连接完成</li></ol><h5 id="三次握手能避免啥🐔儿东西呢-为啥两次不行？">三次握手能避免啥🐔儿东西呢（为啥两次不行？）</h5><p>我们假设client给server发了个连接请求，但是请求丢失，然后client再发一个，server收到这个然后建立连接，这里面client发送了两个请求会有以下情况出现：</p><p>client发出的第一个请求没有丢，只是网络阻塞;但接下来，server收到后以为是新的一个连接，server返回一个确认报文，但client收到server确认报文会发现自己并没有建立连接请求，所以会忽视server的确认报文，也不会向server发送数据但server会<strong>一直开着连接等client的数据，白白浪费资源!</strong>（但采用三次握手的话就没得事，server端没有接到client的第三次确认，就知道client没有要建立连接）</p><h4 id="tcp四次挥手">TCP四次挥手</h4><p><img src="/img/TCPgoodbye.jpg" srcset="/img/loading.gif" alt="tcpfour"></p><ol><li><p>client 发送<strong>FIN=1</strong>（终止位，跟同步位一样都在header里面，<del>自己特喵去看</del>下面给你画一个算了,但这里注意，<strong>无论带不带数据，这厮都要消耗一个序号！</strong>）<strong>seq=client_u</strong> （这里序号是<strong>前面一个传送过的数据最后一个字节的序号+1</strong>）;(client进入FIN-WAIT-1状态)</p></li><li><p>server收到释放报文返回<strong>ACK=1</strong><strong>Seq=server_u</strong>(同理，也是前面一个传送过的数据的最后一个字节序号+1);(server进入CLOSE-WAIT状态，但实际上是个半关闭状态，server-&gt;client方向的连接保持，但client-&gt;server已经没有<strong>数据</strong>要传输了)</p></li><li><p>client收到server的确认后，进入FIN-WAIT2状态，等待server的连接释放报文</p></li><li><p>如果server没有数据要发给client了（server持续发送数据到client，也可以不发），携带报文 <strong>FIN=1</strong>， ACK=1<strong>seq=server_u2</strong>(新，可能发送了一些数据)<strong>ack=client_u+1</strong>（重复上次已发送的确认号）(server进入LAST-ACK状态)</p></li><li><p>(紧接3)client收到释放报文后，返回确认报文：ACK=1确认号<strong>ack=server_u2+1</strong>序号<strong>seq=client_u+1</strong> （前面1的FIN报文消耗了一个序号client_u）然后client进入TIME_WAIT状态，然后经过2MSL（RFC 793设为2mins，但其实应该要用更小的数值）再进入CLOSED状态client撤销相应的TCB（传输控制块）后，结束连接</p></li></ol><h5 id="为啥要等2msl">为啥要等2MSL</h5><ol><li><p>保证client发送的最后一个ACK报文能够到达server;因为这个报文可能会丢失，然后处在LAST-ACK的server收不到已发送的FIN+ACK报文的确认。正常情况下，server会重传FIN+ACK报文，client接着重传最后一个ACK报文，重新计时;但如果client不等待，发送完ACK报文直接释放连接进入CLOSED，client就没法收到server重传的FIN+ACK报文，也不会再发送一次确认报文（因为关闭了啊！），这样server重传的东西client就收不到，server也就不会正常进入CLOSED状态</p></li><li><p>防止出现 ‘已失效的连接请求报文段’(如同三次握手时间的client第一次发出的报文);client发送完最后一个ACK报文段后，经过2MSL，可以确定本连接持续时间内的所有报文段都从网络消失，这样就不会出现旧的连接报文段了</p></li></ol><h5 id="为啥连接用三次-断开要四次呢？">为啥连接用三次，断开要四次呢？</h5><ul><li>主要区别还是在连接时，server收到连接请求后可以直接返回SYN+ACK报文；</li><li>但是断开时，server收到了client的FIN报文后，可能还有数据没有传完，只能先发回一个ACK，等到最后数据都传完了才会发FIN，所以为了避免没传完数据就关闭了的情况，只能加多一次连接;如果是三次(最后一次server返回的ACK+FIN还有一堆数据合并为最后一次response)，会造成长时间阻塞，导致客户端以为上一次的FIN没有到server，然后重传;</li></ul><p>PS：server的cclosed状态要比client的要早一点MSL&gt;=TTL</p><p>连接当中如果用HTTPS，参考之前写的</p><h5 id="keepalive-timer">keepalive timer</h5><p>存在header里面的keep-alive是http协议的，可以维持长连接,HTTP/1.1开启;</p><p>2MSL是被client的一个TIME-WAIT timer设置的，实际上TCP<strong>还有</strong>另外一个keepalive timer，主要用来探测端到端的连接有没有失效linux命令</p><div class="hljs"><pre><code class="hljs s">sysctl -a | grep keepalive</code></pre></div><p>默认7200s检测一次，一次最多重传9个包,每个包间隔75s</p><p>但是因为该设置不太合理，比如检测间隔太长等,很多应用没有开启</p><h5 id="tcp-fast-open">TCP fast open</h5><p>顾名思义是一个减少连接时延的方法，实现在第二次握手就可以传输响应数据,主要就是使用SYN cookie实现具体做法：</p><ol><li><p>首轮的三次握手中，服务端接到SYN不会立即回复SYN+ACK，而是通过计算得到一个SYN Cookie,然后将这个Cookie放到TCP报文的fast open选项，然后返回，接下来就是正常的三次握手余下的流程;</p></li><li><p>接下来的握手中，客户端会将之前缓存的<strong>cookie</strong>，<strong>SYN</strong>和<strong>HTTP request</strong> 一起发给服务端，如果合法(不合法可能是过期的原因)直接返回SYN+ACK;</p></li><li><p>(重要！！！)接下来服务端就可以直接发送数据而不用等客户端的ACK了！！！</p></li><li><p>但是确保三次握手协议不变，client端最后还是会返回ACK</p></li></ol><p>linux可以通过</p><div class="hljs"><pre><code class="hljs bash">cat /proc/sys/net/ipv4/tcp_fastopen</code></pre></div><p>检查是否开启，1为client端，2为server，3为both</p><p><strong>注意一下这个功能可能被一些防火墙隔离</strong></p><h3 id="3-有哪些字段-一些字段的意义">3. 有哪些字段，一些字段的意义</h3><p>比较关键的字段</p><ul><li>明确方向源端口(2B)，目的端口(2B)</li><li>明确报文本身信息头部长度(4bit)</li><li>可靠性ack(8B)，seq号码(8B) , 窗口大小(16B),校验和(16B)</li><li>一些标志的bitACK,SYN,FIN ,RST,PSH(不放入缓存直接被程序用),…???</li><li>额外的字段kind(1B)+length(1B)+info(8B)比如有<strong>timestamp</strong>字段:kind = 8 , length = 10, info由timestamp(4B)和timestamp echo(4B)组成</li></ul><h3 id="4-一些拥塞控制优化吞吐量的算法">4. 一些拥塞控制优化吞吐量的算法</h3><h4 id="nagle">Nagle</h4><p>有一种情景是client端不断发给server端很小的包，一次1B，这样发1KB就要1K次；Nagle就是解决这种问题，具体做法</p><ul><li>第一次发1B，立即发送</li><li>后面的发送要满足<ol><li>数据要达到MSS</li><li>之前所有包ACK都收到</li></ol></li></ul><h4 id="延迟确认">延迟确认</h4><p>指的是把一段时间内ACK合并然后延迟回复,tcp要求这个时延必须小于500ms，unix一般不超过200ms但是有一些<strong>不能</strong>延迟确认</p><ul><li>接收到一个大于一个帧的报文，且需要调整窗口大小</li><li>TCP处于quick ack模式(tcp_in_quick_mode)</li><li>有乱序的包</li></ul><h4 id="byte-queue-limits-bql">Byte Queue Limits (BQL)</h4><h4 id="tcp-small-queues-tsq">TCP Small Queues (TSQ)</h4><h4 id="early-departure-time-edt">Early Departure Time (EDT)</h4><h3 id="5-其他">5. 其他</h3><h4 id="tcp-backlogs">TCP Backlogs</h4><p>针对SYN floods攻击，linux下使用了**两个队列(模型)**来缓解:</p><ul><li><p>一个是有最小metadata的SYN Backlog(未完成的连接队列);</p><p>每个这样的syn分节对应其中一项：已由某个客户发出到达服务器，而服务器正在等待完成相应的TCP三鹿握手的过程，这些套接字处于SYN_RCVD状态。</p></li><li><p>一个是监听功能的Listen SYN Backlog(已完成的连接队列);</p><p>每个已经完成的三路握手的客户对应其中的一员，这些套接字处于ESTABLISHED状态。</p></li></ul><p>如图<img src="/img/" srcset="/img/loading.gif" alt="tcpsynlog"></p><p>TCP在未完成队列接收SYN的request，当三次握手完成(established)后，就会将这个request移到已完成的连接队列的尾部;</p><p>除了两个队列模型外，TCP listen path也用无锁方式来改进???（似乎有点问题）4.7内核版本改进</p><h4 id="dns协议">DNS协议</h4><p>首先这🐔是<strong>应用层</strong>协议！！！功能主要就是<strong>把域名转换为IP地址</strong>然后，主要是在<strong>UDP</strong>上面跑，端口<strong>53</strong>长度最多是<strong>512Bytes</strong>，若过多要用 <img src="https://en.wikipedia.org/wiki/Extension_mechanisms_for_DNS" srcset="/img/loading.gif" alt="EDNS"></p><h4 id="uri-和-url-和域名">URI 和 URL 和域名</h4><p>URI（统一资源标识符） 包括 URL（统一资源定位符）和URN（统一资源名称）</p><p>URI通用模式：</p><div class="hljs"><pre><code class="hljs undefined">scheme：<span class="hljs-comment">[// <span class="hljs-comment">[user：password @]</span> host <span class="hljs-comment">[：port]</span>]</span> <span class="hljs-comment">[/]</span> path <span class="hljs-comment">[？查询]</span> <span class="hljs-comment">[#片段]</span></code></pre></div><p>URL：主要用于连接网页或部分部件，借助访问的协议（http，ftp等）来检索定位资源位置URL包含了</p><ol><li>访问资源的协议</li><li>服务器位置</li><li>端口</li><li>资源在服务器上的位置</li><li>片段标识符（就是锚点#something）</li></ol><p>域名（domain name）指的是任一主机或路由器连接在因特网上都有<strong>唯一</strong>的 <strong>层次结构的名字</strong>,只是一个<strong>逻辑概念</strong></p><h3 id="6-浏览器输入url发生了什么-个人感觉按照这个🐔来复习会比较好">6. 浏览器输入url发生了什么 （个人感觉按照这个🐔来复习会比较好）</h3><ol><li>输入URL，浏览器会解析url，这里面是通过DNS域名解析，找到url对应的服务器地址，其中可能会从HOSTS文件找</li><li>找到主机地址，就会连接主机，这里面tcp三次握手，发送HTTP请求然后封装发送的包，http包放在tcp包里，tcp包放在IP包里，层层往下，每一层会通过网管（gateway）</li><li>到了IP协议处会将其通过ARP解析出相应的在链路层的物理地址（通过路由器），在网络层和以上使用都是IP地址，以下都是硬件地址了，所以数据链路层看不见IP地址了</li><li>网络层通过物理地址找到路由器，把层层封装的包通过网桥（或桥接器等）等发送到链路层上，当前只能看见MAC帧，链路层负责开始传输数据了</li><li>物理层只是把传输数据 变成电信号真正地传到网线上</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>networking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Something about LOCK</title>
    <link href="/2019/07/01/Comcon/ReentranceLock/"/>
    <url>/2019/07/01/Comcon/ReentranceLock/</url>
    
    <content type="html"><![CDATA[<h2 id="可重入锁-reentrancelock">可重入锁（ReentranceLock）</h2><p>可以进一步加强锁的封装性，简化了代码的开发，避免死锁;拿别人的一个例子：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parentDo</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//....</span>    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">childDo</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">super</span>.parentDo();    &#125;&#125;</code></pre></div><p>如果不可重入，super.parentDo()不可以获得Parent的锁，因为这个锁已经被childDo()持有，从而使线程阻塞，造成死锁所以可以用于：</p><ol><li>递归调用</li><li>此线程调用同一对象其它synchronized或者有同步锁函数。synchronized是可重入锁</li></ol><h3 id="golang中不同">Golang中不同</h3><p>golang设计者对此做过回应<img src="https://stackoverflow.com/questions/14670979/recursive-locking-in-go#14671462" srcset="/img/loading.gif" alt="这里">go不支持可重入锁，只能通过将需要锁的操作作为函数，并以Locked为后缀命名，然后调用它们的时候用锁锁住</p><h2 id="自旋锁-spinlock">自旋锁(SpinLock)</h2><p>线程会反复检查锁变量是否可用。但由于线程此时一直保持执行，所以属于忙等待（busy-waiting），一旦获得了自旋锁，线程会一直保持该锁，直到显式释放;这里说说<strong>互斥锁</strong>，区别就是，互斥锁的调用者一方如果发现锁被拿走了，就会<strong>进入睡眠状态</strong>盗取别人例子：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpinLock</span></span>&#123;    <span class="hljs-keyword">private</span> AtomicReference&lt;Thread&gt; cas = <span class="hljs-keyword">new</span> AtomicReference&lt;Thread&gt;();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> lock&#123;        Thread cur=Thread.currentThread();        <span class="hljs-comment">//CAS</span>        <span class="hljs-comment">//第一个线程得到锁，就会跳过while循环，第二个线程会一直在while循环，直到满足CAS</span>        <span class="hljs-keyword">while</span> (!cas.compareAndSet(<span class="hljs-keyword">null</span>,cur))&#123;            <span class="hljs-comment">//Do sth...</span>        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>&#123;        Thread cur=Thread.currentThread();        cas.compareAndSet(cur,<span class="hljs-keyword">null</span>);    &#125;&#125;</code></pre></div><p>Pros:自旋锁避免上下文切换（？），只要阻塞很短时间的场景下可以使用<br>Cons:</p><ol><li>然而会导致不公平地持有锁，无法满足等待最长时间线程获得锁，会有饥饿状态出现</li><li>越来越多的线程循环等待会导致cpu越来越多</li></ol><p>可重入的自旋锁和不可重入的自旋锁</p>]]></content>
    
    
    
    <tags>
      
      <tag>LOCK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Something in gRPC</title>
    <link href="/2019/06/29/Go/gRPC/"/>
    <url>/2019/06/29/Go/gRPC/</url>
    
    <content type="html"><![CDATA[<p>常用的rpc框架，我们先从它的proto开始了解吧//todo</p><a id="more"></a><p>我们这里只讨论go语法，语言方面其他都是大同小异</p><h2 id="proto">proto</h2><p>创建proto文件 <strong>data.proto</strong></p><div class="hljs"><pre><code class="hljs go">syntax = <span class="hljs-string">"proto2"</span>;service Authenticate&#123;rpc login(toServerData) returns (ResponseFromServer)&#123;&#125;rpc home(toServerData) returns(ResponseFromServer)&#123;&#125;rpc logout(toServerData) returns(ResponseFromServer)&#123;&#125;&#125;message toServerData&#123;required <span class="hljs-keyword">int32</span> ctype = <span class="hljs-number">1</span>;required <span class="hljs-keyword">string</span> name =<span class="hljs-number">2</span>;    optional bytes httpdata=<span class="hljs-number">3</span>;&#125;message ResponseFromServer &#123;required <span class="hljs-keyword">bool</span> Success=<span class="hljs-number">1</span>;optional bytes tcpData=<span class="hljs-number">2</span>;<span class="hljs-comment">// Errcode int</span>&#125;</code></pre></div><p>用安装的protoc插件生成</p><div class="hljs"><pre><code class="hljs shell">protoc --proto_path=/mypath --go_out=plugins=grpc:. *.proto //当前在mypath路径下，用grpc模式生成proto文件</code></pre></div><p>生成 <strong>data.pb.proto</strong></p><p>-----------这些就直接参照手册理解吧-----------------<br>这里还是记录下这厮的解码方式吧，参考</p><blockquote><blockquote><p>《数据密集型系统设计》</p></blockquote></blockquote><p>protobuf的的编码其实跟 thrift的BinaryCompact编码有点相似就拿上面那个例子:</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">toServerData</span></span>&#123;<span class="hljs-keyword">required</span> <span class="hljs-built_in">int32</span> ctype = <span class="hljs-number">1</span>;<span class="hljs-keyword">required</span> <span class="hljs-built_in">string</span> name =<span class="hljs-number">2</span>;    <span class="hljs-keyword">optional</span> <span class="hljs-built_in">bytes</span> httpdata=<span class="hljs-number">3</span>;&#125;</code></pre></div><h2 id="提供的一些连接方式">提供的一些连接方式</h2><p>单向stream双向stream</p>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>To my lover</title>
    <link href="/2019/06/26/ToMyLover/"/>
    <url>/2019/06/26/ToMyLover/</url>
    
    <content type="html"><![CDATA[<p>I was looking for something until met you,So I found the whole world</p>]]></content>
    
    
    
    <tags>
      
      <tag>Love</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang Context</title>
    <link href="/2019/06/21/Go/Context/"/>
    <url>/2019/06/21/Go/Context/</url>
    
    <content type="html"><![CDATA[<p>Golang出色的协程为其增添不少色彩，而Context在协程间的协作，同步发挥了很大的作用</p><a id="more"></a><p><img src="/img/golangContextMascot.jpg" srcset="/img/loading.gif" alt="Context"></p><h2 id="作用">作用</h2><p>开头已经说道，Context主要用于在goroutine之间传递上下文信息，而这些信息包括key-value pair，cancel信号，timeout信号等http包，sql包里面都用到了context，比如http包里面，API可以由外部执行cancel操作，可以设置timeout信号来cancelhttp请求服务如果过慢，则可以用timeout进行释放资源举例：获取商品的默认库存数量等</p><p><strong><em>参考 go在今日头条的实践</em></strong></p><p>另外，之前的<img src="/Concurrency" srcset="/img/loading.gif" alt="Concurrency"> 有谈到协程之前如何同步（比如 channel和select）但如果要共享一些全局变量，或者需要同时被关闭，就可以用context来实现</p><h2 id="源码">源码</h2><p>可以参考官方blog<img src="https://blog.golang.org/context" srcset="/img/loading.gif" alt="context blog"></p><p>整体提供了：</p><table>  <tr>    <th>Name</th>    <th>Type</th>    <th>Usage</th>    <th>Comment</th>  </tr>  <tr>    <td>Context</td>    <td>Interface</td>    <td>Define four methods:<br><br>Deadline() (deadline time.Time, ok bool)<br>Done()&lt;-chan struct{}<br>Err() error<br>Value(key interface{}) interface{}</td>    <td></td>  </tr>  <tr>    <td>emptyCtx</td>    <td>struct</td>    <td>Also define interface, but it's empty</td>    <td></td>  </tr>  <tr>    <td>CancelFunc</td>    <td>func</td>    <td>cancel func</td>    <td></td>  </tr>  <tr>    <td>CancelCtx</td>    <td>struct</td>    <td>mark as cancelable</td>    <td rowspan="3">都有实现自己的方法<br><br><br>Cancel()</td>  </tr>  <tr>    <td>timerCtx</td>    <td>struct</td>    <td>canceled if timeout</td>  </tr>  <tr>    <td>valueCtx</td>    <td>struct</td>    <td>save K-V pair</td>  </tr>  <tr>    <td>Background</td>    <td>func</td>    <td>Background returns a non-nil, empty Context. It is never canceled, has no<br>values, and has no deadline. It is typically used by the main function,<br> initialization, and tests, and as the top-level Context for incoming requests.</td>    <td>返回空的context，常用做top-level context</td>  </tr>  <tr>    <td>TODO</td>    <td>func</td>    <td>TODO returns a non-nil, empty Context.<br>Code should use context.TODO when it' s unclear which Context to use or it is not yet available<br> (because the surrounding function has not yet been extended to accept a Context<br>parameter). TODO is recognized by static analysis tools that determine<br>whether Contexts are propagated correctly in a program.</td>    <td>返回空的context</td>  </tr>  <tr>    <td>WithCancel</td>    <td>func</td>    <td>Based on parent context, generate a cancelable context</td>    <td>基于父context生成可取消context<br>(自然就会调用下面的propagateCancel)</td>  </tr>  <tr>    <td>newCancelCtx</td>    <td>func</td>    <td>create a cancelable context</td>    <td>返回一个CancelCtx</td>  </tr>  <tr>    <td>propagateCancel</td>    <td>func</td>    <td>propagateCancel arranges for child to be canceled</td>    <td>向下传递context的关系</td>  </tr>  <tr>    <td>parentCancelCtx</td>    <td>func </td>    <td>parentCancelCtx follows a chain of parent references until it finds a<br><br>*cancelCtx. This function understands how each of the concrete types in this<br><br>package represents its parent.</td>    <td>找到第一个可取消的父节点</td>  </tr>  <tr>    <td>removeChild</td>    <td>func</td>    <td>remove child</td>    <td>去掉父节点的孩子节点</td>  </tr>  <tr>    <td>init</td>    <td>func</td>    <td>init this package</td>    <td></td>  </tr>  <tr>    <td>WithDeadLine</td>    <td>func</td>    <td>Create a context with deadline</td>    <td rowspan="3">同理，都是为了创建不同功能的context</td>  </tr>  <tr>    <td>WithTimeout</td>    <td>func</td>    <td></td>  </tr>  <tr>    <td>WIthValue</td>    <td>func</td>    <td></td>  </tr>  <tr>    <td></td>    <td></td>    <td></td>    <td></td>  </tr></table><p>context里面的类图：</p><p><img src="/img/go_context.png" srcset="/img/loading.gif" alt="contextClass"></p><p>如上图所示，展开</p><h3 id="interface">Interface</h3><h4 id="context">Context</h4><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span> &#123;<span class="hljs-comment">//deadline会返回 这个context应该被取消的时间， 如果ok==false，指没有deadline设置（即返回deadline的时间或者返回没有设置deadline）</span>Deadline() (deadline time.Time, ok <span class="hljs-keyword">bool</span>)    <span class="hljs-comment">//返回一个关闭的只读channel ，代表着这个context应该被cancel或者到了deadline</span>    Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;    <span class="hljs-comment">//channel Done（）关闭后，返回关闭原因</span>Err() error    <span class="hljs-comment">//获取key对应的value值</span>Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125;&#125;</code></pre></div><p>关于 <strong>Done()</strong> 需要注意的是这个是一个<strong>只读</strong> 的 <strong>channel</strong>！</p><ol><li>只有在其被关闭后，才可以从里面读出值， 而且这个值是相应类型的 <strong>零值</strong>，所以goroutine可以在其关闭后读出零值，判断后继续做后面的事情</li><li>其具有关联性，即所有用到这个context的goroutine，一旦有一方关闭了(Done())，其他的也会被关闭</li></ol><h4 id="canceler">Canceler</h4><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// A canceler is a context type that can be canceled directly. The</span><span class="hljs-comment">// implementations are *cancelCtx and *timerCtx.</span><span class="hljs-keyword">type</span> canceler <span class="hljs-keyword">interface</span> &#123;cancel(removeFromParent <span class="hljs-keyword">bool</span>, err error)Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;&#125;</code></pre></div><p>源码说的很清楚了，这个接口会被 *cancelCtx和 *timerCtx 实现</p><p>//todo 为啥 Canceler里面有 cancel()，而Context里面 没有呢,是种设计问题吧？context有一些不会用到cancel，比如emptyCtx？</p><h3 id="struct">struct</h3><h4 id="emptyctx">emptyCtx</h4><p>这个暂时略过，只要知道把这个当成一个占位符即可，有些函数可能以后会用到context，暂时把它当作一个参数传进去而已它的相关方法有background() 和 TODO()</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// An emptyCtx is never canceled, has no values, and has no deadline. It is not</span><span class="hljs-comment">// struct&#123;&#125;, since vars of this type must have distinct addresses.</span></code></pre></div><h4 id="cancelctx">cancelCtx</h4><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// A cancelCtx can be canceled. When canceled, it also cancels any children</span><span class="hljs-comment">// that implement canceler.</span><span class="hljs-keyword">type</span> cancelCtx <span class="hljs-keyword">struct</span> &#123;Contextmu       sync.Mutex            <span class="hljs-comment">// protects following fields</span>done     <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;         <span class="hljs-comment">// created lazily, closed by first cancel call</span>children <span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">// set to nil by the first cancel call</span>err      error                 <span class="hljs-comment">// set to non-nil by the first cancel call</span>&#125;</code></pre></div><p>这个cancelCtx 有实现了接口 <strong>Context</strong>我们注意到源码中说到 done是 created lazily，即这个不是初始化就会有;发现这个在其下的Done()方法里面才会初始化：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span> <span class="hljs-title">Done</span><span class="hljs-params">()</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">struct</span></span>&#123;&#125; &#123;c.mu.Lock()<span class="hljs-keyword">if</span> c.done == <span class="hljs-literal">nil</span> &#123;c.done = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<span class="hljs-comment">//这里</span>&#125;d := c.donec.mu.Unlock()<span class="hljs-keyword">return</span> d&#125;</code></pre></div><p>前面说到 这个 <strong>&lt;-chan struct{}</strong> 指的是只读 channel，在其他地方如果读取的话（还没关闭）会block住</p><p>紧接着**cancel()**方法</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// cancel closes c.done, cancels each of c's children, and, if</span><span class="hljs-comment">// removeFromParent is true, removes c from its parent's children.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span> <span class="hljs-title">cancel</span><span class="hljs-params">(removeFromParent <span class="hljs-keyword">bool</span>, err error)</span></span> &#123;<span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">"context: internal error: missing cancel error"</span>)&#125;c.mu.Lock()<span class="hljs-keyword">if</span> c.err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">//前面说道err是当timeout或者cancel的时候会添加，所以有err就一定是被取消了（var Canceled = errors.New("context canceled")）</span>c.mu.Unlock()<span class="hljs-keyword">return</span> <span class="hljs-comment">// already canceled</span>&#125;c.err = err<span class="hljs-keyword">if</span> c.done == <span class="hljs-literal">nil</span> &#123;c.done = closedchan <span class="hljs-comment">//var closedchan = make(chan struct&#123;&#125;)</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">close</span>(c.done)&#125;<span class="hljs-keyword">for</span> child := <span class="hljs-keyword">range</span> c.children &#123;<span class="hljs-comment">//loop所有的children，每个都调用cancel（）</span><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> acquiring the child's lock while holding parent's lock.//为啥要锁住呢，golang里面没有可重入锁，所以child和parent的锁都是分开的</span>child.cancel(<span class="hljs-literal">false</span>, err)&#125;c.children = <span class="hljs-literal">nil</span><span class="hljs-comment">//把children字段设为nil</span>c.mu.Unlock()<span class="hljs-keyword">if</span> removeFromParent &#123;<span class="hljs-comment">//从父context移除自己</span>removeChild(c.Context, c)&#125;&#125;</code></pre></div><p>源码注释写着</p><ol><li>cancel会关闭掉 done这个channel，还会cancel掉c的所有children</li><li>如果removeFromparent 是true，最后调用removeChild()</li></ol><h5 id="cancel-方法的流程：">Cancel（）方法的流程：</h5><ol><li>关闭c.Done() channel，然后不断地cancel它的子节点</li><li>并从父节点移除自己（removeFromParent）</li></ol><p>自然地，我们先看看removeChild()函数</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// removeChild removes a context from its parent.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeChild</span><span class="hljs-params">(parent Context, child canceler)</span></span> &#123;p, ok := parentCancelCtx(parent)<span class="hljs-comment">//拿出父context，这里是p</span><span class="hljs-keyword">if</span> !ok &#123;<span class="hljs-keyword">return</span>&#125;p.mu.Lock()<span class="hljs-keyword">if</span> p.children != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">delete</span>(p.children, child)<span class="hljs-comment">//直接从map里面删除这个child（删除自己）</span>&#125;p.mu.Unlock()&#125;</code></pre></div><p><del>PS：里面的parentCancelCtx（）后来发现问题出在 valueCtx上面，我们放在 <a href>valueCtx</a> 讲 </del></p><h5 id="withcancel-流程：">WithCancel（）流程：</h5><p>我们回到上面的<strong>cancel()</strong> 方法，输入的removeFromParent什么时候是true or false呢，全局查找后发现在**WithCancel()**里面有用到，同时这也是一个Export出去（大写）的方法，目的是创建一个可cancel的Context：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// A CancelFunc tells an operation to abandon its work.</span><span class="hljs-comment">// A CancelFunc does not wait for the work to stop.</span><span class="hljs-comment">// After the first call, subsequent calls to a CancelFunc do nothing.</span><span class="hljs-keyword">type</span> CancelFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><span class="hljs-comment">// WithCancel returns a copy of parent with a new Done channel. The returned</span><span class="hljs-comment">// context's Done channel is closed when the returned cancel function is called</span><span class="hljs-comment">// or when the parent context's Done channel is closed, whichever happens first.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Canceling this context releases resources associated with it, so code should</span><span class="hljs-comment">// call cancel as soon as the operations running in this Context complete.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithCancel</span><span class="hljs-params">(parent Context)</span> <span class="hljs-params">(ctx Context, cancel CancelFunc)</span></span> &#123;c := newCancelCtx(parent)<span class="hljs-comment">//这个就是复制parent</span>propagateCancel(parent, &amp;c)<span class="hljs-keyword">return</span> &amp;c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">true</span>, Canceled) &#125;&#125;</code></pre></div><ol><li>传入parent Context（一般是background），返回一个parentcontext的复制，这个parent contex有 <strong>新的Done channel</strong></li><li>这个新（复制）的Done channel会在两种情况被关闭（不管哪个先发生）：返回的cancel CancelFunc （复制的） 被called （注意，<strong>CancelFunc只能被调用一次，接下来的都会do nothing</strong>）parent context的 Done channel被关闭</li></ol><p><strong>那么删除前该怎么办（调用返回的cancel CancelFunc前），直接断开当前context和其parent的链接？</strong>不行，还要把当前context的children全部cancel掉：这里走到propagateCancel()函数</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// propagateCancel arranges for child to be canceled when parent is.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">propagateCancel</span><span class="hljs-params">(parent Context, child canceler)</span></span> &#123;<span class="hljs-keyword">if</span> parent.Done() == <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">//没有初始化操作，即没有调用Done()操作，所以自然不存在cancel</span><span class="hljs-keyword">return</span> <span class="hljs-comment">// parent is never canceled</span>&#125;<span class="hljs-keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;p.mu.Lock()<span class="hljs-keyword">if</span> p.err != <span class="hljs-literal">nil</span> &#123;            <span class="hljs-comment">// parent has already been canceled</span>            child.cancel(<span class="hljs-literal">false</span>, p.err)<span class="hljs-comment">//这里传入的就是false，因为父context已经被cancel掉了（父与当前child的链接断开），只需要把child和其下面的</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> p.children == <span class="hljs-literal">nil</span> &#123;p.children = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>&#123;&#125;)&#125;p.children[child] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;&#125;p.mu.Unlock()&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果没有找到parent context（它自己是空的），就新建一个goroutine监视parent context或者child context的done信号</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> &lt;-parent.Done():<span class="hljs-comment">//如果找不到父节点，这个就不会调用</span>child.cancel(<span class="hljs-literal">false</span>, parent.Err())<span class="hljs-keyword">case</span> &lt;-child.Done():<span class="hljs-comment">//可能父节点取消了，这个会重复让子节点再取消一次</span>&#125;&#125;()&#125;&#125;</code></pre></div><p>从源码知道，propagateCancel()主要目的是当parent被cancel，把child给取消;（跟<strong>cancel（）方法重叠？？？</strong>）会不断的传播传播下去，把parent的children字段全部设为空的struct</p><h4 id="parentcancelctx特殊性">parentCancelCtx特殊性</h4><p>之前说到的在这个parentCancelCtx() for循环里面，万一把当前context嵌套在一个struct里面，</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// parentCancelCtx follows a chain of parent references until it finds a</span><span class="hljs-comment">// *cancelCtx. This function understands how each of the concrete types in this</span><span class="hljs-comment">// package represents its parent.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parentCancelCtx</span><span class="hljs-params">(parent Context)</span> <span class="hljs-params">(*cancelCtx, <span class="hljs-keyword">bool</span>)</span></span> &#123;<span class="hljs-keyword">for</span> &#123;<span class="hljs-comment">//很奇怪？？？为啥要for呢？？？</span><span class="hljs-keyword">switch</span> c := parent.(<span class="hljs-keyword">type</span>) &#123;<span class="hljs-keyword">case</span> *cancelCtx:<span class="hljs-keyword">return</span> c, <span class="hljs-literal">true</span><span class="hljs-keyword">case</span> *timerCtx:<span class="hljs-keyword">return</span> &amp;c.cancelCtx, <span class="hljs-literal">true</span><span class="hljs-keyword">case</span> *valueCtx:parent = c.Context<span class="hljs-comment">//for的问题在这里</span><span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>&#125;&#125;&#125;</code></pre></div><h4 id="valuectx">valueCtx</h4><p>结构体：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// A valueCtx carries a key-value pair. It implements Value for that key and</span><span class="hljs-comment">// delegates all other calls to the embedded Context.</span><span class="hljs-keyword">type</span> valueCtx <span class="hljs-keyword">struct</span> &#123;Contextkey, val <span class="hljs-keyword">interface</span>&#123;&#125;&#125;</code></pre></div><p>一个简单的kv结构，但是一个ctx只支持一对kv，多了的话会构成一颗<strong>树型</strong>的结构</p><p>首先可以确认它是一个<strong>Context</strong> ，它的独立方法只有两个，其他都是继承context：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *valueCtx)</span> <span class="hljs-title">String</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">"%v.WithValue(%#v, %#v)"</span>, c.Context, c.key, c.val)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *valueCtx)</span> <span class="hljs-title">Value</span><span class="hljs-params">(key <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<span class="hljs-keyword">if</span> c.key == key &#123;<span class="hljs-keyword">return</span> c.val&#125;<span class="hljs-keyword">return</span> c.Context.Value(key)&#125;</code></pre></div><p>Value（）的方法是取出对应key的value，但返回值是 <strong>c.Context.Value(key)</strong>，明显是递归调用，其会一直往它的parent context查找，key是否等于输入的key，一直到终点（background）前面也说到 <strong>background=new（emptyCtx）</strong>，所以在终点调用的其实是**emptyCtx.Value()**返回的是nil值</p><p>Export出去的创建一个valueCtx的方法：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// WithValue returns a copy of parent in which the value associated with key is</span><span class="hljs-comment">// val.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Use context Values only for request-scoped data that transits processes and</span><span class="hljs-comment">// APIs, not for passing optional parameters to functions.</span><span class="hljs-comment">//这里很明白地说明了，context值是被设计为在进程间或者API间request的存储值，而不是为了传入一些可选的参数给函数</span><span class="hljs-comment">// The provided key must be comparable and should not be of type</span><span class="hljs-comment">// string or any other built-in type to avoid collisions between</span><span class="hljs-comment">// packages using context. Users of WithValue should define their own</span><span class="hljs-comment">// types for keys. </span><span class="hljs-comment">//还要注意这里，WithValue的key必须是可比较的，不能是string或者其他built-in type，目的是避免不同用的context包的冲突</span><span class="hljs-comment">//To avoid allocating when assigning to an</span><span class="hljs-comment">// interface&#123;&#125;, context keys often have concrete type</span><span class="hljs-comment">// struct&#123;&#125;. Alternatively, exported context key variables' static</span><span class="hljs-comment">// type should be a pointer or interface.</span><span class="hljs-comment">//为了避免？？？ context的key一般是有确切的类型struct，或者是exported出去的key静态类型为指针或者interface</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithValue</span><span class="hljs-params">(parent Context, key, val <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">Context</span></span> &#123;<span class="hljs-keyword">if</span> key == <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">"nil key"</span>)&#125;<span class="hljs-keyword">if</span> !reflect.TypeOf(key).Comparable() &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">"key is not comparable"</span>)&#125;<span class="hljs-keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;&#125;</code></pre></div><p>WithValue（）适用范围：<strong>只用与在request作用域内的数据，这种数据是在进程或API传输所用，而不是作为函数的parameter使用</strong></p><p>WithValue（）规定了：</p><ol><li>其key不应该是string或者其他内置的类型，主要是为了防止使用context包的其他包之间产生冲突</li><li>所以key应该是用户自己设置的，要自己覆盖Comparable（）方法才行这里给出 **Comparable()**的源码解释</li></ol><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// Methods applicable only to some types, depending on Kind.</span><span class="hljs-comment">// The methods allowed for each kind are:</span><span class="hljs-comment">//</span><span class="hljs-comment">//Int*, Uint*, Float*, Complex*: Bits</span><span class="hljs-comment">//Array: Elem, Len</span><span class="hljs-comment">//Chan: ChanDir, Elem</span><span class="hljs-comment">//Func: In, NumIn, Out, NumOut, IsVariadic.</span><span class="hljs-comment">//Map: Key, Elem</span><span class="hljs-comment">//Ptr: Elem</span><span class="hljs-comment">//Slice: Elem</span>    <span class="hljs-comment">//Struct: Field, FieldByIndex, FieldByName, FieldByNameFunc, NumField</span></code></pre></div><ol start="3"><li>为了防止赋值给interface{}，context的key经常是有具体类型的struct，此外，export出去的key的静态类型应该是指针或者interface</li></ol><h5 id="流程">流程</h5><ol><li>判断key是否为空，key的类型是否合法</li><li>返回一个有parent指针的valueCtx;所以，创建valueCtx是可以从parent开始一级一级往下创建(树)，如下图：<img src="/img/valueCtx.png" srcset="/img/loading.gif" alt="valueCtx"></li></ol><h4 id="timerctx">timerCtx</h4><p>结构体：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// A timerCtx carries a timer and a deadline. It embeds a cancelCtx to</span><span class="hljs-comment">// implement Done and Err. It implements cancel by stopping its timer then</span><span class="hljs-comment">// delegating to cancelCtx.cancel.</span><span class="hljs-keyword">type</span> timerCtx <span class="hljs-keyword">struct</span> &#123;cancelCtxtimer *time.Timer <span class="hljs-comment">// Under cancelCtx.mu.</span>deadline time.Time&#125;</code></pre></div><p>它的cancel方法</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *timerCtx)</span> <span class="hljs-title">cancel</span><span class="hljs-params">(removeFromParent <span class="hljs-keyword">bool</span>, err error)</span></span> &#123;c.cancelCtx.cancel(<span class="hljs-literal">false</span>, err)<span class="hljs-keyword">if</span> removeFromParent &#123;<span class="hljs-comment">// Remove this timerCtx from its parent cancelCtx's children.</span>removeChild(c.cancelCtx.Context, c)&#125;c.mu.Lock()<span class="hljs-keyword">if</span> c.timer != <span class="hljs-literal">nil</span> &#123;c.timer.Stop()c.timer = <span class="hljs-literal">nil</span>&#125;c.mu.Unlock()&#125;</code></pre></div><p>流程：</p><ol><li>先调用里面的cancelCtx的cancel（）方法，取消其子节点</li><li>如果要</li></ol><p>哪里用到timerCtx.cancel（）呢，我们看看创建一个timerCtx的函数：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).</span><span class="hljs-comment">//</span><span class="hljs-comment">// Canceling this context releases resources associated with it, so code should</span><span class="hljs-comment">// call cancel as soon as the operations running in this Context complete:</span><span class="hljs-comment">//</span><span class="hljs-comment">// func slowOperationWithTimeout(ctx context.Context) (Result, error) &#123;</span><span class="hljs-comment">// ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)</span><span class="hljs-comment">// defer cancel()  // releases resources if slowOperation completes before timeout elapses</span><span class="hljs-comment">// return slowOperation(ctx)</span><span class="hljs-comment">// &#125;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithTimeout</span><span class="hljs-params">(parent Context, timeout time.Duration)</span> <span class="hljs-params">(Context, CancelFunc)</span></span> &#123;<span class="hljs-keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))&#125;</code></pre></div><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// WithDeadline returns a copy of the parent context with the deadline adjusted</span><span class="hljs-comment">// to be no later than d. If the parent's deadline is already earlier than d,</span><span class="hljs-comment">// WithDeadline(parent, d) is semantically equivalent to parent. The returned</span><span class="hljs-comment">// context's Done channel is closed when the deadline expires, when the returned</span><span class="hljs-comment">// cancel function is called, or when the parent context's Done channel is</span><span class="hljs-comment">// closed, whichever happens first.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Canceling this context releases resources associated with it, so code should</span><span class="hljs-comment">// call cancel as soon as the operations running in this Context complete.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithDeadline</span><span class="hljs-params">(parent Context, d time.Time)</span> <span class="hljs-params">(Context, CancelFunc)</span></span> &#123;<span class="hljs-keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;<span class="hljs-comment">// The current deadline is already sooner than the new one.</span><span class="hljs-keyword">return</span> WithCancel(parent)&#125;c := &amp;timerCtx&#123;cancelCtx: newCancelCtx(parent),deadline:  d,&#125;propagateCancel(parent, c)dur := time.Until(d)<span class="hljs-keyword">if</span> dur &lt;= <span class="hljs-number">0</span> &#123;c.cancel(<span class="hljs-literal">true</span>, DeadlineExceeded) <span class="hljs-comment">// deadline has already passed</span><span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">true</span>, Canceled) &#125;&#125;c.mu.Lock()<span class="hljs-keyword">defer</span> c.mu.Unlock()<span class="hljs-keyword">if</span> c.err == <span class="hljs-literal">nil</span> &#123;c.timer = time.AfterFunc(dur, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;c.cancel(<span class="hljs-literal">true</span>, DeadlineExceeded)&#125;)&#125;<span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">true</span>, Canceled) &#125;&#125;</code></pre></div><p>我们发现WithTimeout和WithDeadline（）都可以创建timerCtx区别： withTimeout第二个参数是传入duration，即距离现在的时间，withDeadline第二个参数指的是绝对时间，即几时几分</p><p>withDeadline（）流程：</p><ol><li><p>检查当前的deadline，如果存在且当前deadline比传入的时间要早，那么就退化成WithCancel（）</p></li><li><p>如果不存在deadline或者传入时间较晚，把当前timerCtx加入到parent Context里面;但是注意，还要计算现在的时间是否大于了传入的时间，如果大于说明已经过了传入的deadline，直接退化成cancel（），并传入exceed错误信息：</p> <div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">var</span> DeadlineExceeded error = deadlineExceededError&#123;&#125;<span class="hljs-keyword">type</span> deadlineExceededError <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(deadlineExceededError)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span>   &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">"context deadline exceeded"</span> &#125;</code></pre></div></li><li><p>如果上述都不成立，调用time.AfterFunc()，规定时间后调用cancel()</p></li></ol><h3 id="使用例子">使用例子</h3><p>这个经典的goroutine泄漏：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">repeatGen</span><span class="hljs-params">()</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">int</span></span>&#123;    c:=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;;i++&#123;            c&lt;-i        &#125;    &#125;()    <span class="hljs-keyword">return</span> c&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">for</span> v:=<span class="hljs-keyword">range</span> repeatGen()&#123;        fmt.Println(v)        <span class="hljs-keyword">if</span> v==<span class="hljs-number">3</span>&#123;            <span class="hljs-keyword">break</span>        &#125;    &#125;&#125;</code></pre></div><p>当v==3的时候，break出来，但这时候repeatGen里面的goroutine仍然在跑，不会被终止,goroutine发生泄漏</p><p>用context改进：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">repeatGen</span><span class="hljs-params">(ctx context.Context)</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">int</span></span>&#123;    c:=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">for</span> i:<span class="hljs-number">0</span>;;i++&#123;            <span class="hljs-keyword">select</span> &#123;                <span class="hljs-keyword">case</span> &lt;-ctx.Done():<span class="hljs-comment">//等待done信号</span>                    <span class="hljs-keyword">return</span>                <span class="hljs-keyword">case</span> c&lt;-i:            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ctx,cancelFunc:=WithCancel(context.Background())    <span class="hljs-keyword">defer</span> cancelFunc()<span class="hljs-comment">//最后无论怎么样也要调用确保一定能关掉（为保万一而已，不一定要）</span>    <span class="hljs-keyword">for</span> v:=<span class="hljs-keyword">range</span> repeatGen(ctx)&#123;        fmt.Println(v)        <span class="hljs-keyword">if</span> v==<span class="hljs-number">3</span>&#123;            cancelFunc()<span class="hljs-comment">//完成直接调用cancel</span>            <span class="hljs-keyword">break</span>        &#125;    &#125;&#125;</code></pre></div><p><strong><em>参考《go语言圣经》</em></strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fmt 输出包</title>
    <link href="/2019/06/21/Go/fmt/"/>
    <url>/2019/06/21/Go/fmt/</url>
    
    <content type="html"><![CDATA[<p>留个坑----</p><a id="more"></a><p>关于这个包，其实有不少很不错的实现</p><p>比如：fmt.Output()</p><h3 id="pool">pool</h3><p>存储暂时的对象，这些对象很可能会被存储以及调用</p><p>使用sync/pool，创建了一个动态长度的buffer，可以根据需求扩展以及收缩,但是不适用于短时间生存的</p><h2 id="sprintf">Sprintf</h2><p>直接看一道题</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> yoyo <span class="hljs-keyword">struct</span>&#123;    Name <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(y *yoyo)</span> <span class="hljs-title">do</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span>&#123;    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">"%+v"</span>,y)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    p:=&amp;yoyo&#123;&#125;    p.do()&#125;</code></pre></div><p>答案是输出stack overflow</p><p>二话不说直接dlv进去看:贴图先不给，大概流程是,fmt.sprintf里面会调用doPrintf(format,a)这个函数就是loop  format里面的字符串（即我们传入的 “%+v”)遇到% ， +v这种特殊字符就停止 调用</p><div class="hljs"><pre><code class="hljs go">printArgs(arg ,verb <span class="hljs-keyword">rune</span>)</code></pre></div><p>这个函数会进行一个简单的判断，arg的类型，有些类型如果用cast (T.(type)这种模式)可以转换，则不需要使用反射，如果要用反射，即上面题目中，传入的指针y;进入 handleMethods(verb rune)</p><ol><li>判断是不是formatter？</li><li>判断这个verb的类型(v,s,x,X,q)中的一种，如果是，会继续判断传入的p.arg.(type)是否是error还是一个Stringer</li></ol><p>进入p.fmtString(v.String(),verb),其中v=p.arg.(type)实际就是最一开始传入的参数 <strong>y</strong></p><p>这时候就会发现，这个v.String()就又回到最初的yoyo.String()方法，就会造成死循环，栈溢出;</p>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Something should be noted in golang&#39;s map</title>
    <link href="/2019/06/19/Go/SortedMap/"/>
    <url>/2019/06/19/Go/SortedMap/</url>
    
    <content type="html"><![CDATA[<p>There is <strong>SortedMap</strong> or <strong>LinkedHashMap</strong> in JavaBoth can ensure the inserted order of elements, but f ** k myself, I found that Go <strong>only supports basic HashMap</strong>which means you have to do SortedMap and LinkedHashMap by yourself.</p><div class="hljs"><pre><code>                                ----From a damn interview test</code></pre></div><a id="more"></a><p>I met a problem in an interview test:</p><p>Given a file containing URLs on every line,you must record all of their occurence times, then save it into a new fileformat like:</p><div class="hljs"><pre><code>url1  2timesurl2  3timesurl3  4times</code></pre></div><p>But it should be noticed that all urls in new file have the same sequence as those in source files;</p><p>其实你要解决三个问题：</p><ol><li>url频次统计（map）</li><li>要按顺序放入新文件？？？//todo</li><li>文件太大怎么办（拆乘多个文件，进行映射，再统计，但这里又不知道怎么保证顺序？？！！难倒只有手动实现LinkedHashMap<del>红黑树</del>不一定是红黑树，但是LinkedHashMap是一定要实现的<a href="LinkedHashMap%E5%AE%9E%E7%8E%B0">这里跳到LinkedHashMap</a>）</li></ol><p>Go blog <img src="https://blog.golang.org/go-maps-in-action" srcset="/img/loading.gif" alt="map in action"> says:</p><blockquote><blockquote><blockquote><p>When iterating over a map with a range loop, the iteration order is not specified and is not guaranteed to be the same from one iteration to the next. Since the release of Go 1.0, the runtime has randomized map iteration order.</p></blockquote></blockquote></blockquote><h3 id="sortedmap">SortedMap</h3><p>Someone has already implemented itFrom Go blog  <img src="https://blog.golang.org/go-maps-in-action" srcset="/img/loading.gif" alt="map in action"></p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">"sort"</span><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span><span class="hljs-keyword">var</span> keys []<span class="hljs-keyword">int</span><span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> m &#123;<span class="hljs-comment">//extract all the damn key out</span>    keys = <span class="hljs-built_in">append</span>(keys, k)&#125;sort.Ints(keys)<span class="hljs-comment">//sort them</span><span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> keys &#123;<span class="hljs-comment">//then you can get a sorted map</span>    fmt.Println(<span class="hljs-string">"Key:"</span>, k, <span class="hljs-string">"Value:"</span>, m[k])&#125;</code></pre></div><p>If your <strong>key</strong> is not an int or string or you wanna sort it by yourself:</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">//we assume a struct is like below:</span><span class="hljs-keyword">type</span> Obj <span class="hljs-keyword">struct</span> &#123;Title    <span class="hljs-keyword">string</span>Sequence <span class="hljs-keyword">int</span>Size     <span class="hljs-keyword">int</span>&#125;<span class="hljs-comment">//</span><span class="hljs-keyword">type</span> By <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(o1, o2 *Obj)</span> <span class="hljs-title">bool</span></span><span class="hljs-comment">//ObjSorter joins a By function and a slice of Objs to be sorted.</span><span class="hljs-keyword">type</span> ObjSorter <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">//to wrap the obj and by function into this struct</span>objs []Objby   <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(o1, o2 *Obj)</span> <span class="hljs-title">bool</span></span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(by By)</span> <span class="hljs-title">Sort</span><span class="hljs-params">(objs []Obj)</span></span> &#123;os := &amp;ObjSorter&#123;objs: objs,by:   by,&#125;sort.Sort(os)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *ObjSorter)</span> <span class="hljs-title">Less</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">return</span> s.by(&amp;s.objs[i], &amp;s.objs[j])&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *ObjSorter)</span> <span class="hljs-title">Swap</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span></span> &#123;s.objs[i], s.objs[j] = s.objs[j], s.objs[i]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *ObjSorter)</span> <span class="hljs-title">Len</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(s.objs)&#125;</code></pre></div><p>Then to use it:</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SortedMap</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[Obj]<span class="hljs-keyword">int</span>)</span></span> &#123;sortByTitle := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(o1, o2 *Obj)</span> <span class="hljs-title">bool</span></span> &#123; <span class="hljs-comment">//sort by Ttitle field</span><span class="hljs-keyword">return</span> o1.Title &lt; o2.Title&#125;<span class="hljs-comment">// sortBySequence := func(o1, o2 *Obj) bool &#123; //sortBy Sequence field</span><span class="hljs-comment">// return o1.Sequence &lt; o2.Sequence</span><span class="hljs-comment">// &#125;</span>tempObjs := <span class="hljs-built_in">make</span>([]Obj, <span class="hljs-number">0</span>)<span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> m &#123;tempObjs = <span class="hljs-built_in">append</span>(tempObjs, k)&#125;By(sortByTitle).Sort(tempObjs)<span class="hljs-comment">//Sorted this</span><span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> tempObjs &#123;<span class="hljs-comment">//operate this </span>fmt.Printf(<span class="hljs-string">"key:%v,value:%v \n"</span>, k, m[k])&#125;&#125;</code></pre></div><p>To test:</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    obj1 := &amp;Obj&#123;Title: <span class="hljs-string">"4"</span>&#125;obj2 := &amp;Obj&#123;Title: <span class="hljs-string">"2"</span>&#125;obj3 := &amp;Obj&#123;Title: <span class="hljs-string">"1"</span>&#125;objs := <span class="hljs-built_in">make</span>([]*Obj, <span class="hljs-number">0</span>)objs = <span class="hljs-built_in">append</span>(objs, obj1, obj2, obj3)m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[Obj]<span class="hljs-keyword">int</span>)m[*obj1] = <span class="hljs-number">1</span>m[*obj3] = <span class="hljs-number">1</span>m[*obj2] = <span class="hljs-number">1</span>SortedMap(m)&#125;</code></pre></div><p>Result:</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-string">key:</span>&#123;<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>&#125;,<span class="hljs-string">value:</span><span class="hljs-number">1</span> <span class="hljs-string">key:</span>&#123;<span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>&#125;,<span class="hljs-string">value:</span><span class="hljs-number">1</span> <span class="hljs-string">key:</span>&#123;<span class="hljs-number">4</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>&#125;,<span class="hljs-string">value:</span><span class="hljs-number">1</span></code></pre></div><p>Above example can be found in <img src="https://golang.org/pkg/sort/" srcset="/img/loading.gif" alt="Golang slice doc examples">傻了，写到这里才发现，sortedMap有个鸡用，不符合这道题的要求啊！！！</p><h3 id="linkedhashmap">LinkedHashMap</h3><p>To just ensure <strong>inserted order</strong>:you can refer to " srcset="/img/loading.gif<img src alt="Java LinkedHashMap">//or arrayMap()</p><p><strong>But</strong>here we won’t achieve the LinkedHashMap, it’s kind of troublesome…</p><p>We do a trade-off between time and space:</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">//just create a slice to save sequence</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CalcUrls</span><span class="hljs-params">()</span></span>&#123;    sequence:=<span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>,<span class="hljs-number">0</span>)    m:=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)    <span class="hljs-comment">//.....</span>        url:=fp.ReadLine()    <span class="hljs-keyword">if</span> _,exists:=m[url];exists&#123;        m[url]++    &#125;<span class="hljs-keyword">else</span>&#123;        sequence=<span class="hljs-built_in">append</span>(sequence,url)    &#125;    <span class="hljs-comment">//....</span>    <span class="hljs-keyword">for</span> _,v:=<span class="hljs-keyword">range</span> sequence&#123;        res:=fmt.Sprintf(<span class="hljs-string">"url:%v,times:%v"</span>,v,m[v])        Writer.write(res)<span class="hljs-comment">//write into the new file</span>    &#125;        <span class="hljs-comment">//....</span>&#125;</code></pre></div><p><strong>---------------------------------新增---------------------------------------------</strong>主要是红黑树是为了能便于删除和添加，而我遇到的面试题只考虑添加，所以没必要，但是隔了一天，还是觉得不爽</p><p>自己尝试实现一下基于红黑树的map看看，就当做复习吧：</p><p>首先，红黑树也是AVL树，区别就只是颜色上的判断不同而已，所以AVL的rotate我这里略过，主要就是颜色的判断要符合</p><ol><li>每个节点是黑或者红</li><li>根节点是黑色</li><li>每个叶子节点是黑色（且为nil，添加的时候没用到，删除的时候会用）</li><li>如果一个节点是红色的，它的子节点必须是黑色的</li><li><strong>从一个节点到该节点的所有叶子节点的路径上包含相同数目的黑节点</strong> （这个一行代码可以搞定，但之后很可能会违反第4，所以要紧接着进行处理）</li></ol><h5 id="节点插入时候-检查：">节点插入时候，检查：</h5><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">//主要思路，先像AVL一样插入，之后再调整</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(brtree *BRTree)</span> <span class="hljs-title">insertNode</span><span class="hljs-params">(pnode *BRNode)</span></span> &#123;tempRoot := brtree.root<span class="hljs-keyword">var</span> temp *BRNode<span class="hljs-keyword">for</span> tempRoot != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">//已有根节点，就往下loop找到插入点</span>temp = tempRoot <span class="hljs-comment">//每次更新</span><span class="hljs-keyword">if</span> pnode.val &gt; tempRoot.val &#123;tempRoot = tempRoot.right&#125; <span class="hljs-keyword">else</span> &#123;tempRoot = tempRoot.left&#125;&#125;pnode.parent = temp <span class="hljs-comment">//找到最后，把pnode的parent指向找到的最后一个点</span><span class="hljs-keyword">if</span> temp != <span class="hljs-literal">nil</span> &#123;    <span class="hljs-comment">//不是根节点</span><span class="hljs-keyword">if</span> temp.val &lt; pnode.val &#123; <span class="hljs-comment">//判断放在左子树还是右子树</span>temp.right = pnode&#125; <span class="hljs-keyword">else</span> &#123;temp.left = pnode&#125;&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//根节点</span>brtree.root = pnode&#125;pnode.color = RED <span class="hljs-comment">//直接把这个颜色先设置为红色！！！主要为了满足：</span><span class="hljs-comment">// 从一个节点到该节点的所有叶子节点的路径上包含相同数目的黑节点（可以试想一下，最下方插入一个红色节点，因为目前红色节点的叶子节点肯定是黑色的nil，所以必会满足这个特性）</span>brtree.insertCheck(pnode) <span class="hljs-comment">//再检查，因为这个时候可能跟上面的第4点违背了，比如在红色的节点下面插一个红色的节点</span>&#125;</code></pre></div><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">//插入时进行检查</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(brtree *BRTree)</span> <span class="hljs-title">insertCheck</span><span class="hljs-params">(pnode *BRNode)</span></span> &#123;<span class="hljs-comment">//1. 该节点没有父节点，即为root（与上面insertNode插入点的检查并不重复，因为接下来会进行递归，这个属于边界条件，所以这个检查root必不可少）</span><span class="hljs-keyword">if</span> pnode.parent == <span class="hljs-literal">nil</span> &#123;brtree.root = pnodebrtree.root.color = BLACK<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">//2.父节点是黑色直接添加(不用管)，红色接着处理</span><span class="hljs-keyword">if</span> pnode.parent.color == RED &#123;<span class="hljs-comment">//2.1 父，叔叔节点不为空而且其颜色是红色 ,则将该父叔都改为黑色,将祖父改成红色</span><span class="hljs-comment">/*  10,B /     \    6,B    15,B   /   \     /  \4,R   8,R  11,R  19,R/pnode,R==&gt;父叔节点都变成黑色，祖父变成红色  10,B /     \    6,R    15,B   /   \     /  \4,B   8,B  11,R  19,R             /  pnode,R==&gt;递归，从祖父（6）开始，因为此时父节点属于根节点，是黑色，所以完成           10,B /     \    6,R    15,B   /   \     /  \4,B   8,B  11,R  19,R             /  pnode,R*/</span><span class="hljs-keyword">if</span> pnode.getUncle() != <span class="hljs-literal">nil</span> &amp;&amp; pnode.getUncle().color == RED &#123;pnode.parent.color = BLACKpnode.getUncle().color = BLACKpnode.getGrandParent().color = REDbrtree.insertCheck(pnode.getGrandParent()) <span class="hljs-comment">//对该树上的节点递归上去处理</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//2.2 父节点为红色，叔叔节点不存在或者是黑色</span>isLeft := pnode == pnode.parent.leftisParentLeft := pnode.parent == pnode.getGrandParent().left<span class="hljs-keyword">if</span> isLeft &amp;&amp; isParentLeft &#123;<span class="hljs-comment">//2.2.1 是左子树，其父节点也是左子树</span><span class="hljs-comment">/*       ...  /        8,B    /  \   7,R   /nil  /pnode,R*/</span><span class="hljs-comment">//=》</span><span class="hljs-comment">/*         /     7,B         /   \     pnode,R  8,R               \             /nil*/</span>pnode.parent.color = BLACKpnode.getGrandParent().color = REDbrtree.rotateRight(pnode.getGrandParent())&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> !isLeft &amp;&amp; !isParentLeft &#123;<span class="hljs-comment">//2.2.2 不是左子树，父亲也不是左子树</span><span class="hljs-comment">/*  7,B      /  \2,B/nil   8,R           \           10,pnode*/</span>pnode.parent.color = BLACKpnode.getGrandParent().color = REDbrtree.rotateLeft(pnode.getGrandParent())&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> isLeft &amp;&amp; !isParentLeft &#123;<span class="hljs-comment">//2.2.3 是左子树，但父亲不是左子树</span><span class="hljs-comment">/*8,B    /  \6,B/nil   10,R        /      pnode，R*/</span><span class="hljs-comment">/*pnode,R    /  \6,B/nil  8,B            \            10,R*/</span>brtree.rotateRight(pnode.parent)<span class="hljs-comment">//实际上变成了2.2.2</span>brtree.rotateLeft(pnode.parent) <span class="hljs-comment">//pnode现在在原先pnode的父节点位置</span>pnode.color = BLACKpnode.left.color = REDpnode.right.color = RED&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> !isLeft &amp;&amp; isParentLeft &#123;<span class="hljs-comment">//2.2.4不是左子树，但父亲是左子树</span><span class="hljs-comment">/* \        8,B    /  \   7,R   10,B/nil      \      pnode，R*/</span><span class="hljs-comment">//==&gt;</span><span class="hljs-comment">/* 8，B    /    \  pnode,R  10,B/nil  /7,R*/</span><span class="hljs-comment">/* pnode，R    /    \   8,B   10,B/nil  /7,R*/</span>brtree.rotateLeft(pnode.parent)<span class="hljs-comment">//实际上变成了2.2.1</span>brtree.rotateRight(pnode.parent)pnode.color = BLACKpnode.left.color = REDpnode.right.color = RED&#125;&#125;&#125;&#125;</code></pre></div><h5 id="节点的删除">节点的删除</h5><p>删除节点的时候也分几种情况先把它当作普通二叉查找树处理：</p><ol><li>删除的节点没有子节点，直接删除</li><li>被删除节点只有一个孩子，删除这个节点，并用其孩子代替这个节点</li><li>被删除节点有两个孩子：找出后继节点，用后继节点内容复制给该节点，删除后继节点，再将后继节点删除;就可以考虑后继节点了，被删除的节点（刚刚的后继节点）有两个非空子节点情况下，它的后继节点不可能两个子节点不是空的，意思就是后继节点只有一个或零个儿子，就可以按前面的1,2进行处理</li></ol><p>接着就是按照红黑树的颜色规则来改变和旋转了//todo我实在写不动了</p><div class="hljs"><pre><code class="hljs go"></code></pre></div><p>那么把红黑树放在map上呢：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">//todo</span></code></pre></div><h4 id="linkedhashmap实现">LinkedHashMap实现</h4><p>真正的实现，先讲一下：</p><ol><li>定义数据结构node，这个是链表上的每个节点，应该有prev,next,key，val这些</li><li>定义整个map，应该是整个链表lmap，应该有指向头部，尾部的指针，map[key]node,length,</li></ol><p><strong>---------------------------------end-----------------------------------------------</strong>The above code may use O(2n) space, but time complexity reduce to O(n)<strong>!!!Everything seems done!!!</strong></p><p>So what if we use a <strong>large file?</strong></p><h3 id="large-file">Large File</h3><p>Solution: Split the large file into several files, it depends on your MEM:针对大文件，其实普通的思想就是&quot;分而治之&quot;，更多可以参考MapReduce</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HashFile</span><span class="hljs-params">(url <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span>&#123;<span class="hljs-comment">//pass a url</span>    seed:=<span class="hljs-number">131</span>    hash:=<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> _,v:=<span class="hljs-keyword">range</span> url&#123;        hash=hash*seed+v    &#125;    <span class="hljs-keyword">return</span> hash &amp; <span class="hljs-number">0x7FFFFFFF</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//........</span>    <span class="hljs-comment">//url:=fp.ReadLine()</span>    pos:=HashFile(url)    file:=pos%<span class="hljs-number">10</span><span class="hljs-comment">//we assume that it split into 10 files</span>    bufio.newWriter(file+<span class="hljs-string">".txt"</span>)    Writer.Write(file+<span class="hljs-string">".txt"</span>)<span class="hljs-comment">//write it into specific file</span>    <span class="hljs-comment">//........</span>    urls:=<span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>,<span class="hljs-number">0</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++&#123;        urlPlusTimes:=LoopEachFile(files)<span class="hljs-comment">//calculate each files' urls</span>        urls=<span class="hljs-built_in">append</span>(urls,urlPlusTimes...)<span class="hljs-comment">// Here comes to the question??? how to ensure sequence???</span>    &#125;&#125;</code></pre></div><h3 id="最终解决办法">最终解决办法</h3><p>几天了，想不出来啊</p><ol><li>主要是拆开多个文件的话，如果每一条记录都是unqiue的，map也要O（n）复杂度，内存会爆</li></ol><p>//todo</p><h3 id="addition">Addition</h3><h4 id="unsafe">unsafe</h4><p>map in golang is <strong>not thread-safe</strong>;So it involves with concurrency situation, you must add <strong>sync.Mutex</strong> or <strong>sync.RWMutex</strong>About that, can refer to <img src="/Concurrency" srcset="/img/loading.gif" alt="my previous blog"></p>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang Mux</title>
    <link href="/2019/06/08/Go/GolangMux/"/>
    <url>/2019/06/08/Go/GolangMux/</url>
    
    <content type="html"><![CDATA[<p>开始做笔记…(之前面试被怼了)</p><a id="more"></a><h2 id="路由匹配原理-regexp-in-router">路由匹配原理(Regexp in Router)</h2><p>First, let’s go through its *** usage ***:</p><div class="hljs"><pre><code class="hljs go">router:=mux.router()router.HandlerFunc(<span class="hljs-string">"/api/v&#123;version&#125;/&#123;category&#125;"</span>,handler)</code></pre></div><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">//then in handler:</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handler</span><span class="hljs-params">(w http.ResponseWriter,r *http.request)</span></span>&#123;    vars:=mux.Vars(r)<span class="hljs-comment">//Get the variables!</span>    <span class="hljs-comment">//...</span>&#125;</code></pre></div><p>Let’s cut it into two parts:</p><h3 id="handlerfunc-path-handler">HandlerFunc(path,handler)</h3><div class="hljs"><pre><code class="hljs golang"><span class="hljs-comment">// HandleFunc registers a new route with a matcher for the URL path.</span><span class="hljs-comment">// See Route.Path() and Route.HandlerFunc().</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Router)</span> <span class="hljs-title">HandleFunc</span><span class="hljs-params">(path <span class="hljs-keyword">string</span>, f <span class="hljs-keyword">func</span>(http.ResponseWriter,    *http.Request)</span>) *<span class="hljs-title">Route</span></span> &#123;    <span class="hljs-keyword">return</span> r.NewRoute().Path(path).HandlerFunc(f)&#125;</code></pre></div><p>then let’s see  *** Route.Path(path) *** :</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// Path -----------------------------------------------------------------------</span><span class="hljs-comment">// Path adds a matcher for the URL path.</span><span class="hljs-comment">// It accepts a template with zero or more URL variables enclosed by &#123;&#125;. The</span><span class="hljs-comment">// template must start with a "/".</span><span class="hljs-comment">// Variables can define an optional regexp pattern to be matched:</span><span class="hljs-comment">//</span><span class="hljs-comment">// - &#123;name&#125; matches anything until the next slash.</span><span class="hljs-comment">//</span><span class="hljs-comment">// - &#123;name:pattern&#125; matches the given regexp pattern.</span><span class="hljs-comment">//</span><span class="hljs-comment">// For example:</span><span class="hljs-comment">//</span><span class="hljs-comment">//     r := mux.NewRouter()</span><span class="hljs-comment">//     r.Path("/products/").Handler(ProductsHandler)</span><span class="hljs-comment">//     r.Path("/products/&#123;key&#125;").Handler(ProductsHandler)</span><span class="hljs-comment">//     r.Path("/articles/&#123;category&#125;/&#123;id:[0-9]+&#125;").</span><span class="hljs-comment">//       Handler(ArticleHandler)</span><span class="hljs-comment">//</span><span class="hljs-comment">// Variable names must be unique in a given route. They can be retrieved</span><span class="hljs-comment">// calling mux.Vars(request).</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Route)</span> <span class="hljs-title">Path</span><span class="hljs-params">(tpl <span class="hljs-keyword">string</span>)</span> *<span class="hljs-title">Route</span></span> &#123;<span class="hljs-comment">//根据传入的url增加正则匹配</span>r.err = r.addRegexpMatcher(tpl, regexpTypePath)<span class="hljs-keyword">return</span> r&#125;</code></pre></div><p>In *** r.err = r.addRegexpMatcher(tpl, regexpTypePath) ***the *** regexpTypePath=0 *** means this is for matching Path instead of Host/Port/Prefix/Query</p><p>Continue, Go into method *** addRegexpMatcher() ***:</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// addRegexpMatcher adds a host or path matcher and builder to a route.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Route)</span> <span class="hljs-title">addRegexpMatcher</span><span class="hljs-params">(tpl <span class="hljs-keyword">string</span>, typ regexpType)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">if</span> r.err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> r.err&#125;<span class="hljs-keyword">if</span> typ == regexpTypePath || typ == regexpTypePrefix &#123;<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(tpl) &gt; <span class="hljs-number">0</span> &amp;&amp; tpl[<span class="hljs-number">0</span>] != <span class="hljs-string">'/'</span> &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"mux: path must start with a slash, got %q"</span>, tpl)&#125;<span class="hljs-keyword">if</span> r.regexp.path != <span class="hljs-literal">nil</span> &#123;tpl = strings.TrimRight(r.regexp.path.template, <span class="hljs-string">"/"</span>) + tpl&#125;&#125;rr, err := newRouteRegexp(tpl, typ, routeRegexpOptions&#123;<span class="hljs-comment">// 核心部分</span>strictSlash:    r.strictSlash,useEncodedPath: r.useEncodedPath,&#125;)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;<span class="hljs-keyword">for</span> _, q := <span class="hljs-keyword">range</span> r.regexp.queries &#123;<span class="hljs-keyword">if</span> err = uniqueVars(rr.varsN, q.varsN); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;&#125;<span class="hljs-keyword">if</span> typ == regexpTypeHost &#123;<span class="hljs-keyword">if</span> r.regexp.path != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">if</span> err = uniqueVars(rr.varsN, r.regexp.path.varsN); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;&#125;r.regexp.host = rr&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> r.regexp.host != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">if</span> err = uniqueVars(rr.varsN, r.regexp.host.varsN); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;&#125;<span class="hljs-keyword">if</span> typ == regexpTypeQuery &#123;r.regexp.queries = <span class="hljs-built_in">append</span>(r.regexp.queries, rr)&#125; <span class="hljs-keyword">else</span> &#123;r.regexp.path = rr&#125;&#125;r.addMatcher(rr)<span class="hljs-comment">//这里会把当前matcher加入matcher slice</span><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre></div><p>We will find that we only enter the first *** if *** block (from line 4 - line 11):Getinto the *** newRouteRegexp() ***</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// newRouteRegexp parses a route template and returns a routeRegexp,</span><span class="hljs-comment">// used to match a host, a path or a query string.</span><span class="hljs-comment">//</span><span class="hljs-comment">// It will extract named variables, assemble a regexp to be matched, create</span><span class="hljs-comment">// a "reverse" template to build URLs and compile regexps to validate variable</span><span class="hljs-comment">// values used in URL building.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Previously we accepted only Python-like identifiers for variable</span><span class="hljs-comment">// names ([a-zA-Z_][a-zA-Z0-9_]*), but currently the only restriction is that</span><span class="hljs-comment">// name and pattern can't be empty, and names can't contain a colon.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newRouteRegexp</span><span class="hljs-params">(tpl <span class="hljs-keyword">string</span>, typ regexpType, options routeRegexpOptions)</span> <span class="hljs-params">(*routeRegexp, error)</span></span> &#123;    <span class="hljs-comment">//....</span>    <span class="hljs-keyword">return</span> ......&#125;</code></pre></div><p>I will roughly split the above code into serveral parts as below:</p><h4 id="procedure">Procedure :</h4><ol><li>根据括号筛选变量 (braceIndices)It will check the all *** {variable} *** in Path and save them into a slice:</li></ol><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// braceIndices returns the first level curly brace indices from a string.</span><span class="hljs-comment">// It returns an error in case of unbalanced braces.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">braceIndices</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">([]<span class="hljs-keyword">int</span>, error)</span></span> &#123;<span class="hljs-keyword">var</span> level, idx <span class="hljs-keyword">int</span><span class="hljs-keyword">var</span> idxs []<span class="hljs-keyword">int</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<span class="hljs-keyword">switch</span> s[i] &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">'&#123;'</span>:<span class="hljs-keyword">if</span> level++; level == <span class="hljs-number">1</span> &#123;idx = i&#125;<span class="hljs-keyword">case</span> <span class="hljs-string">'&#125;'</span>:<span class="hljs-keyword">if</span> level--; level == <span class="hljs-number">0</span> &#123;idxs = <span class="hljs-built_in">append</span>(idxs, idx, i+<span class="hljs-number">1</span>)<span class="hljs-comment">//注意：这里只是存了variable开始和结尾的index，而不是string</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> level &lt; <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">"mux: unbalanced braces in %q"</span>, s)&#125;&#125;&#125;<span class="hljs-keyword">if</span> level != <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">"mux: unbalanced braces in %q"</span>, s)&#125;<span class="hljs-keyword">return</span> idxs, <span class="hljs-literal">nil</span>&#125;</code></pre></div><p>====&gt;</p><ol start="2"><li>移除斜杠 (Remove endSlash)</li></ol><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">if</span> has Suffix():    tpl = tpl[:<span class="hljs-built_in">len</span>(tpl)<span class="hljs-number">-1</span>]<span class="hljs-comment">//remove end slash</span></code></pre></div><p>====&gt;</p><ol start="3"><li>traverse idxs(variables)</li></ol><div class="hljs"><pre><code class="hljs go">varsN := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>, <span class="hljs-built_in">len</span>(idxs)/<span class="hljs-number">2</span>)<span class="hljs-comment">//多少个变量</span>varsR := <span class="hljs-built_in">make</span>([]*regexp.Regexp, <span class="hljs-built_in">len</span>(idxs)/<span class="hljs-number">2</span>)<span class="hljs-comment">//多少个变量的匹配</span>pattern := bytes.NewBufferString(<span class="hljs-string">""</span>)pattern.WriteByte(<span class="hljs-string">'^'</span>)reverse := bytes.NewBufferString(<span class="hljs-string">""</span>)<span class="hljs-keyword">var</span> end <span class="hljs-keyword">int</span><span class="hljs-keyword">var</span> err error<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(idxs); i += <span class="hljs-number">2</span> &#123;<span class="hljs-comment">//因为之前说过idxs里面是index,+=2实际是遍历下一个变量</span>    <span class="hljs-comment">// Set all values we are interested in.</span>    raw := tpl[end:idxs[i]]<span class="hljs-comment">//括号之前的string</span>    end = idxs[i+<span class="hljs-number">1</span>]<span class="hljs-comment">//指的是closed bracket</span>    parts := strings.SplitN(tpl[idxs[i]+<span class="hljs-number">1</span>:end<span class="hljs-number">-1</span>], <span class="hljs-string">":"</span>, <span class="hljs-number">2</span>)<span class="hljs-comment">//把变量给弄出来,不过可能有&#123;name:pattern&#125;这种情况，所以要分割开</span>    name := parts[<span class="hljs-number">0</span>]    patt := defaultPattern <span class="hljs-comment">//defaultPattern是 [^/]+,即匹配‘/’多次</span>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) == <span class="hljs-number">2</span> &#123;        patt = parts[<span class="hljs-number">1</span>]<span class="hljs-comment">//如果有检测到：，就用后面的正则</span>    &#125;    <span class="hljs-comment">// Name or pattern can't be empty.</span>    <span class="hljs-keyword">if</span> name == <span class="hljs-string">""</span> || patt == <span class="hljs-string">""</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">"mux: missing name or pattern in %q"</span>,            tpl[idxs[i]:end])    &#125;    <span class="hljs-comment">// Build the regexp pattern.</span>    fmt.Fprintf(pattern, <span class="hljs-string">"%s(?P&lt;%s&gt;%s)"</span>, regexp.QuoteMeta(raw), varGroupName(i/<span class="hljs-number">2</span>), patt)    <span class="hljs-comment">// Build the reverse template.</span>    fmt.Fprintf(reverse, <span class="hljs-string">"%s%%s"</span>, raw)    <span class="hljs-comment">// Append variable name and compiled pattern.</span>    varsN[i/<span class="hljs-number">2</span>] = name<span class="hljs-comment">//！！！！这个就是变量的存储位置</span>    varsR[i/<span class="hljs-number">2</span>], err = regexp.Compile(fmt.Sprintf(<span class="hljs-string">"^%s$"</span>, patt))    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err    &#125;&#125;</code></pre></div><p>返回后回到 *<em>func (r <em>Route) addRegexpMatcher(tpl string, typ regexpType) error</em></em> func，这个函数最后会把match加入matchers里面</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// addMatcher adds a matcher to the route.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Route)</span> <span class="hljs-title">addMatcher</span><span class="hljs-params">(m matcher)</span> *<span class="hljs-title">Route</span></span> &#123;<span class="hljs-keyword">if</span> r.err == <span class="hljs-literal">nil</span> &#123;r.matchers = <span class="hljs-built_in">append</span>(r.matchers, m)&#125;<span class="hljs-keyword">return</span> r&#125;</code></pre></div><ol start="4"><li></li></ol><h3 id="vars">Vars()</h3><p>The place used by mux to save variables called *** context *** (上下文)And we have to talk about the *** context in ‘net/http’ ***:</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">//这个是mux里面的context</span><span class="hljs-comment">// ----------------------------------------------------------------------------</span><span class="hljs-comment">// Context </span><span class="hljs-comment">// ----------------------------------------------------------------------------</span><span class="hljs-comment">// RouteMatch stores information about a matched route.</span><span class="hljs-keyword">type</span> RouteMatch <span class="hljs-keyword">struct</span> &#123;Route   *RouteHandler http.HandlerVars    <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span><span class="hljs-comment">// MatchErr is set to appropriate matching error</span><span class="hljs-comment">// It is set to ErrMethodMismatch if there is a mismatch in</span><span class="hljs-comment">// the request method and route method</span>MatchErr error&#125;<span class="hljs-keyword">type</span> contextKey <span class="hljs-keyword">int</span><span class="hljs-keyword">const</span> (varsKey contextKey = <span class="hljs-literal">iota</span>routeKey)<span class="hljs-comment">// Vars returns the route variables for the current request, if any.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Vars</span><span class="hljs-params">(r *http.Request)</span> <span class="hljs-title">map</span>[<span class="hljs-title">string</span>]<span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">if</span> rv := contextGet(r, varsKey); rv != <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">//这里会从request的context里面获取key-value pair，然后转换成map</span><span class="hljs-keyword">return</span> rv.(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>)&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre></div><p>Then go into *** contextGet(r,varsKey) ***:</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">//"mux"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">contextGet</span><span class="hljs-params">(r *http.Request, key <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<span class="hljs-keyword">return</span> r.Context().Value(key)<span class="hljs-comment">//发现用的是net/http里面的context</span>&#125;</code></pre></div><p>Context struct in *** “net/http” ***可以参考自己写的一个<a href="/Context.html">context</a></p><p>一切到最后，handleFunc()会调用ServeHTTP（w,req），里面就会把RouteMatch的vars导出，放入http包里的context里</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// ServeHTTP dispatches the handler registered in the matched route.</span><span class="hljs-comment">//</span><span class="hljs-comment">// When there is a match, the route variables can be retrieved calling</span><span class="hljs-comment">// mux.Vars(request).</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Router)</span> <span class="hljs-title">ServeHTTP</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;<span class="hljs-keyword">if</span> !r.skipClean &#123;path := req.URL.Path<span class="hljs-keyword">if</span> r.useEncodedPath &#123;path = req.URL.EscapedPath()&#125;<span class="hljs-comment">// Clean path to canonical form and redirect.</span><span class="hljs-keyword">if</span> p := cleanPath(path); p != path &#123;<span class="hljs-comment">// Added 3 lines (Philip Schlump) - It was dropping the query string and #whatever from query.</span><span class="hljs-comment">// This matches with fix in go 1.2 r.c. 4 for same problem.  Go Issue:</span><span class="hljs-comment">// http://code.google.com/p/go/issues/detail?id=5252</span>url := *req.URLurl.Path = pp = url.String()w.Header().Set(<span class="hljs-string">"Location"</span>, p)w.WriteHeader(http.StatusMovedPermanently)<span class="hljs-keyword">return</span>&#125;&#125;<span class="hljs-keyword">var</span> match RouteMatch<span class="hljs-keyword">var</span> handler http.Handler<span class="hljs-keyword">if</span> r.Match(req, &amp;match) &#123;handler = match.Handlerreq = setVars(req, match.Vars)<span class="hljs-comment">//这里，设置vars</span>req = setCurrentRoute(req, match.Route)&#125;<span class="hljs-keyword">if</span> handler == <span class="hljs-literal">nil</span> &amp;&amp; match.MatchErr == ErrMethodMismatch &#123;handler = methodNotAllowedHandler()&#125;<span class="hljs-keyword">if</span> handler == <span class="hljs-literal">nil</span> &#123;handler = http.NotFoundHandler()&#125;handler.ServeHTTP(w, req)&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Something about authentication and authorization</title>
    <link href="/2019/06/05/Comcon/LoginSecurity/"/>
    <url>/2019/06/05/Comcon/LoginSecurity/</url>
    
    <content type="html"><![CDATA[<p>Wat the hack is <a href="https://tools.ietf.org/html/rfc6749" target="_blank" rel="noopener">Oauth2</a>, <a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener">JWT</a>, <a href="https://tools.ietf.org/html/rfc2818" target="_blank" rel="noopener">HTTPS</a>??? Followings are my notes:</p><a id="more"></a><h2 id="oauth2">Oauth2</h2><h3 id="流程">流程</h3><p>主要流程如图：<img src="/img/OauthProcess.png" srcset="/img/loading.gif" alt="OauthProcess" title="Process"></p><h3 id="四种验证方法">四种验证方法</h3><p><img src="/img/Oauth4Methods.png" srcset="/img/loading.gif" alt="Oauth4method" title="four ways of identification"></p><h2 id="jwt">JWT</h2><p>主要流程(盗图)：<img src="/img/JWT.png" srcset="/img/loading.gif" alt="jwt"></p><h3 id="主要格式">主要格式</h3><div class="hljs"><pre><code>header.payload.signature</code></pre></div><p>header结构：</p><div class="hljs"><pre><code class="hljs undefined">&#123;    <span class="hljs-attr">"typ"</span>: <span class="hljs-string">"JWT"</span>,    <span class="hljs-attr">"alg"</span>: <span class="hljs-string">"HS256"</span>&#125;</code></pre></div><p>payload 用于携带你希望向服务端传递的信息。你既可以往里添加官方字段（这里的“字段” (field) 也可以被称作“声明” claims）例如iss(Issuer签发者)，aud（接受jwt的一方），jti（jwt唯一身份标识，主要作为一次性token）, sub(Subject面向的用户), exp(Expiration time)</p><p>也可以塞入自定义的字段，比如 userId:</p><div class="hljs"><pre><code class="hljs undefined">&#123;    <span class="hljs-attr">"userId"</span>: <span class="hljs-string">"yjqweqw0019-aq"</span><span class="hljs-comment">//但一般不要敏感信息，因为会被看见</span>&#125;</code></pre></div><p>Signature结构</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-title">secret</span>=<span class="hljs-string">"mhh12121"</span>//存在服务器上的密钥<span class="hljs-class"><span class="hljs-keyword">data</span> = base64( <span class="hljs-title">header</span> ) + “.” + base64( <span class="hljs-title">payload</span> )</span><span class="hljs-title">signature</span> = <span class="hljs-type">Hash</span>( <span class="hljs-class"><span class="hljs-keyword">data</span>, secret )//这里我们用<span class="hljs-type">HMACSHA256</span></span></code></pre></div><p>假设我们的header 和paylaod如下</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-comment">//header</span>&#123;    <span class="hljs-string">"typ"</span>: <span class="hljs-string">"JWT"</span>,    <span class="hljs-string">"alg"</span>: <span class="hljs-string">"HS256"</span>&#125;<span class="hljs-comment">//payload</span>&#123;    <span class="hljs-string">"userId"</span>: <span class="hljs-string">"yjqweqw0019-aq"</span>&#125;<span class="hljs-comment">//服务器上的secret</span>secret=<span class="hljs-string">"mhh12121"</span></code></pre></div><p>可以通过这个网站<img src="https://jwt.io/" srcset="/img/loading.gif" alt="jwtio">验证你的signature准确性</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-comment">//我们的signature应该是这个</span>eyJhbGciOiJIUzI<span class="hljs-number">1</span><span class="hljs-symbol">NiIsInR5</span>cCI<span class="hljs-number">6</span>IkpX<span class="hljs-attr">VCJ9</span>.eyJ<span class="hljs-number">1</span>c<span class="hljs-number">2</span>VySWQiOiJ<span class="hljs-number">5</span>a<span class="hljs-symbol">nF3</span>ZXF<span class="hljs-number">3</span>MDAxOS<span class="hljs-number">1</span>hcSJ<span class="hljs-number">9.7</span>jRvE_F<span class="hljs-number">8</span>lriMHlTZPJulRPg_V<span class="hljs-number">66</span>I<span class="hljs-number">6</span>r-f<span class="hljs-number">7</span>caMuI<span class="hljs-number">82</span>u<span class="hljs-number">1</span>o</code></pre></div><h2 id="tls-https-http-tls-tls1-2-ssl3-3">TLS (HTTPS=HTTP+TLS，TLS1.2=SSL3.3)</h2><p>TLS (Transport layer security) mainly works in Application Layer. TLS is the 3rd edition of SSL(Secure Socket Layer) so that it can work on any application over TCP.</p><p>It provides securty over serverl aspects:</p><ol><li>encryption(加密性)：指提交的数据不被获得</li><li>data Integerity(数据完整性)：指提交的的订单不被修改</li><li>Port Identification (端点鉴别，包括服务端和客户端)：指提交和接收的两边能互相确认身份</li></ol><p>至于流程验证，为了方便了解，我们先简化SSL：</p><p>举例用Bob和Alice</p><h4 id="第一步：">第一步：</h4><h5 id="握手">握手</h5><p>一、 因为这是在TCP之上，所以先进行TCP链接,Bob发起链接，Alice接收，这里略过</p><p>二、 要验证Alice是真正的Alice：1. Bob会发送一个 SSL 验证报文，,下图是 <strong>SSL hello</strong>报文2. Alice 则用她的 <strong>证书</strong>进行回应，证书中包含了她的公钥3. Bob收到证书，因为 证书被 <strong>CA</strong> 证实过了，所以Bob会知道Alice的真实性4. 如果证书是真的，Bob会产生一个 <strong>主密钥（MS）</strong> 该密钥只用于这个SSL会话</p><p>三、 双方生成共同的密钥：1. Bob会用 Alice的公钥加密这个 <strong>主密钥MS</strong> 生成 <strong>加密的主密钥(EMS)</strong>2. Bob发送 <strong>EMS</strong> 给Alice3. Alice收到 <strong>EMS</strong> 并用自己的 <strong>私钥</strong> 解开得到 <strong>密钥（MS）</strong>，这样双方都有一个共同的<strong>密钥</strong></p><h4 id="第二步：">第二步：</h4><h5 id="密钥导出">密钥导出</h5><p>现在双方有一个共同的密钥，已经可以用作通信，但前面说到，要保证3点加密性，数据完整性，端点鉴别而且对于Alice和Bob每个人来说，这些都用不同的密钥才会更安全</p><p>为此，可以让Alice和Bob各生成4个密钥</p><ol><li>E<sub>B</sub> 指Bob发送到Alice的数据的会话加密密钥</li><li>M<sub>B</sub> 指Bob发送到Alice的数据的会话MAC密钥</li><li>E<sub>A</sub> 指Alice发送到Bob的数据的会话加密密钥</li><li>M<sub>A</sub> 指Alice发送到Bob的数据的会话MAC密钥</li></ol><p>每人通过MS生成4个密钥，其中两个用于加密数据，另外两个用于验证数据完整性</p><h4 id="第三步">第三步</h4><h5 id="数据传输">数据传输</h5><p>但在数据传输中，经过TCP链接后，开始发送数据，一次发送了加密的数据，但另一个用于验证数据完整性的MAC去哪里了呢？我们希望一次性就可以把加密数据和验证完整性的MAC都发送出去（即一次发送即可满足加密性和完整性）</p><p>为了解决这个问题，SSL将数据流分割成 <a href="#SSL-%E8%AE%B0%E5%BD%95">记录</a> ，对每一个记录附加一个MAC用于完整性检查，然后加密 <strong>记录+MAC</strong> ：比如，从Bob发送开始， 产生这个MAC， Bob将数据连同密钥M<sub>B</sub>放入一个hash函数，再用自己CA会话加密密钥 <strong>E<sub>B</sub></strong>,最后再传入TCP</p><p>然而，数据完整性仍然得不到保证，万一有中间人能抓取Bob发送的两个报文段，颠倒它们的顺序，调整TCP报文段的序号(seq)，将两个次序颠倒的报文段发送给Alice，假设TCP报文段刚好封装一个记录（流式传输，所以不保证只含一个），Alice会这样做：</p><ol><li>Alice端运行的TCP认为一切正常，传递这两个记录给SSL子层</li><li>SSL解密这两个记录</li><li>SSL会用每个记录中的MAC来验证完整性</li><li>SSL将解密的两条记录的字节流传给应用层，但实际上因为颠倒了报文，次序不正确。</li></ol><p>解决如上问题，主要就要解决TCP的序号问题，所以就可以自己使用一个<strong>序号计数器</strong>：Bob维护一个序号计数器，这个计数器不在记录中，而在MAC的计算中：即</p><blockquote><blockquote><p>MAC=Hash(数据 + MAC密钥M<sub>B</sub> + 当前序号)</p></blockquote></blockquote><p>这样一来，以上颠倒了两个报文段的顺序，Alice解码发现顺序不对，就不会处理这两个报文</p><h3 id="ssl-记录">SSL 记录</h3><p>该记录如下图所示：<img src="/img/SSL.png" srcset="/img/loading.gif" alt="SSL记录格式"></p><p>主要由类型字段，版本字段，长度字段，数据字段和MAC构成，但其前三个字段是不加密的类型字段：指出是握手报文还是有数据的报文，还被用于关闭SSL连接上（后面说到）</p><h3 id="连接关闭时注意的问题">连接关闭时注意的问题</h3><p>一般来讲，关闭连接就会由Client端，即Bob发起TCP FIN报文请求断开，但这个易遭到截断攻击（truncation attack)：如果中间人过早地发送TCP FIN报文，Server端（Alice）会认为已经收到所有Bob的数据。</p><p>解决方案：SSL记录中的<strong>类型字段</strong>指明这个记录是否用于关闭连接。这里还要注意，虽然这个字段是明文，但接收方仍然可以用记录的MAC对它进行鉴别</p><p>***参考 《计算机网络自顶向下》 ***</p><h3 id="https-一般是443端口">HTTPS（一般是443端口）</h3><p>CA证书包含了：</p><ol><li>序号和过期时间</li><li>姓名</li><li>所有者公钥</li><li>域名</li><li>签发机构</li></ol><p>流程如图<img src="/img/HTTPS.png" srcset="/img/loading.gif" alt="https"></p><h4 id="问题：">问题：</h4><ol><li>那么每次client端生成的key放在哪里呢？</li></ol><p>改变环境变量SSLKEYLOGFILE，浏览器会从以下地址记录生成的对称密钥（linux）</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">SSLKEYLOGFILE</span>=~/tls/key.log</code></pre></div><ol start="2"><li>被劫持咋办？可以从图上的序号开始谈：</li><li>首先3处，可能 <strong>有中间人拦截server端传去client端的请求吗，然后篡改证书？</strong>如果中间人模拟一个自签名证书：浏览器会把这个自签名证书和系统证书匹配，匹配不上，会失败<br>如果中间人假冒颁发机构颁发证书：因为没有颁发机构的私钥，所以证书指纹不能对上，也会失败</li></ol><p>所以，唯一破解就是用户自己安装了一个未知证书，这样系统会认为中间人证书是信任的</p><ol start="2"><li>接着6 处，即是被拦截，中间人没有server的私钥，无法解开</li></ol><p>防止看不懂，还是新增一副图吧（盗图）：<img src="/img/CA.jpeg" srcset="/img/loading.gif" alt="CA"></p><ol start="3"><li>加密都用了啥？</li></ol><p>而下面client<strong>步骤4</strong>则用的是<strong>对称加密</strong>传输的数据，再用<strong>非对称加密</strong> 加密 这个<strong>经过对称加密的数据</strong>（太绕）</p><h2 id="tls1-3">TLS1.3</h2><p>对比TLS1.2，TLS1.3在速度上有了很大的进步,注意到之前TLS1.2在建立连接时用了4次RTT，即4次握手，但是TLS1.3缩减到了2次</p><h3 id="做的修改">做的修改</h3><h4 id="速度加快">速度加快</h4><h4 id="加密算法删减">加密算法删减</h4>]]></content>
    
    
    
    <tags>
      
      <tag>security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Concurrency Problem</title>
    <link href="/2019/06/05/Go/Concurrency/"/>
    <url>/2019/06/05/Go/Concurrency/</url>
    
    <content type="html"><![CDATA[<p>其实里面只涉及部分concurrency问题，一些<strong>实用例子</strong>，比较浅显，只是暂时做个笔记，仍然有大部分问题需要继续深入，保持持续更新</p><a id="more"></a><h2 id="1-channel">1. Channel</h2><p>1.1 互斥</p><p>要先明白一句话</p><blockquote><blockquote><p>Share memory by communication, do not communicate by sharing memory通过通信来分享内存，而不是靠分享内存来通信</p></blockquote></blockquote><p>这句话应该见过无数遍了，但这就是golang channel的核心思想</p><p>作为channel，顾名思义，就像一个管道一样，主要就是控制数据流向（DataFlow），从而可以控制多个协程间的协作，达到互斥，同步等目的</p><p>1.2 当把channel当作传入参数的时候要先确定一下箭头方向</p><p>chan&lt;-string：指的是可以入可以出的channel</p><p>&lt;-chan string：指的是receive-only channnel</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">//gobyexample 例子</span><span class="hljs-comment">// This `ping` function only accepts a channel for sending</span><span class="hljs-comment">// values. It would be a compile-time error to try to</span><span class="hljs-comment">// receive on this channel.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ping</span><span class="hljs-params">(pings <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">string</span>, msg <span class="hljs-keyword">string</span>)</span></span> &#123;    pings &lt;- msg&#125;<span class="hljs-comment">// The `pong` function accepts one channel for receives</span><span class="hljs-comment">// (`pings`) and a second for sends (`pongs`).</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pong</span><span class="hljs-params">(pings &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, pongs <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">string</span>)</span></span> &#123;    msg := &lt;-pings    pongs &lt;- msg&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    pings := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, <span class="hljs-number">1</span>)    pongs := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, <span class="hljs-number">1</span>)    ping(pings, <span class="hljs-string">"passed message"</span>)    pong(pings, pongs)    fmt.Println(&lt;-pongs)&#125;</code></pre></div><h3 id="channel部分源码解析：">Channel部分源码解析：</h3><p>应用上，我们经常用作两个goroutine通信，一个写入，一个读出</p><p>这里可以有无缓冲的channel，和有缓冲的channel，</p><p>无缓冲的写入就<strong>必须</strong>要(立即!!!通常写入会放入到一个goroutine中，且该goroutine要在这之前就入队列)读出，否则立即阻塞（阻塞在写入的地方），读出后也会阻塞（阻塞读出）</p><p>有缓冲的在空的时候会阻塞读出，满之后会阻塞写入</p><p>在调用方（其实可以在任何地方close，但是一般在写入方close才符合设计规范）close掉channel，第二个参数会返回false；</p><p>如果里面仍然有值，可以读出，但是写入会引发panic</p><div class="hljs"><pre><code class="hljs go">x,ok:=&lt;-channel1<span class="hljs-keyword">if</span> !ok&#123;<span class="hljs-comment">//channel1已经被关掉</span>&#125;</code></pre></div><p>基本数据结构:</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hchan <span class="hljs-keyword">struct</span> &#123;qcount   <span class="hljs-keyword">uint</span>           <span class="hljs-comment">// total data in the queue</span>dataqsiz <span class="hljs-keyword">uint</span>           <span class="hljs-comment">// size of the circular queue</span>buf      unsafe.Pointer <span class="hljs-comment">// points to an array of dataqsiz elements</span>elemsize <span class="hljs-keyword">uint16</span>closed   <span class="hljs-keyword">uint32</span>elemtype *_type <span class="hljs-comment">// element type</span>sendx    <span class="hljs-keyword">uint</span>   <span class="hljs-comment">// send index</span>recvx    <span class="hljs-keyword">uint</span>   <span class="hljs-comment">// receive index</span>recvq    waitq  <span class="hljs-comment">// list of recv waiters</span>sendq    waitq  <span class="hljs-comment">// list of send waiters</span><span class="hljs-comment">// lock protects all fields in hchan, as well as several</span><span class="hljs-comment">// fields in sudogs blocked on this channel.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Do not change another G's status while holding this lock</span><span class="hljs-comment">// (in particular, do not ready a G), as this can deadlock</span><span class="hljs-comment">// with stack shrinking.</span>lock mutex&#125;</code></pre></div><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// sudog represents a g in a wait list, such as for sending/receiving</span><span class="hljs-comment">// on a channel.</span><span class="hljs-comment">//</span><span class="hljs-comment">// sudog is necessary because the g ↔ synchronization object relation</span><span class="hljs-comment">// is many-to-many. A g can be on many wait lists, so there may be</span><span class="hljs-comment">// many sudogs for one g; and many gs may be waiting on the same</span><span class="hljs-comment">// synchronization object, so there may be many sudogs for one object.</span><span class="hljs-comment">//</span><span class="hljs-comment">// sudogs are allocated from a special pool. Use acquireSudog and</span><span class="hljs-comment">// releaseSudog to allocate and free them.</span><span class="hljs-keyword">type</span> sudog <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">// The following fields are protected by the hchan.lock of the</span><span class="hljs-comment">// channel this sudog is blocking on. shrinkstack depends on</span><span class="hljs-comment">// this for sudogs involved in channel ops.</span>g *g<span class="hljs-comment">// isSelect indicates g is participating in a select, so</span><span class="hljs-comment">// g.selectDone must be CAS'd to win the wake-up race.</span>isSelect <span class="hljs-keyword">bool</span>next     *sudogprev     *sudogelem     unsafe.Pointer <span class="hljs-comment">// data element (may point to stack)</span><span class="hljs-comment">// The following fields are never accessed concurrently.</span><span class="hljs-comment">// For channels, waitlink is only accessed by g.</span><span class="hljs-comment">// For semaphores, all fields (including the ones above)</span><span class="hljs-comment">// are only accessed when holding a semaRoot lock.</span>acquiretime <span class="hljs-keyword">int64</span>releasetime <span class="hljs-keyword">int64</span>ticket      <span class="hljs-keyword">uint32</span>parent      *sudog <span class="hljs-comment">// semaRoot binary tree</span>waitlink    *sudog <span class="hljs-comment">// g.waiting list or semaRoot</span>waittail    *sudog <span class="hljs-comment">// semaRoot</span>c           *hchan <span class="hljs-comment">// channel</span>&#125;</code></pre></div><h3 id="happens-before问题">Happens-before问题</h3><p>在<a href="https://golang.org/ref/mem" target="_blank" rel="noopener">goMemory</a>里面有提到这个happens-before问题,其实就是指令重排(特么终于解决我的疑问了)channel的一些问题：</p><ol><li>带缓冲的channel的写操作在其相应的读操作之前</li><li>不带缓冲的channel发生在其相应的写操作之前</li><li>如果你关闭channel，之后才会读其channel最后的返回值0(这个其实在Context里面发现过！)</li></ol><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">var</span> temp=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<span class="hljs-comment">//不带缓冲</span><span class="hljs-keyword">var</span> a=<span class="hljs-string">"123"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;    fmt.Println(<span class="hljs-string">"a:"</span>,a)<span class="hljs-comment">//1 </span>    &lt;-temp<span class="hljs-comment">// 2</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">go</span> foo()    temp&lt;<span class="hljs-number">-1</span><span class="hljs-comment">//3</span>    fmt.Println(<span class="hljs-string">"a main:"</span>,a)<span class="hljs-comment">//4</span>&#125;</code></pre></div><p>输出</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">a:</span> <span class="hljs-number">123</span><span class="hljs-attr">a main:</span> <span class="hljs-number">123</span></code></pre></div><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">var</span> temp=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>,<span class="hljs-number">10</span>)<span class="hljs-comment">//带缓冲</span><span class="hljs-keyword">var</span> a=<span class="hljs-string">"123"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;    fmt.Println(<span class="hljs-string">"a:"</span>,a)<span class="hljs-comment">//1 </span>    temp&lt;<span class="hljs-number">-1</span><span class="hljs-comment">// 2</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">go</span> foo()    &lt;-temp<span class="hljs-comment">//3,可能先发生</span>    fmt.Println(<span class="hljs-string">"a main:"</span>,a)<span class="hljs-comment">//4</span>&#125;</code></pre></div><p>不能保证1, 2 和 3 的发生顺序，就很有可能只输出</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">a main:</span> <span class="hljs-number">123</span></code></pre></div><blockquote><blockquote><p>The kth receive on a channel with capacity C happens before the k+Cth send from that channel completes.一个容量为C的channel接到的第k个值会发生在 第K+C个值发出完成 之前</p></blockquote></blockquote><p>用一个官方例子：下面这个例子限制了每时每刻最多有三个work在工作</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">var</span> limit = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">3</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> _, w := <span class="hljs-keyword">range</span> work &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w <span class="hljs-keyword">func</span>()</span>)</span> &#123;limit &lt;- <span class="hljs-number">1</span>w()&lt;-limit&#125;(w)&#125;<span class="hljs-keyword">select</span>&#123;&#125;&#125;</code></pre></div><h2 id="2-mutex互斥量">2. Mutex互斥量</h2><h3 id="01互斥量">01互斥量</h3><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">var</span> sema=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;,<span class="hljs-number">1</span>)</code></pre></div><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">//每次使用前</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Deposit</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>)</span></span>&#123;    sema&lt;-<span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<span class="hljs-comment">//锁住，往里面加一个</span>    balance+=amount    &lt;-sema<span class="hljs-comment">//释放</span>&#125;</code></pre></div><h3 id="sync-mutex-互斥量">Sync.Mutex 互斥量</h3><p>注意： golang的锁都不是可重入锁(ReentranLock),参考一下Java的 <a href="../Java-Concurrency.html">可重入锁</a></p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mu Sync.Mutex<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Deposit</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>)</span></span> &#123;mu.Lock()balance = balance + amountmu.Unlock()&#125;<span class="hljs-comment">// func Withdraw() int &#123;</span><span class="hljs-comment">// return &lt;-balances</span><span class="hljs-comment">// &#125;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Balance</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;    mu.Lock()    <span class="hljs-keyword">defer</span> mu.Unlockb := balance<span class="hljs-keyword">return</span> b&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Withdraw</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;    mu.Lock()    <span class="hljs-keyword">defer</span> mu.Unlock()Deposit(-amount)<span class="hljs-comment">//这里，重用了mu的锁，但是，golang不支持重入锁，所以这里会进行阻塞</span><span class="hljs-keyword">if</span> Balance() &lt; <span class="hljs-number">0</span> &#123;Deposit(amount)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre></div><h3 id="rwmutex-读写互斥量">* RWMutex 读写互斥量</h3><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mu Sync.RWMutex</code></pre></div><p><strong>写操作 Lock(), UnLock()</strong></p><p><strong>读操作 RLock(), RUnlock()</strong></p><p>读锁即是 同一时间允许多个读的协程，但只允许一个写的协程</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">//重写Balance()</span><span class="hljs-keyword">var</span> mu Sync.RWMutex<span class="hljs-keyword">var</span> balance <span class="hljs-keyword">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Balance</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span>&#123;    mu.RLock()    <span class="hljs-keyword">defer</span> mu.RUnlock()    b:=balance    <span class="hljs-keyword">return</span> b&#125;</code></pre></div><h2 id="3-sync-waitgroup-等待组-java-countdownlatch">3.Sync.WaitGroup 等待组 (Java CountDownLatch)</h2><h3 id="普通使用">普通使用</h3><p>Sync.WaitGroup有三个methods:</p><ol><li>Add(delta int):将你要等待的协程加入，delta即加入的数量</li><li>Done() : 代表当前协程完成</li><li>Wait() : 等待所有协程完成(调用Done())，完成后即返回，否则一直阻塞</li></ol><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">//举个例子：</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">(number <span class="hljs-keyword">int</span>)</span></span>&#123;    <span class="hljs-keyword">var</span> wg Sync.WaitGroup    wg.Add(number)<span class="hljs-comment">//要同步的协程数</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;number;i++&#123;        <span class="hljs-keyword">go</span> doSth(&amp;wg,i)    &#125;    begin:=Time.Now()    wg.Wait()<span class="hljs-comment">//完成后继续往下跑</span>    end:=Time.Now()<span class="hljs-comment">//这里还可以这样进行批量测试</span>    dur:=Time.Duration(end-begin)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSth</span><span class="hljs-params">(wg *Sync.WaitGroup,num <span class="hljs-keyword">int</span>)</span></span>&#123;    fmt.Println(num)    wg.Done()<span class="hljs-comment">//完成就Done</span>&#125;</code></pre></div><h3 id="分析">分析</h3><p>首先看下其结构：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// A WaitGroup waits for a collection of goroutines to finish.</span><span class="hljs-comment">// The main goroutine calls Add to set the number of</span><span class="hljs-comment">// goroutines to wait for. Then each of the goroutines</span><span class="hljs-comment">// runs and calls Done when finished. At the same time,</span><span class="hljs-comment">// Wait can be used to block until all goroutines have finished.</span><span class="hljs-comment">//</span><span class="hljs-comment">// A WaitGroup must not be copied after first use.</span><span class="hljs-keyword">type</span> WaitGroup <span class="hljs-keyword">struct</span> &#123;noCopy noCopy<span class="hljs-comment">// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.</span><span class="hljs-comment">// 64-bit atomic operations require 64-bit alignment, but 32-bit</span><span class="hljs-comment">// compilers do not ensure it. So we allocate 12 bytes and then use</span><span class="hljs-comment">// the aligned 8 bytes in them as state, and the other 4 as storage</span><span class="hljs-comment">// for the sema.</span>state1 [<span class="hljs-number">3</span>]<span class="hljs-keyword">uint32</span>&#125;</code></pre></div><ul><li>带有nocopy，即使用时只可以传指针</li><li>state1是一个3个uint32元素的数组，高32位</li></ul><h2 id="4-sync-once-单例-不知道怎么翻译">4. Sync.Once 单例（不知道怎么翻译。。。）</h2><p>顾名思义，就是只运行一次的意思，很显然适合单例模式需要注意的是，Once只有一个MethodDo（func(){}）: Do方法只接受 *** 无参无返回值的函数 ***</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">var</span> once Sync.Once    doOnce:=<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;        fmt.Println(<span class="hljs-string">"do ONCE!"</span>)    &#125;    done:=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++&#123;        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;            once.Do(doOnce)<span class="hljs-comment">//最终只输出一行 do ONCE！</span>            done&lt;-<span class="hljs-literal">true</span>        &#125;()    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++&#123;        &lt;-done    &#125;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Something about Slice in Go</title>
    <link href="/2019/06/05/Go/Slice/"/>
    <url>/2019/06/05/Go/Slice/</url>
    
    <content type="html"><![CDATA[<p>Golang’s Slice is kinda diffrent===&gt;</p><a id="more"></a><p>当前版本go 1.13<img src="../../img/golangusergroups.png" srcset="/img/loading.gif" alt="group"></p><p>Related article [Slice]<a href="https://blog.golang.org/slices" target="_blank" rel="noopener">https://blog.golang.org/slices</a></p><p>讨论到一种数据结构，我们很自然就从以下：</p><ul><li>结构体本身</li><li>初始化(constructor)</li><li>使用详情（包含各种数据增删改等情况）</li><li>销毁(deconstructor)</li></ul><h2 id="1-结构体">1. 结构体</h2><p>slice其实是一个结构体，并不是简单的数组或者链表</p> <div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">//actually its not visible to programmer</span><span class="hljs-comment">//我自己臆想出来的,但可以从src/runtime/slice.go找出,或者走这个链接：https://golang.org/src/runtime/slice.go</span><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span>&#123;    length <span class="hljs-keyword">int</span> <span class="hljs-comment">//length</span>    pointer <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">//point to first element, the type depends on the element</span>    Capacity <span class="hljs-keyword">int</span><span class="hljs-comment">//max容量</span>&#125;</code></pre></div><p>实际上是这样的:</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span>&#123;    array unsafe.Pointer    <span class="hljs-built_in">len</span> <span class="hljs-keyword">int</span>    <span class="hljs-built_in">cap</span> <span class="hljs-keyword">int</span>&#125;</code></pre></div><p>来到这里你可能会想到，好像一个对象耶，那么这玩意儿传入func里面是不是传指针进去呢？（即里面的修改会影响到origianl？）答案是不会</p><p>Example:</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SubtractOneFromLength</span><span class="hljs-params">(slice []<span class="hljs-keyword">byte</span>)</span> []<span class="hljs-title">byte</span></span> &#123;    slice = slice[<span class="hljs-number">0</span> : <span class="hljs-built_in">len</span>(slice)<span class="hljs-number">-1</span>]    <span class="hljs-keyword">return</span> slice&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    fmt.Println(<span class="hljs-string">"Before: len(slice) ="</span>, <span class="hljs-built_in">len</span>(slice))    newSlice := SubtractOneFromLength(slice)<span class="hljs-comment">//you haven't passed the slice's header into it</span>    fmt.Println(<span class="hljs-string">"After:  len(slice) ="</span>, <span class="hljs-built_in">len</span>(slice))    fmt.Println(<span class="hljs-string">"After:  len(newSlice) ="</span>, <span class="hljs-built_in">len</span>(newSlice))&#125;</code></pre></div><p>You <strong>Must</strong> do sth like:</p><div class="hljs"><pre><code class="hljs go">newSlice := SubtractOneFromLength(&amp;slice)<span class="hljs-comment">//Like this will work!</span></code></pre></div><h2 id="2-初始化">2. 初始化</h2><div class="hljs"><pre><code class="hljs golang"><span class="hljs-comment">//顶层</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeslice64</span><span class="hljs-params">(et *_type, len64, cap64 <span class="hljs-keyword">int64</span>)</span> <span class="hljs-title">unsafe</span>.<span class="hljs-title">Pointer</span></span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeslice</span><span class="hljs-params">(et *_type, <span class="hljs-built_in">len</span>, <span class="hljs-built_in">cap</span> <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">unsafe</span>.<span class="hljs-title">Pointer</span></span>&#123;&#125;</code></pre></div><p>以上函数会先进行一个<strong>溢出判断</strong> （todo，这里涉及到编译器平台问题），如果cap设定太大会panic:cap out of range</p><p>然后便会开始分配空间，这里用的是runtime/malloc.go里面的mallocgc方法:</p><ol><li>小对象会从每个<strong>P(GPM模型中process)中的cache</strong>的可用队列中拿到空间</li><li>大对象(&gt;32KB)则会从全局<strong>堆</strong>中拿到空间</li></ol><p>详情可以看下<a href="./gc.md">之前的那篇笔记gc</a></p><h2 id="3-enlarge-capcity">3. Enlarge Capcity</h2><p>你可以理解slice是动态列表，到达某个值后很自然就会扩容，扩容的大小文档里面也写了，小于1024长度是直接 <strong>×2</strong>，或者是超过了1024的只会库容1.25倍（也不一定奥，可以接着看）：</p><div class="hljs"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">growslice</span><span class="hljs-params">(et *_type, old slice, <span class="hljs-built_in">cap</span> <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">slice</span></span> &#123;<span class="hljs-comment">// et 指的是？？？？， old是老的slice，cap是申请的容量</span>    <span class="hljs-comment">//前面是一些判断racecodition以及调试，防止cap设置不合理的判断</span>    ........    <span class="hljs-comment">//-------------这里开始计算扩容数量-----------------</span>    newcap := old.<span class="hljs-built_in">cap</span>    doublecap := newcap + newcap    <span class="hljs-keyword">if</span> <span class="hljs-built_in">cap</span> &gt; doublecap &#123;<span class="hljs-comment">//申请容量 &gt; 2 * 旧的容量</span>        newcap = <span class="hljs-built_in">cap</span>    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> old.<span class="hljs-built_in">len</span> &lt; <span class="hljs-number">1024</span> &#123;<span class="hljs-comment">//老容量 &lt; 1024，直接扩成旧的两倍</span>            newcap = doublecap        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// Check 0 &lt; newcap to detect overflow</span>            <span class="hljs-comment">// and prevent an infinite loop.</span>            <span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="hljs-built_in">cap</span> &#123;<span class="hljs-comment">//好像看见有文章說是1.25倍，但实际并不是，可以往下继续看capmen变量</span>                newcap += newcap / <span class="hljs-number">4</span>            &#125;            <span class="hljs-comment">// Set newcap to the requested cap when</span>            <span class="hljs-comment">// the newcap calculation overflowed.</span>            <span class="hljs-keyword">if</span> newcap &lt;= <span class="hljs-number">0</span> &#123;<span class="hljs-comment">//溢出的话就使之等于申请的容量</span>                newcap = <span class="hljs-built_in">cap</span>            &#125;        &#125;    &#125;</code></pre></div><p>但是，那些只针对于没有定义 *** cap *** 字段的slice，万一规定了，像</p><div class="hljs"><pre><code class="hljs go">slice := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>)</code></pre></div><p>上限就是15了，如果强行append。。。。。。*** 也没关系! ***，只是这个时候会进行扩容，然后,原slice的地址（即第一个元素的地址）会进行改变</p><div class="hljs"><pre><code class="hljs go">slice := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)slice[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>slice=<span class="hljs-built_in">append</span>(slice,<span class="hljs-number">3</span>)fmt.Println(&amp;slice[<span class="hljs-number">0</span>])<span class="hljs-comment">//0x414020</span>slice=<span class="hljs-built_in">append</span>(slice,<span class="hljs-number">4</span>)fmt.Println(&amp;slice[<span class="hljs-number">0</span>])<span class="hljs-comment">//0x414040</span></code></pre></div><p>同样，<strong><em>这里有另外几个坑</em></strong>：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">//example in docs</span>    slice := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>)    fmt.Printf(<span class="hljs-string">"len: %d, cap: %d\n"</span>, <span class="hljs-built_in">len</span>(slice), <span class="hljs-built_in">cap</span>(slice))<span class="hljs-comment">//15</span>    newSlice := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(slice), <span class="hljs-number">2</span>*<span class="hljs-built_in">cap</span>(slice))    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> slice &#123;        newSlice[i] = slice[i]    &#125;    slice = newSlice    fmt.Printf(<span class="hljs-string">"len: %d, cap: %d\n"</span>, <span class="hljs-built_in">len</span>(slice), <span class="hljs-built_in">cap</span>(slice))<span class="hljs-comment">//30</span></code></pre></div><ol><li>究竟是哪个slice</li></ol><p>简单的 = 号其实属于一种浅复制</p><div class="hljs"><pre><code class="hljs go">a:=<span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)a[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>a[<span class="hljs-number">1</span>]=<span class="hljs-number">2</span>a[<span class="hljs-number">2</span>]=<span class="hljs-number">3</span>b:=<span class="hljs-built_in">append</span>(a,<span class="hljs-number">4</span>)c:=<span class="hljs-built_in">append</span>(a,<span class="hljs-number">100</span>)fmt.Println(&amp;a[<span class="hljs-number">0</span>], &amp;b[<span class="hljs-number">0</span>], &amp;c[<span class="hljs-number">0</span>]) <span class="hljs-comment">//0xc0000125c0 0xc0000125c0 0xc0000125c0</span><span class="hljs-comment">//  可以看到这里其实用的是同一个slice</span>fmt.Println(a, b, c)<span class="hljs-comment">//[1 2 3] [1 2 3 100] [1 2 3 100]</span>c[<span class="hljs-number">0</span>] = <span class="hljs-number">101</span>fmt.Println(a, b, c)<span class="hljs-comment">//[101 2 3] [101 2 3 100] [101 2 3 100]</span></code></pre></div><ol start="2"><li>值传递？引用传递？</li></ol><p>首先明确，slice是一种struct,struct本身就是值传递</p><div class="hljs"><pre><code class="hljs go">y:=[]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;add(y)<span class="hljs-comment">//你可能这样子推论：go里面都是值传递==&gt;所以这里面的改动不会影响到y。可惜，这是错的</span>fmt.Println(y)<span class="hljs-comment">//&#123;1,1,1&#125;  ///wtf？？？？？</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(y []<span class="hljs-keyword">int</span>)</span></span>&#123;    <span class="hljs-comment">//这个就不会改变，因为这个v只是值的拷贝</span>    <span class="hljs-comment">// for _,v:=range y&#123; </span>    <span class="hljs-comment">//     v++</span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-comment">//但这个会被改变</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-keyword">range</span> y&#123;        y[i]++    &#125;&#125;</code></pre></div><h5 id="注意：">注意：</h5><p>其实上面已经提到，slice是一个struct，传入的时候如果仅仅是修改一下元素的内容，是不会对其头部地址进行改变，所以，传入修改其值是可以的;</p><p>但是，做一些比如append之类的操作，这样会使整个slice发生变化，<strong>其头部指针指向一个新的slice</strong>，所以原来的slice就不会被改变</p><p>针对以上问题的答案也有了：</p><ol><li><p>因为a,b,c的头指针地址都一样，所以其实它们都指向同一个slice，所以后面对任意一个进行改变，都会覆盖其他的改变;</p></li><li><p>slice作为参数传递进去，其实可以改变其中的元素，在不重新分配内存的情况下会影响到自身。但如果需要（保险为先），必须从返回值或传指针进行修改;</p></li></ol><h3 id="但是-扩容其实没有那么简单-我注意到growslice下面还要一段源码"><strong>但是，扩容其实没有那么简单，我注意到growslice下面还要一段源码！</strong></h3><h3 id="扩容growslice">扩容growslice</h3><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">growslice</span><span class="hljs-params">(et *_type, old slice, <span class="hljs-built_in">cap</span> <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">slice</span></span> &#123;<span class="hljs-comment">// et 是_type指针，详情可以看type文章， old是老的slice，cap是申请的容量</span><span class="hljs-comment">//新的slice的length会设为旧的slice的length</span>    ........    <span class="hljs-comment">//-------------以上计算扩容数量结束--------------------</span>    newcap := old.<span class="hljs-built_in">cap</span>doublecap := newcap + newcap<span class="hljs-keyword">if</span> <span class="hljs-built_in">cap</span> &gt; doublecap &#123;newcap = <span class="hljs-built_in">cap</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> old.<span class="hljs-built_in">len</span> &lt; <span class="hljs-number">1024</span> &#123;            newcap = doublecap            <span class="hljs-comment">//长度小于1024，新cap直接= len*2</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// Check 0 &lt; newcap to detect overflow</span>            <span class="hljs-comment">// and prevent an infinite loop.</span>            <span class="hljs-comment">//这里有个检测overflow的小技巧；还有</span><span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="hljs-built_in">cap</span> &#123;newcap += newcap / <span class="hljs-number">4</span>&#125;<span class="hljs-comment">// Set newcap to the requested cap when</span><span class="hljs-comment">// the newcap calculation overflowed.</span><span class="hljs-keyword">if</span> newcap &lt;= <span class="hljs-number">0</span> &#123;newcap = <span class="hljs-built_in">cap</span>&#125;&#125;&#125;    <span class="hljs-comment">//-------------!!!!以下开始计算内存位置，不但继续计算新的容量大小，还要决定扩容后是否要重新划分内存------------------</span>    <span class="hljs-keyword">var</span> overflow <span class="hljs-keyword">bool</span>    <span class="hljs-keyword">var</span> lenmem, newlenmem, capmem <span class="hljs-keyword">uintptr</span>    <span class="hljs-comment">// Specialize for common values of et.size.</span>    <span class="hljs-comment">// For 1 we don't need any division/multiplication.</span>    <span class="hljs-comment">// For sys.PtrSize, compiler will optimize division/multiplication into a shift by a constant.//这里就说到会优化</span>    <span class="hljs-comment">// For powers of 2, use a variable shift.</span>    <span class="hljs-keyword">switch</span> &#123;    <span class="hljs-keyword">case</span> et.size == <span class="hljs-number">1</span>:        lenmem = <span class="hljs-keyword">uintptr</span>(old.<span class="hljs-built_in">len</span>)        newlenmem = <span class="hljs-keyword">uintptr</span>(<span class="hljs-built_in">cap</span>)        capmem = roundupsize(<span class="hljs-keyword">uintptr</span>(newcap))<span class="hljs-comment">//这个就是计算新的capmen，当newcap不符合规定内存的大小规格时，会进行roundup内存对齐!!!</span>        overflow = <span class="hljs-keyword">uintptr</span>(newcap) &gt; maxAlloc        newcap = <span class="hljs-keyword">int</span>(capmem)    <span class="hljs-keyword">case</span> et.size == sys.PtrSize:<span class="hljs-comment">//是一个指针大小</span>        lenmem = <span class="hljs-keyword">uintptr</span>(old.<span class="hljs-built_in">len</span>) * sys.PtrSize        newlenmem = <span class="hljs-keyword">uintptr</span>(<span class="hljs-built_in">cap</span>) * sys.PtrSize        capmem = roundupsize(<span class="hljs-keyword">uintptr</span>(newcap) * sys.PtrSize)        overflow = <span class="hljs-keyword">uintptr</span>(newcap) &gt; maxAlloc/sys.PtrSize        newcap = <span class="hljs-keyword">int</span>(capmem / sys.PtrSize)<span class="hljs-comment">//sys.PtrSize指的是一个指针的size，64位的机器就是8</span>    <span class="hljs-keyword">case</span> isPowerOfTwo(et.size):<span class="hljs-comment">//2次幂会用variable shift</span>        <span class="hljs-keyword">var</span> shift <span class="hljs-keyword">uintptr</span>        <span class="hljs-keyword">if</span> sys.PtrSize == <span class="hljs-number">8</span> &#123;            <span class="hljs-comment">// Mask shift for better code generation.</span>            shift = <span class="hljs-keyword">uintptr</span>(sys.Ctz64(<span class="hljs-keyword">uint64</span>(et.size))) &amp; <span class="hljs-number">63</span>        &#125; <span class="hljs-keyword">else</span> &#123;            shift = <span class="hljs-keyword">uintptr</span>(sys.Ctz32(<span class="hljs-keyword">uint32</span>(et.size))) &amp; <span class="hljs-number">31</span>        &#125;        lenmem = <span class="hljs-keyword">uintptr</span>(old.<span class="hljs-built_in">len</span>) &lt;&lt; shift        newlenmem = <span class="hljs-keyword">uintptr</span>(<span class="hljs-built_in">cap</span>) &lt;&lt; shift        capmem = roundupsize(<span class="hljs-keyword">uintptr</span>(newcap) &lt;&lt; shift)        overflow = <span class="hljs-keyword">uintptr</span>(newcap) &gt; (maxAlloc &gt;&gt; shift)        newcap = <span class="hljs-keyword">int</span>(capmem &gt;&gt; shift)    <span class="hljs-keyword">default</span>:<span class="hljs-comment">//其他的情况就直接除以et.size</span>        lenmem = <span class="hljs-keyword">uintptr</span>(old.<span class="hljs-built_in">len</span>) * et.size        newlenmem = <span class="hljs-keyword">uintptr</span>(<span class="hljs-built_in">cap</span>) * et.size        capmem = roundupsize(<span class="hljs-keyword">uintptr</span>(newcap) * et.size)        overflow = <span class="hljs-keyword">uintptr</span>(newcap) &gt; maxSliceCap(et.size)        newcap = <span class="hljs-keyword">int</span>(capmem / et.size)    &#125;    <span class="hljs-comment">// The check of overflow (uintptr(newcap) &gt; maxSliceCap(et.size))</span>    <span class="hljs-comment">// in addition to capmem &gt; _MaxMem is needed to prevent an overflow</span>    <span class="hljs-comment">// which can be used to trigger a segfault on 32bit architectures</span>    <span class="hljs-comment">// with this example program:</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// type T [1&lt;&lt;27 + 1]int64</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// var d T</span>    <span class="hljs-comment">// var s []T</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// func main() &#123;</span>    <span class="hljs-comment">//   s = append(s, d, d, d, d)</span>    <span class="hljs-comment">//   print(len(s), "\n")</span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">cap</span> &lt; old.<span class="hljs-built_in">cap</span> || overflow || capmem &gt; maxAlloc &#123;        <span class="hljs-built_in">panic</span>(errorString(<span class="hljs-string">"growslice: cap out of range"</span>))    &#125;        <span class="hljs-keyword">var</span> p unsafe.Pointer         <span class="hljs-comment">//这个应该是地址了</span>    <span class="hljs-keyword">if</span> et.kind&amp;kindNoPointers != <span class="hljs-number">0</span> &#123;        p = mallocgc(capmem, <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>)<span class="hljs-comment">//申请内存空间</span>        memmove(p, old.array, lenmem)        <span class="hljs-comment">// The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length).</span>        <span class="hljs-comment">// Only clear the part that will not be overwritten.</span>        memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// Note: can't use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.</span>        p = mallocgc(capmem, et, <span class="hljs-literal">true</span>)        <span class="hljs-keyword">if</span> !writeBarrier.enabled &#123;            memmove(p, old.array, lenmem)        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">uintptr</span>(<span class="hljs-number">0</span>); i &lt; lenmem; i += et.size &#123;                typedmemmove(et, add(p, i), add(old.array, i))            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> slice&#123;p, old.<span class="hljs-built_in">len</span>, newcap&#125;&#125;</code></pre></div><p>这里可以参照<a href="./memManage.md">之前写的日志memManger</a>里面有关go的内存管理中</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">roundupsize</span><span class="hljs-params">(size <span class="hljs-keyword">uintptr</span>)</span> <span class="hljs-title">uintptr</span></span>&#123;&#125;</code></pre></div><p>即会对传入类型进行内存对齐,这也可能会导致扩容的容量跟之前说的*2或1.25倍不同！</p><p>我们做一个实验:</p><div class="hljs"><pre><code class="hljs go">t := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>)log.Printf(<span class="hljs-string">"%+v"</span>, <span class="hljs-built_in">cap</span>(t))t = <span class="hljs-built_in">append</span>(t, <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)log.Printf(<span class="hljs-string">"%+v"</span>, <span class="hljs-built_in">cap</span>(t))</code></pre></div><p>结果得出的是1000和2048，符合&lt;1024 则*2</p><div class="hljs"><pre><code class="hljs go">t := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">1024</span>, <span class="hljs-number">1024</span>)log.Printf(<span class="hljs-string">"%+v"</span>, <span class="hljs-built_in">cap</span>(t))t = <span class="hljs-built_in">append</span>(t, <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)log.Printf(<span class="hljs-string">"%+v"</span>, <span class="hljs-built_in">cap</span>(t))</code></pre></div><p>结果是1024和1280 ，符合&gt;1024 则 ×1.25倍</p><div class="hljs"><pre><code class="hljs go">t := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">1025</span>, <span class="hljs-number">1025</span>)log.Printf(<span class="hljs-string">"%+v"</span>, <span class="hljs-built_in">cap</span>(t))t = <span class="hljs-built_in">append</span>(t, <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)log.Printf(<span class="hljs-string">"%+v"</span>, <span class="hljs-built_in">cap</span>(t))</code></pre></div><p>1025,1360 ,符合</p><h2 id="4-回收">4. 回收</h2><p>//todo</p>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>class loading</title>
    <link href="/2019/06/05/java/Java-Class/"/>
    <url>/2019/06/05/java/Java-Class/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><p>##类的加载</p><h3 id="双亲委托模型">双亲委托模型</h3><p>双亲委派指的就是类加载器需要加载类的时候，会先把请求委托给父类加载器，依次递归，如果父类能完成，就返回，只有父类或祖类等无法完成，才自己加载;</p><p>JVM预定义的三个类型的加载器（classloader）</p><ol><li>Bootstrap加载器一般在&lt;JAVA_RUNTIME_HOME&gt;/lib下的类库加载到内存中，因为其涉及JVM本身实现细节，使用C++实现，所以开发者没法获得其引用</li><li>Extension类加载器sun的ExtClassloader负责&lt;JAVA_RUNTIME_HOME&gt;/lib/ext下或由java.ext.dir指定位置中的类库加载到内存中;</li><li>System类加载器AppClassloader实现，负责把classpath中指定的类加载;</li></ol><p>####目的防止内存出现多个同样的字节码，也能保证用到真正JDK里面提供的类;</p><p>然而这个<strong>并不是强制模型</strong></p><h4 id="需要注意：">需要注意：</h4><ol><li>加载的时候，会派出<strong>当前线程</strong>的类加载器（当前类加载器通过Thread.getContextClassLoader()，也可以通过setContextLoader()设置类加载器</li><li>如果加载该类的时候，有其他类引用此类，其他类也会被该类加载器加载</li><li>可直接调用Classloader.loadClass()指定某个类加载器</li></ol><p>SPI（service Provider Interface）//todo</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Notes about JVM</title>
    <link href="/2019/06/05/java/Java-JVM/"/>
    <url>/2019/06/05/java/Java-JVM/</url>
    
    <content type="html"><![CDATA[<p>不得不说，特么这兄弟归纳的太好了<img src="https://github.com/caison/java-knowledge-mind-map" srcset="/img/loading.gif" alt="地址"></p><a id="more"></a><p>字符串常量池</p><h2 id="内存结构">内存结构</h2><p><img src="/img/jvm_memStruct.jpg" srcset="/img/loading.gif" alt="旧的图" title="jvm Memstruct"></p><p><img src="/img/MemStruct.png" srcset="/img/loading.gif" alt="更特么详细的">上面的线程共享区，因为所有对象都在这里分配内存，所以也是GC的主要区域</p><p><img src="/img/HeapStruct.png" srcset="/img/loading.gif" alt="堆结构"></p><p>关于堆结构，上图是JDK8的示意图###堆</p><h4 id="新生代：">新生代：</h4><p>所有新生成的对象首先都是存放在新生代</p><h5 id="eden区">Eden区</h5><p>最主要包含了刚创建的对象，该区域对象大部分都是短期内死亡，所以垃圾回收器主要用标记-整理算法回收该区域</p><h5 id="survivor区">Survivor区</h5><p>又分为平等的两个区：</p><ol><li>From Survivor（s0）</li><li>To Survivor（S1）采用复制算法，每次只使用其中一块;</li></ol><p>Eden：Survivor=8：1</p><h4 id="老年代">老年代</h4><p>一般在Survivor中没有被清除出去的对象才会进入该区域，主要使用标记-清除（mark-sweep）算法</p><h4 id="操作">操作</h4><p>可-Xms 数字或-Xmx 数字 两个jvm参数来指定一个程序的堆内存大小，第一个是起始值，第二个是最大值</p><div class="hljs"><pre><code class="hljs java">java -Xms1M -Xmx2M helloworld</code></pre></div><h3 id="方法区-method-area">方法区（method area）</h3><p>用于存放已被加载的类信息，常量，静态变量，即时编译器编译（jit）后的代码等然而对其进行垃圾回收的话主要是对<strong>常量池</strong>和类的卸载</p><p>Hotspot虚拟机把它当作永久代进行垃圾回收，但因为很少确定永久代的大小JDK1.8开始，把永久代移除，并把方法区移至元空间（位于本地内存，不是JVM内存）</p><h4 id="运行时常量池">运行时常量池</h4><p>是方法区一部分，Class文件中的常量池（编译器生成的各种字面量和符号引用）会在类加载后被放入这个区域除了在编译期生成的常量，还允许动态生成，如string.Intern()PS：</p><ol><li>用双引号声明出来的String对象会被存储在常量池里</li><li>如果不是用双引号，intern方法会<strong>从字符串常量池中查询字符串是否存在，如果不存在就会将当前字符串放入常量池</strong></li></ol><h5 id="常见面试题">常见面试题</h5><div class="hljs"><pre><code class="hljs java">String s=<span class="hljs-keyword">new</span> String(<span class="hljs-string">"abc"</span>);</code></pre></div><p>如上创建了多少个对象？答案就是2个，一个是String在堆上的对象，一个是常量池里面的字符串”abc“</p><h4 id="操作-v2">操作</h4><p>-XX:PermSize最小空间-XX:MaxPermSize最大空间</p><h4 id="异常">异常</h4><p>和heap一样不需要连续的内存，而且动态扩展，失败会抛出OutOfMemory异常</p><h3 id="jvm-stack">JVM stack</h3><p>每个Java方法在执行的同时会创建一个栈帧用于存储局部变量表，操作数栈，常量池引用等信息;<strong>从调用到执行完成的过程，就对应了一个栈帧在jvm栈中的入栈和出栈</strong></p><h4 id="操作-v3">操作</h4><p>可以通过-Xss 设置jvm栈大小</p><div class="hljs"><pre><code class="hljs java">java -Xss512M helloworld</code></pre></div><h4 id="异常-v2">异常</h4><p>当请求栈深度超过最大值，会抛出stackoverflow异常</p><h3 id="本地方法栈">本地方法栈</h3><p>本地方法栈与JVM栈类似，只不过JVM栈为java方法（字节码）服务，本地方法为JVM的native方法服务本地方法一般由c++，汇编等编写</p><h4 id="操作-v4">操作</h4><p>Sun jdk中和jvm栈和本地方法栈是同一个，因此也可以用-Xss控制每个线程的大小</p><h3 id="程序计数器">程序计数器</h3><p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Notes about HTTP2</title>
    <link href="/2018/07/15/Comcon/HTTP2/"/>
    <url>/2018/07/15/Comcon/HTTP2/</url>
    
    <content type="html"><![CDATA[<p>HTTP2</p><a id="more"></a><h2 id="结构">结构</h2><h2 id="相对于http1-1-改变了啥子">相对于HTTP1.1 改变了啥子</h2><h3 id="http1-1提供的特性">HTTP1.1提供的特性</h3><p>HTTP1.1有一个关键的特性：keep-alive头字段以前的HTTP协议都是规定 <strong>每次请求都要建立一次连接（3次握手）</strong>，更别提慢启动，拥塞控制这些捞东西了;</p><p>而HTTP1.1的keep-alive字段就可以保证 <strong>一定时间内，同一域名多次请求数据，只建立一次HTTP请求</strong>，其他请求可以复用这次建立的通道，这里一定时间可以通过工具配置（nginx，apache）</p><h3 id="http1-1仍然有缺陷">HTTP1.1仍然有缺陷</h3><ol><li>连接数过多，浏览器一般就会因为这个设置TCP连接限制;一般是6-8个，假设是6,如果apache最大并发数为300,服务器每次承载最多只有300/6=50而已，多过这个数就要等待</li><li>文件传输只能是<strong>串行</strong>的（在一个通道里面）</li></ol><h3 id="http2多路复用">HTTP2多路复用</h3><ol><li><p>连接数过多的问题：HTTP2在<strong>同一域名</strong>下所有连接都基于<strong>流</strong>，都在同一个连接，比如上面的并发为300,用HTTP2就能达到300;</p></li><li><p>因为HTTP1.1传输的request和response都是<strong>基于文本的</strong>，所以所有数据必须按<strong>顺序传输</strong>才能保证可靠性（TCP）;然而HTTP2前面说到利用的是<strong>二进制数据帧</strong>和<strong>流</strong>（TCP其实也是流），帧就是标识了数据的顺序！即不必要传完一个request，等到response再继续下一个;</p></li></ol><h2 id="question">Question</h2><h3 id="why-not-use-http2-as-download-protocol">why not use HTTP2 as download protocol?</h3><p><a href="https://stackoverflow.com/questions/44019565/http2-file-download" target="_blank" rel="noopener">StackOverflow上有大佬提出</a></p><p>主要是两个点：</p><ol><li>frame overhead</li></ol><ol start="2"><li>flow control</li></ol><p>http2的server端会控制给每一个session和每一个在这个session里的stream的发送端口</p><h3 id="造成的问题-something-not-compatible-with-http2">造成的问题? Something not compatible with HTTP2?</h3><ol><li>JS文件合并:以前多个模块（文件）会合并成一个文件，当有模块要修改的时候，会全部上传一遍;</li><li>多域名进行文件传输(domain sharding)，会导致<strong>DNS解析时间过长</strong>，<strong>增加服务端压力</strong>等</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>networking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Notes about Raft and Paxos</title>
    <link href="/2018/07/10/Comcon/DistributeProtocol/"/>
    <url>/2018/07/10/Comcon/DistributeProtocol/</url>
    
    <content type="html"><![CDATA[<p>复习一些分布式理论: Raft和Paxos(暂时只讨论算法情况，工程情况留坑)</p><a id="more"></a><h2 id="paxos">PAXOS</h2><p>paxos实际上是一系列的协议，有basic-paxos, multi-paxos</p><p>目的：让多个参与者达成一致，共识</p><p><strong>一个原则</strong>：参与者如果达成一致，这个一致的观点在传递中永不会改变</p><h3 id="basic-paxos">basic-Paxos</h3><h4 id="一些角色和名词">一些角色和名词</h4><ol><li>client</li></ol><p>只是负责发起request到分布式系统并等待相应</p><ol start="2"><li><p>Proposer（发起者）每个Proposer也是一个Acceptor它负责从client 发起请求，尝试让Acceptor来同意这个请求，也会在冲突发生的时候作为一个合作者来使协议继续执行（propser可以不断发起提议，不用等提议完成）</p></li><li><p>Acceptor（Voter）每个Acceptor也是一个Proposer<strong>多个Acceptor</strong>组成一个Quorums（法定多数），所有发向一个Acceptor的必须要发给Acceptor的一个Quorum,不会同意比自己以前接受过的提案编号小的提案，任何从一个Acceptor来的信息会被忽略，除非能接受到一个从这个Quorum里所有的Acceptor来的拷贝？？？</p></li><li><p>Quorums（多数派）</p></li></ol><p>Quorums被定义为某些Accetors的集合的子集，即任何两个Quorums都会有至少一个Acceptor交集，而且Quorums总会是包含大部分的Acceptor;比如：有一个Accetpros的集合{A，B，C，D}，大部分的Quorums可以是任意三个Acceptor组成：{A，B，C}，{A，C，D}等等而经常Acceptor还会携带不同的权值，但保证的是Quorums所包含的所有Acceptors的权值和都会<strong>大于</strong>总的权值和（所有的Acceptors）的一半;</p><ol start="5"><li>Learner</li></ol><p>只是作为协议的复制因素，一旦client的request被Acceptor同意，learner就会开始执行这个request以及返回给client一个响应;一般为了提高协议的可用性，可以额外增加多个learner</p><h4 id="基本流程">基本流程</h4><p>每个basic-paxos的实例（或执行者）决定于一个输出值。该协议在多轮通信中进行;成功的有两轮，每轮有a，b，我们假定是在一个异步模型里面，即一个processor可能在第一轮，另一个可能在第二轮</p><p>首先进行典型的2PC 协议</p><p>Phase 1：</p><ol><li>1a：Prepare</li></ol><p>Proposer创建一个信息，我们称为<strong>Prepare</strong>，附带一个<strong>唯一标识数字 n</strong> 。</p><ul><li>而且当前的 n 要大于这个Proposer之前发的信息附带的所有 nX;</li><li>每次n = ++maxProposal;</li><li>Porcessor把这个带有 n 的Prepare信息（这里只带有n，实际上它不用带其他信息，比如提议内容）发到在一个Quorum的Acceptor上（哪些Acceptor在Quorum里面是由Proposer决定的???)</li></ul><p>如果Proposer不能与至少一个Quorum通信则不应该初始化Paxos</p><ol start="2"><li>1b：Promise（两个承诺，一个应答）</li></ol><p>每一个Acceptor会等待Proposer的Prepare信息，如果一个Acceptor收到了，它会查看附带的n标识，会有两种情况：</p><ol><li><p>如果<strong>n比之前收到的所有proposal n都大</strong></p><ul><li>这个Acceptor一定要返回一个信息Promise给对应的Proposer，然后会忽视所有未来的附带标识小于n的提议（信息）。</li><li>如果这个Acceptor以前接收过<strong>其他提议</strong>，返回给这个Proposer的response一定要包含之前的提议编号m，和对应的值w;（这里Acceptor还会<strong>持久化</strong>该proposal值）</li></ul></li><li><p>如果<strong>n出现&lt;=之前收到的任何一个proposal n</strong></p><ul><li>则不接受proposal n&lt;=当前请求的prepare请求，Acceptor能忽略这个提议;</li><li>为了优化，还是可回一个denial response，提示Proposer可以停止创建带有n的提议了，且该response可以带上一个当前Acceptor的promiseProposal，以便Proposer的更新</li></ul></li></ol><p>Phase 2：</p><ol><li>2a： Accept(propose)</li></ol><p>如果一个Proposer收到了的从Quorum返回的response，</p><ol><li>如果未超过一半的Acceptors同意，提议失败</li><li>如果超过了一半：</li></ol><div class="hljs"><pre><code>- 如果**所有**Acceptor都没有收到内容（null），即可发起proposal的内容，然后带上当前的**proposal n**，向所有Acceptor再发送提议;- 如果有**部分**Acceptor接到过内容，会从所有接受过的内容中，**选择proposal n最大**的内容作为真正的内容，提议编号仍然为n，但这时Proposer就不能提议自己的内容，只能信任Acceptor通过的内容;</code></pre></div><ol start="2"><li>2b：Accepted如果Acceptor接收到了提议后，他必须遵循：<ul><li>如果有且仅有不违背 **Phase1b（两个承诺）**情况下（即该提议n等于之前Phase1保存的编号），记录下(<strong>持久化</strong>）<strong>当前proposal n 和内容</strong>;最后Proposer收到Quorum返回的Accept response后，形成决议</li></ul></li></ol><h4 id="图解在算法异常的情况下-工程下更加复杂-先占坑-：">图解在算法异常的情况下（工程下更加复杂，先占坑）：</h4><ol><li>没有失败的情况下</li></ol><p>有一个client，1一个proposer，3个Acceptor，和两个learnner;</p><div class="hljs"><pre><code class="hljs undefined">Client   Proposer      Acceptor     Learner   |<span class="hljs-string">         </span>|<span class="hljs-string">          </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|   X--------&gt;|<span class="hljs-string">          </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Request   </span>|<span class="hljs-string">         X---------&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Prepare(1)   </span>|<span class="hljs-string">         </span>|<span class="hljs-string">&lt;---------X--X--X       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Promise(1,&#123;Va,Vb,Vc&#125;)   </span>|<span class="hljs-string">         X---------&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Accept!(1,V)   </span>|<span class="hljs-string">         </span>|<span class="hljs-string">&lt;---------X--X--X------&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">  Accepted(1,V)   </span>|<span class="hljs-string">&lt;---------------------------------X--X  Response   </span>|<span class="hljs-string">         </span>|<span class="hljs-string">          </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|Here, V is the last of (Va, Vb, Vc).</code></pre></div><ol start="2"><li><p>Acceptor失败的情况</p></li><li><p>Quorum里面有一个Acceptor失败了，所以整个Quorum大小会变成2，整个paxos还是成功的（此时Quorum数目&gt; Acceptors/2)</p></li><li><p>如果有两个或三个失败，则直接返回失败;或Proposer重新发起提议（内容一样，提议号n+1）但是，对第一次已经成功接收的acceptor不会修改，其余上一次失败的acceptors才会接收提议</p></li></ol><div class="hljs"><pre><code class="hljs undefined">Client   Proposer      Acceptor     Learner   |<span class="hljs-string">         </span>|<span class="hljs-string">          </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|   X--------&gt;|<span class="hljs-string">          </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Request   </span>|<span class="hljs-string">         X---------&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Prepare(1)   </span>|<span class="hljs-string">         </span>|<span class="hljs-string">          </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  !       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  !! FAIL !!   </span>|<span class="hljs-string">         </span>|<span class="hljs-string">&lt;---------X--X          </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Promise(1,&#123;Va, Vb, null&#125;)   </span>|<span class="hljs-string">         X---------&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">          </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Accept!(1,V)   </span>|<span class="hljs-string">         </span>|<span class="hljs-string">&lt;---------X--X---------&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">  Accepted(1,V)   </span>|<span class="hljs-string">&lt;---------------------------------X--X  Response   </span>|<span class="hljs-string">         </span>|<span class="hljs-string">          </span>|<span class="hljs-string">  </span>|<span class="hljs-string">          </span>|<span class="hljs-string">  </span>|</code></pre></div><ol start="3"><li>Leaner也可能会失败</li></ol><p>虽然有一个learner失败了，但整个paxos还是成功的</p><div class="hljs"><pre><code class="hljs undefined">Client Proposer         Acceptor     Learner   |<span class="hljs-string">         </span>|<span class="hljs-string">          </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|   X--------&gt;|<span class="hljs-string">          </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Request   </span>|<span class="hljs-string">         X---------&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Prepare(1)   </span>|<span class="hljs-string">         </span>|<span class="hljs-string">&lt;---------X--X--X       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Promise(1,&#123;Va,Vb,Vc&#125;)   </span>|<span class="hljs-string">         X---------&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Accept!(1,V)   </span>|<span class="hljs-string">         </span>|<span class="hljs-string">&lt;---------X--X--X------&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">  Accepted(1,V)   </span>|<span class="hljs-string">         </span>|<span class="hljs-string">          </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  !  !! FAIL !!   </span>|<span class="hljs-string">&lt;---------------------------------X     Response   </span>|<span class="hljs-string">         </span>|<span class="hljs-string">          </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|</code></pre></div><ol start="4"><li>Proposer失败</li></ol><p>在Proposer接收到proposal值（提议内容）之后，发回的Accept阶段失败了，只有一个Acceptor接到提议;同时，一个新的Proposer被选举出来：</p><div class="hljs"><pre><code class="hljs undefined">Client  Proposer        Acceptor     Learner   |<span class="hljs-string">      </span>|<span class="hljs-string">             </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|   X-----&gt;|<span class="hljs-string">             </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Request   </span>|<span class="hljs-string">      X------------&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Prepare(1)   </span>|<span class="hljs-string">      </span>|<span class="hljs-string">&lt;------------X--X--X       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Promise(1,&#123;Va, Vb, Vc&#125;)   </span>|<span class="hljs-string">      </span>|<span class="hljs-string">             </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|   |<span class="hljs-string">      </span>|<span class="hljs-string">             </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  !! Leader fails during broadcast !!   </span>|<span class="hljs-string">      X------------&gt;</span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Accept!(1,V)   </span>|<span class="hljs-string">      !             </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|   |<span class="hljs-string">         </span>|<span class="hljs-string">          </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  !! NEW LEADER !!   </span>|<span class="hljs-string">         X---------&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Prepare(2)   </span>|<span class="hljs-string">         </span>|<span class="hljs-string">&lt;---------X--X--X       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Promise(2,&#123;V, null, null&#125;)   </span>|<span class="hljs-string">         X---------&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Accept!(2,V)   </span>|<span class="hljs-string">         </span>|<span class="hljs-string">&lt;---------X--X--X------&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">  Accepted(2,V)   </span>|<span class="hljs-string">&lt;---------------------------------X--X  Response   </span>|<span class="hljs-string">         </span>|<span class="hljs-string">          </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|</code></pre></div><ol start="5"><li>多个Proposer冲突 ！！！！锁住了对方的Accept，导致prepare的值全部作废这里问题大了。。。。（其实就引出了multi-paxos）</li></ol><div class="hljs"><pre><code class="hljs undefined">Client   Leader         Acceptor     Learner   |<span class="hljs-string">      </span>|<span class="hljs-string">             </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|   X-----&gt;|<span class="hljs-string">             </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Request   </span>|<span class="hljs-string">      X------------&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Prepare(1)   </span>|<span class="hljs-string">      </span>|<span class="hljs-string">&lt;------------X--X--X       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Promise(1,&#123;null,null,null&#125;)   </span>|<span class="hljs-string">      !             </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  !! LEADER FAILS   </span>|<span class="hljs-string">         </span>|<span class="hljs-string">          </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  !! NEW LEADER (knows last number was 1)   </span>|<span class="hljs-string">         X---------&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Prepare(2)   </span>|<span class="hljs-string">         </span>|<span class="hljs-string">&lt;---------X--X--X       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Promise(2,&#123;null,null,null&#125;)   </span>|<span class="hljs-string">      </span>|<span class="hljs-string">  </span>|<span class="hljs-string">          </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  !! OLD LEADER recovers   </span>|<span class="hljs-string">      </span>|<span class="hljs-string">  </span>|<span class="hljs-string">          </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  !! OLD LEADER tries 2, denied   </span>|<span class="hljs-string">      X------------&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Prepare(2)   </span>|<span class="hljs-string">      </span>|<span class="hljs-string">&lt;------------X--X--X       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Nack(2)   </span>|<span class="hljs-string">      </span>|<span class="hljs-string">  </span>|<span class="hljs-string">          </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  !! OLD LEADER tries 3   </span>|<span class="hljs-string">      X------------&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Prepare(3)   </span>|<span class="hljs-string">      </span>|<span class="hljs-string">&lt;------------X--X--X       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Promise(3,&#123;null,null,null&#125;)   </span>|<span class="hljs-string">      </span>|<span class="hljs-string">  </span>|<span class="hljs-string">          </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  !! NEW LEADER proposes, denied   </span>|<span class="hljs-string">      </span>|<span class="hljs-string">  X---------&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Accept!(2,Va)   </span>|<span class="hljs-string">      </span>|<span class="hljs-string">  </span>|<span class="hljs-string">&lt;---------X--X--X       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Nack(3)   </span>|<span class="hljs-string">      </span>|<span class="hljs-string">  </span>|<span class="hljs-string">          </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  !! NEW LEADER tries 4   </span>|<span class="hljs-string">      </span>|<span class="hljs-string">  X---------&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Prepare(4)   </span>|<span class="hljs-string">      </span>|<span class="hljs-string">  </span>|<span class="hljs-string">&lt;---------X--X--X       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Promise(4,&#123;null,null,null&#125;)   </span>|<span class="hljs-string">      </span>|<span class="hljs-string">  </span>|<span class="hljs-string">          </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  !! OLD LEADER proposes, denied   </span>|<span class="hljs-string">      X------------&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Accept!(3,Vb)   </span>|<span class="hljs-string">      </span>|<span class="hljs-string">&lt;------------X--X--X       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Nack(4)   </span>|<span class="hljs-string">      </span>|<span class="hljs-string">  </span>|<span class="hljs-string">          </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  ... and so on ...</span></code></pre></div><h3 id="multi-paxos">Multi-Paxos</h3><p>multi-Paxos将集群分为两种状态</p><p>以上参考 *** <img src="https://webcache.googleusercontent.com/search?q=cache:zXcryn67tFcJ:https://en.wikipedia.org/wiki/Paxos_(computer_science)+&amp;cd=2&amp;hl=en&amp;ct=clnk" srcset="/img/loading.gif" alt="wiki-Paxos"> ***</p><h2 id="raft">Raft</h2><p>解决一致性问题的三个子问题</p><p>比较简单，可以从几个方面进行理解，为</p><ul><li>主从筛选(leader election)</li><li>日志复制(log replication)</li><li>安全性(Safety,leader变更时)</li></ul><h3 id="主从筛选">主从筛选</h3><p>保证任何时期最多只有一个leader，leader节点有所有已提交的日志</p><h3 id="日志复制">日志复制</h3><p>指的是Raft保证每个副本日志append的<strong>连续性</strong></p><p>leader会为每个follower维护一个nextIndex，表示leader给各个follower发送的下一条log entry在log中的index。</p><p>如果日志append的时候前一个日志还没有append，则必须等到前一个日志append后才能append。也就是说不同副本上相同index的日志，只要term相同，那么这两条日志必然相同，且这之前的日志必然也相同。</p><h3 id="安全性">安全性</h3><p>Leader只能附加的原则，只允许leader commit被大部分append的log entry;即如果当前的log已被commit，证明在这之前的所有log都被提交</p><h4 id="节点错误处理">节点错误处理</h4><p>宕机等有几种情况：</p><ol><li><p>Followers 或 CandidatesFollowers 或者candidates 崩溃, 解决办法只需要leader不断重试发送请求即可， 再不行就重启该崩溃的服务器，就能收到AppendEntriesRPC和Requestvotes请求</p></li><li><p>Leader但是Leader 崩溃，如果直接重启服务器：在完成了一次RPC发送但没有接收response的时候重启，他会再次收到一个相同的RPC，但是因为Raft RPC是幂等的，所以这个没有关系，举个例子，如果一个follower接到了AppendEntries请求，而且发现这个请求的log entries已经在自己的log里面了，他会忽略这个请求</p></li><li><p>网络分区，多数派的leader照常工作，少数派按照道理是不能选出leader，所以没有工作，恢复后少数派没有最新的log，所以肯定是成为follower，leader只需要appendEntries回复这些followers的log即可</p></li></ol><h4 id="时间和可用性">时间和可用性</h4><p>时间指timing，这里尤其是leader的选举，是时间敏感的，Raft有个公式，可以保证能选举和维护一个稳定的leader:</p><blockquote><blockquote><p>broadcastTime&lt;&lt; electionTimeout &lt;&lt; MTBF</p></blockquote></blockquote><p>broadcastTime: 广播的平均时间（某个节点）electionTimeout: 选举的时间MTBF: 前一次失败和这一次失败间隔的平均时间（某个节点）</p><p>broadcastTime&lt;&lt; electionTimeout 可以保证leader发送heartbeat给其他followers，防止他们开始选举</p><p>electionTimeout&lt;&lt; MTBF 可以保证系统平稳进步？</p><p>一般来说， broadcastTime只会在0.5ms ~ 20ms取决于持久化的技术，所以相应的，electionTimeout就会是在10ms~500ms之间， 比较重要的节点的MTBF则取几个月或更多</p><h3 id="节点成员改变">节点成员改变</h3><p>我们之前都是假定节点配置是不变的，但实际上当有server crash的时候就需要替换他们虽然我们可以把所有接地都下线，更新配置，然后上线，但这明显有问题</p><ol><li>保证配置的安全， 一个term期间，在有可能有两个leader被选举的时候进行配置的传输，但在转移配置的时候，不能保证所有server都能第一时间拿到新的配置，可能会导致节点分裂成两部分，两个独立的大多数</li></ol><p>为了保证安全，只能分为 <strong>两步提交</strong>一些系统就会做 第一步：关闭旧的配置，第二开启新配置</p><p>在raft里面，节点第一次切换到新的配置，我们称之为joint consensus（交叉共识），一旦交叉共识被commit，整个系统就都转到了新的配置上</p><h4 id="joint-consensus">Joint consensus</h4><p>交叉共识包含log entries会被复制到新旧配置中的所有server任何节点在任一配置中都能被当做leader共识（这里针对选举和提交）要分开的大多数配置通过 （旧的大多数和新的大多数）</p><h2 id="raft缺点">Raft缺点</h2><p>每次都是串行投票,串行apply</p><p><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md" target="_blank" rel="noopener">大牛的证明（中文）</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Distributed</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Notes about Design Pattern（java）</title>
    <link href="/2018/04/30/Comcon/DesignPattern/"/>
    <url>/2018/04/30/Comcon/DesignPattern/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><p>For reviewing some most likely used design pattern:</p><h2 id="singleton"><strong>Singleton</strong></h2><p>Most commonly</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton singleton = <span class="hljs-keyword">new</span> Singleton();    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">//in case of creating a new object</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getSingleton</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> singleton;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">other</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//other method</span>    &#125;&#125;</code></pre></div><p>Pros:</p><ol><li><p>Because only one instance exists in memory, it greatly decrease the usage of memory.Especially in the case that an object needs to be initialized and deleted frequently,while the instantiation and deletion can’t be optimized, Singleton pattern is the best choice.</p></li><li><p>Prevent multiple domination towards the same source.For example, an operation of writing in a file.</p></li><li></li></ol><p>Cons:</p><ol><li>Obviously, because singleton has instatiated itself, so it’s impossible to extend interface to it (abstract class,interface will not be instantiated )</li></ol><p>Scenes:</p><ol><li>generate unique key;</li><li>IO;</li><li>global stored in memory for calculating purpose.For exmaple, Spring Bean is set as a singleton by default so that spring can manage this bean life cycle(but if Bean use non-singleton like prototype pattern,after the initialization of Bean, it will be transfered to J2EE container,Spring no longer manages this Bean)</li></ol><h2 id="proxy"><strong>Proxy</strong></h2><h3 id="static-proxy"><strong>static proxy</strong></h3><p>We assume there is an interface:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IUser</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p>Our target UserDAO:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IUser</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">()</span></span>&#123;        System.out.Println(<span class="hljs-string">"you've logined"</span>);    &#125;&#125;</code></pre></div><p>Proxy Object: UserProxy</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IUser</span></span>&#123;    <span class="hljs-keyword">private</span> User target;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserProxy</span> <span class="hljs-params">(User target)</span></span>&#123;        <span class="hljs-keyword">this</span>.target=target;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"begin login"</span>);        target.login();        System.out.println(<span class="hljs-string">"login end"</span>);    &#125;&#125;</code></pre></div><p><strong>How to Use:</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        User target=<span class="hljs-keyword">new</span> User();        UserProxy p=<span class="hljs-keyword">new</span> UserProxy(target);        p.login();    &#125;&#125;</code></pre></div><h4 id="pros">Pros:</h4><p>It can extend the target’s function without change target’s code</p><h4 id="cons">Cons:</h4><p>If methods in interface increase, both proxy class and target class have to be recodedProxy class <strong>must achieve the same interface</strong> as target class’s, so it may cause loads of proxy class</p><h3 id="dynamic-proxy"><strong>dynamic proxy</strong></h3><h4 id="jdk">JDK</h4><p>Spring 默认使用JDK，<strong>proxy-target-class=false</strong>时使用jdk，true的时候用CGllib代理Able to solve cons in Static proxy:</p><ol><li>you <strong>don’t have to implements interface{} in Proxy class(But the target class must implement interface)</strong>动态代理的区别主要就是，代理的proxy class并<strong>不用自己实现接口</strong>，而是在runtime的时候动态在内存生成</li></ol><p>Creating a dynamic proxy is a static method in <strong>java.lang.reflect.Proxy</strong> package</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> Object <span class="hljs-title">newProxyInstance</span><span class="hljs-params">(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h)</span></span>&#123;&#125;</code></pre></div><p>用法：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GamePlayIH</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;     <span class="hljs-comment">//被代理者</span>     Class cls =<span class="hljs-keyword">null</span>;     <span class="hljs-comment">//被代理的实例</span>     Object obj = <span class="hljs-keyword">null</span>;     <span class="hljs-comment">//我要代理谁</span>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GamePlayIH</span><span class="hljs-params">(Object _obj)</span></span>&#123;             <span class="hljs-keyword">this</span>.obj = _obj;     &#125;     <span class="hljs-comment">//调用被代理的方法</span>     <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span>                    <span class="hljs-keyword">throws</span> Throwable </span>&#123;                                   Object result = method.invoke(<span class="hljs-keyword">this</span>.obj, args);             <span class="hljs-keyword">return</span> result;     &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;        User u = <span class="hljs-keyword">new</span> User();<span class="hljs-comment">//注意要有一个实例才可以</span>        InvocationHandler i=<span class="hljs-keyword">new</span> GamePlayIH(u);                IUser dynamicUser=(IUser) Proxy.newProxyInstance(User<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getClassLoader</span>(),<span class="hljs-title">User</span>.<span class="hljs-title">class</span>.<span class="hljs-title">getInterfaces</span>(),<span class="hljs-title">i</span>)</span>;        dynamicUser.login();    &#125;&#125;</code></pre></div><p>看下newProxyInstance源码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">newProxyInstance</span><span class="hljs-params">(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException    </span>&#123;        Objects.requireNonNull(h);        <span class="hljs-keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();        <span class="hljs-comment">/*         * Look up or generate the designated proxy class.         */</span>        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);        <span class="hljs-comment">/*         * Invoke its constructor with the designated invocation handler.         */</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);            <span class="hljs-keyword">final</span> InvocationHandler ih = h;            <span class="hljs-keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;                AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;                    <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                        cons.setAccessible(<span class="hljs-keyword">true</span>);                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;                    &#125;                &#125;);            &#125;            <span class="hljs-keyword">return</span> cons.newInstance(<span class="hljs-keyword">new</span> Object[]&#123;h&#125;);        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(e.toString(), e);        &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;            Throwable t = e.getCause();            <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> RuntimeException) &#123;                <span class="hljs-keyword">throw</span> (RuntimeException) t;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(t.toString(), t);            &#125;        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(e.toString(), e);        &#125;    &#125;</code></pre></div><p>So how to generate the Proxy Class? <strong>getProxyClass0</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader， Class&lt;?&gt;... interfaces) &#123;    <span class="hljs-keyword">if</span> (interfaces.length &gt; <span class="hljs-number">65535</span>) &#123;<span class="hljs-comment">//为啥不能超过65535？数字怎么来？//网络MTU？？jvm限制方法数目不能大于这个数</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"interface limit exceeded"</span>);    &#125;    <span class="hljs-comment">// If the proxy class defined by the given loader implementing</span>    <span class="hljs-comment">// the given interfaces exists, this will simply return the cached copy;</span>    <span class="hljs-comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span>    <span class="hljs-keyword">return</span> proxyClassCache.get(loader, interfaces);<span class="hljs-comment">//proxyClass的获取可以从Cache里面得到，也可以从proxyFactory里面得到：</span>&#125;</code></pre></div><p>COntinue to <strong>proxyFactory</strong></p><div class="hljs"><pre><code class="hljs java">/**     * A factory function that generates, defines and returns the proxy class given     * the ClassLoader and array of interfaces.     */    private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;    &#123;        // Proxy class会附带前缀 $Proxy        private static final String proxyClassNamePrefix = "$Proxy";        // next number to use for generation of unique proxy class names        private static final AtomicLong nextUniqueNumber = new AtomicLong();        @Override        public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;            Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);            for (Class&lt;?&gt; intf : interfaces) &#123;                /*                 * Verify that the class loader resolves the name of this                 * interface to the same Class object.                 */                Class&lt;?&gt; interfaceClass = null;                try &#123;                    interfaceClass = Class.forName(intf.getName(), false, loader);                &#125; catch (ClassNotFoundException e) &#123;                &#125;                if (interfaceClass != intf) &#123;//可能会对classloader隐藏                    throw new IllegalArgumentException(                        intf + " is not visible from class loader");                &#125;                /*                 * Verify that the Class object actually represents an                 * interface.                 */                if (!interfaceClass.isInterface()) &#123;                    throw new IllegalArgumentException(                        interfaceClass.getName() + " is not an interface");                &#125;                /*                 * Verify that this interface is not a duplicate.                 */                if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123;                    throw new IllegalArgumentException(                        "repeated interface: " + interfaceClass.getName());                &#125;            &#125;            String proxyPkg = null;     // package to define proxy class in            int accessFlags = Modifier.PUBLIC | Modifier.FINAL;            /*             * Record the package of a non-public proxy interface so that the             * proxy class will be defined in the same package.  Verify that             * all non-public proxy interfaces are in the same package.             */            for (Class&lt;?&gt; intf : interfaces) &#123;                int flags = intf.getModifiers();                if (!Modifier.isPublic(flags)) &#123;                    accessFlags = Modifier.FINAL;                    String name = intf.getName();                    int n = name.lastIndexOf('.');                    String pkg = ((n == -1) ? "" : name.substring(0, n + 1));                    if (proxyPkg == null) &#123;                        proxyPkg = pkg;                    &#125; else if (!pkg.equals(proxyPkg)) &#123;                        throw new IllegalArgumentException(                            "non-public interfaces from different packages");                    &#125;                &#125;            &#125;            if (proxyPkg == null) &#123;                // if no non-public proxy interfaces, use com.sun.proxy package                proxyPkg = ReflectUtil.PROXY_PACKAGE + ".";            &#125;            /*             * Choose a name for the proxy class to generate.             */            long num = nextUniqueNumber.getAndIncrement();            String proxyName = proxyPkg + proxyClassNamePrefix + num;//这里就是动态生成proxy名字的地方            /*             * Generate the specified proxy class.             */             //这里就是生成proxy class的地方            byte[] proxyClassFile = ProxyGenerator.generateProxyClass(                proxyName, interfaces, accessFlags);            try &#123;                return defineClass0(loader, proxyName,//defineClass0似乎是到字节码的代码了，没法进入                                    proxyClassFile, 0, proxyClassFile.length);            &#125; catch (ClassFormatError e) &#123;                /*                 * A ClassFormatError here means that (barring bugs in the                 * proxy class generation code) there was some other                 * invalid aspect of the arguments supplied to the proxy                 * class creation (such as virtual machine limitations                 * exceeded).                 */                throw new IllegalArgumentException(e.toString());            &#125;        &#125;    &#125;</code></pre></div><h4 id="cglib-code-generation-library">CGLIB（Code Generation Library)</h4><p><strong>If the target object doesn’t implement any interface{}</strong>you can use <strong>Cglib proxy</strong></p><p>Its principle is that it will create an object <strong>inherit</strong> to target class整个CGlib是基于ASM字节码的生成和转换的库也是用上面的例子,没有implement任何interface</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserNo</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"login without interface"</span>);    &#125;&#125;</code></pre></div><p>How to use:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserMethodInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span></span>&#123;    <span class="hljs-comment">//..</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Obj obj, Method method, Object[] args,MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable</span>&#123;        System.out.println(<span class="hljs-string">"method name:"</span>+ method.getName());        System.out.println(<span class="hljs-string">"method declaring CLass:"</span>+ method.getDeclaringClass());        System.out.println(<span class="hljs-string">"this is "</span>+ (String)proxy.invokeSuper(obj,args));        System.out.println(<span class="hljs-string">"method name:"</span>+ method.getName());            &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;        Enhancer enhancer=<span class="hljs-keyword">new</span> Enhancer();        enhancer.setSuperClass(User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-comment">//根本不用类的实例传入（与JDK有点不一样）</span>        enhancer.setCallback(<span class="hljs-keyword">new</span> UserMethodINterceptor);        User u=(User) enhancer.create();                System.out.println(<span class="hljs-string">"login proxy:"</span>);        u.login();    &#125;&#125;</code></pre></div><p>前面说到因为这是基于继承的动态代理，所以因为 <strong>final</strong> 修饰的方法等是无法被继承的，所以像getClass(),wait()等并不会进行代理如果要强行代理，便会出错：</p><div class="hljs"><pre><code class="hljs java">java.lang.IllegalArgumentException: Cannot subclass <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">cglib</span>.<span class="hljs-title">HelloConcrete</span></span></code></pre></div><p>源码在<strong>java.net.sf.cglib</strong></p><p>里面暂时注意Enhancer class和MethodInterceptor Class</p>]]></content>
    
    
    
    <tags>
      
      <tag>Design Pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-Concurrency</title>
    <link href="/2018/03/07/java/Java-Concurrency/"/>
    <url>/2018/03/07/java/Java-Concurrency/</url>
    
    <content type="html"><![CDATA[<p>Actually we’ve learned the concept about multithread and the problem may cause.For instance, deadlock.</p><a id="more"></a><p>Following is some notes about the avoiding or solving the deadlock.</p><h2 id="monitor">**Monitor **</h2><p>At the beginning, we can look at a picture:<img src="/img/java-monitor-associate-with-object.jpg" srcset="/img/loading.gif" alt="Monitor"></p><p>而一个锁就像一种任何时候只允许一个线程拥有的特权.<br>一个线程可以允许多次对同一对象上锁.对于每一个对象来说,java虚拟机维护一个计数器,记录对象被加了多少次锁,没被锁的对象的计数器是0,线程每加锁一次,计数器就加1,每释放一次,计数器就减1.当计数器跳到0的  时候,锁就被完全释放了.</p><p>java虚拟机中的一个线程在它到达监视区域开始处的时候请求一个锁.JAVA程序中每一个监视区域都和一个对象引用相关联.<br>The program is like a building. And it stores some data meanwhile. But every time this building can only be occupied by only <span style="color:#f92672"><strong>one</strong> thread.If the thread enter this building, it’s called <strong>enter monitor</strong>;If the thread enter the special room in this building, it’s called <strong>get monitor</strong>;If the thread occupy the room, it’s called <strong>occupy monitor</strong>;If the thread leave the room, it’s called <strong>release monitor</strong>;If the thread leave the building, it’s called <strong>exit monitor</strong>;</span></p><p>Then,a <strong>LOCK</strong> is an authority only for single thread in every time.Single thread is allowed to multiplically add the lock to the same <a href="http://object.As" target="_blank" rel="noopener">object.As</a> for an object, JVM maintain a counter to record how many times the object was added lock.</p><p>In Java, to implement a monitor, we’re supposed to use <strong>Lock</strong> and <strong>Condition</strong> class,</p><h2 id="semaphore"><strong>Semaphore</strong></h2><p>In *** official docs ***:</p><blockquote><blockquote><p>A counting semaphore. Conceptually, a semaphore maintains a set of permits.Each acquire() blocks if necessary until a permit is available, and then takes it.Each release() adds a permit, potentially releasing a blocking acquirer.However, no actual permit objects are used; the Semaphore just keeps a count of the number available and acts accordingly.</p></blockquote></blockquote><p>Semaphores are often used to restrict the number of threads than can access some (physical or logical) resource. For example, here is a class that uses a semaphore to control access to a pool of items:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pool</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_AVAILABLE = <span class="hljs-number">100</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Semaphore available = <span class="hljs-keyword">new</span> Semaphore(MAX_AVAILABLE, <span class="hljs-keyword">true</span>);  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getItem</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    available.acquire();    <span class="hljs-keyword">return</span> getNextAvailableItem();  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putItem</span><span class="hljs-params">(Object x)</span> </span>&#123;    <span class="hljs-keyword">if</span> (markAsUnused(x))      available.release();  &#125;  <span class="hljs-comment">// Not a particularly efficient data structure; just for demo</span>  <span class="hljs-keyword">protected</span> Object[] items = ... <span class="hljs-comment">//whatever kinds of items being managed</span>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[MAX_AVAILABLE];  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> Object <span class="hljs-title">getNextAvailableItem</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;      <span class="hljs-keyword">if</span> (!used[i]) &#123;         used[i] = <span class="hljs-keyword">true</span>;         <span class="hljs-keyword">return</span> items[i];      &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; <span class="hljs-comment">// not reached</span>  &#125;  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">markAsUnused</span><span class="hljs-params">(Object item)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;      <span class="hljs-keyword">if</span> (item == items[i]) &#123;         <span class="hljs-keyword">if</span> (used[i]) &#123;           used[i] = <span class="hljs-keyword">false</span>;           <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;         &#125; <span class="hljs-keyword">else</span>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;  &#125;&#125;</code></pre></div><h2 id="threadlocal"><strong>ThreadLocal</strong></h2><p>该修饰符主要修饰变量，使该变量变为线程局部变量，同一个ThreadLocal所包含的对象，在不同thread中有不同的副本所以可以引出：</p><ol><li>每个Thread有不同副本，所以其他thread不可访问，就不会有线程问题</li><li>因为只在一个线程内使用，其<strong>一般</strong>会被<strong>private static</strong>修饰;static主要是因为其保证了多个实例只会有一个，否则同一个线程可能会访问同一个类的不同实例，即使不错误也会导致浪费（重复创建了一样的对象）//？？？？</li></ol><h3 id="结构">结构</h3><p>其内有一个 ThreadlocalMap的内部类，使用的是线性探测法（够慢，不过也够）它的key为ThreadLocal对象，而且还是弱引用</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**     * ThreadLocalMap is a customized hash map suitable only for     * maintaining thread local values. No operations are exported     * outside of the ThreadLocal class. The class is package private to     * allow declaration of fields in class Thread.  To help deal with     * very large and long-lived usages, the hash table entries use     * WeakReferences for keys. However, since reference queues are not     * used, stale entries are guaranteed to be removed only when     * the table starts running out of space.     */</span>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalMap</span> </span>&#123;        <span class="hljs-comment">/**         * The entries in this hash map extend WeakReference, using         * its main ref field as the key (which is always a         * ThreadLocal object).  Note that null keys (i.e. entry.get()         * == null) mean that the key is no longer referenced, so the         * entry can be expunged from table.  Such entries are referred to         * as "stale entries" in the code that follows.         */</span>        <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;            <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span>            Object value;            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;                <span class="hljs-keyword">super</span>(k);                value = v;            &#125;        &#125;        <span class="hljs-comment">//....</span>    &#125;</code></pre></div><h3 id="注意">注意</h3><p>ThreadLocal是个浅copy，如果变量是一个引用类型，那么就要考虑其内部状态是否会被改变，想要解决只能通过重写initialValue（）方法来自己实现深copy;其思路和锁也不一样，锁是强调如何同步多个线程去正确共享一个变量，而threadlocal是为了解决同一个变量如何不被多个线程共享;</p><h3 id="使用场景：">使用场景：</h3><ol><li>每个线程需要有自己单独的实例</li><li>实例需要在多个方法中共享，但不希望被多线程共享</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-Collections</title>
    <link href="/2018/01/07/java/Java-Collection/"/>
    <url>/2018/01/07/java/Java-Collection/</url>
    
    <content type="html"><![CDATA[<p>Following is the summarize of the Java Collections://todo</p><a id="more"></a> <p>#类别List,Set,Map</p><p>##Wildcard</p><p>Lets look at an interesting stuff:<div style="color:#f92672">Collections</div>the <mark>supertype</mark> of all kinds of collections is Collection&lt;?&gt;(? is called “unknown”)</p><div class="hljs"><pre><code class="hljs java">Collection&lt;?&gt; c = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();c.add(<span class="hljs-keyword">new</span> Object());<span class="hljs-comment">//Compile time error;</span></code></pre></div><h2 id="map">Map</h2><h3 id="linkedhashmap">LinkedHashMap</h3><p>首先我们来看下LinkedHashMap的结构（这里盗一张别人的图）<img src="/img/linkedHashMap.jpg" srcset="/img/loading.gif" alt="linkedhashmap"></p><p>由此知道 LinkedHashMap是继承于HashMap的，所以hash算法，红黑树这些玩意儿都会有，但这里主要是它特殊的性质：</p><ol><li>其底层是双向链表，<strong>保证了遍历顺序和插入顺序一致的情况</strong></li><li>实现了LRU (即对访问顺序有相关实现)</li></ol><h3 id="hashmap">HashMap</h3><p>HashTable暂且不谈，jdk8已经不推荐使用，但其是线程安全，因为用了synchronized修饰</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2018/01/05/Regexp/"/>
    <url>/2018/01/05/Regexp/</url>
    
    <content type="html"><![CDATA[<p>曾经认为，这玩意儿要匹配的话扔网上工具转换就行，但现在感觉还是记住一些比较重要的好一点，所以就当练打字吧~</p><p>这里的正则表达式就暂时在javascript上讨论吧。</p><a id="more"></a><p>参考<a href="http://www.runoob.com/jsref/jsref-obj-regexp.html" target="_blank" rel="noopener">网上随便找的中文教程</a></p><p>再附上一个<a href="https://regexr.com/" target="_blank" rel="noopener">贼鸡儿好用的在线匹配</a></p><blockquote><blockquote><blockquote><p>在某些语言里面记得用` ` 字符进行传递</p></blockquote></blockquote></blockquote><p>这就不得不提到<span style="color:#f92672;font-size:2rem">RegExp</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp" target="_blank" rel="noopener">MDN手册</a>这个对象</p><h3 id="语法：">语法：</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> patt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(pattern[, flags])<span class="hljs-keyword">var</span> patt = <span class="hljs-regexp">/pattern/</span>flags;</code></pre></div><p><strong>pattern:就是写正则的地方</strong><strong>flags取值(可以是下面的任意组合):</strong></p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-string">g:</span>global match <span class="hljs-comment">//查找所有匹配而不是在找到第一个匹配后停止</span><span class="hljs-string">i:</span>ignore <span class="hljs-keyword">case</span> <span class="hljs-comment">//忽略大小写</span><span class="hljs-string">m:</span>multiline;treat begining and end characters(^ and $)<span class="hljs-keyword">as</span> working over multiple lines <span class="hljs-comment">//多行匹配,用这个属性后$会匹配'\n'或'\r'.要匹配$本身，用\$</span></code></pre></div><h3 id="特殊字符">特殊字符</h3><table><thead><tr><th style="text-align:center">特殊字符</th><th style="text-align:center">简单说明(无特殊说明，匹配本身都是用\转义)</th></tr></thead><tbody><tr><td style="text-align:center">$</td><td style="text-align:center">匹配输入字符串的结尾位置。</td></tr><tr><td style="text-align:center">()</td><td style="text-align:center">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">(限定符)匹配前面的子表达式零次或多次。</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">(限定符)匹配前面的子表达式一次或多次。</td></tr><tr><td style="text-align:center">.</td><td style="text-align:center">匹配除换行符\n之外的任何单字符;匹配本身用\。</td></tr><tr><td style="text-align:center">?</td><td style="text-align:center">匹配前面的子表达式零次或一次，或知名一个非贪婪限定符。</td></tr><tr><td style="text-align:center">[</td><td style="text-align:center">标记一个中括号表达式的开始。</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。</td></tr><tr><td style="text-align:center">{</td><td style="text-align:center">标记限定符表达式的开始。</td></tr><tr><td style="text-align:center">¦</td><td style="text-align:center">很明显，&quot;或&quot;符号。</td></tr></tbody></table><!--<table><tr><th>特殊字符</th><th>简单说明（没特殊说明的，匹配本身都是直接用\转义）</th></tr><tr><td>$</td><td>匹配输入字符串的结尾位置。</td></tr><tr><td>()</td><td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。</td></tr><tr><td>*</td><td>(限定符)匹配前面的子表达式零次或多次。</td></tr><tr><td>+</td><td>(限定符)匹配前面的子表达式一次或多次。</td></tr><tr><td>.</td><td>匹配除换行符\n之外的任何单字符;匹配本身用\。</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次，或知名一个非贪婪限定符。</td></tr><tr><td>[</td><td>标记一个中括号表达式的开始。</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。</td></tr><tr><td>{</td><td>标记限定符表达式的开始</td></tr><tr><td>|</td><td>很明显，"或"符号</td></tr></table>--><h3 id="限定符">限定符</h3><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:left">简单说明</th></tr></thead><tbody><tr><td style="text-align:center">()</td><td style="text-align:left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。</td></tr><tr><td style="text-align:center">*</td><td style="text-align:left">(限定符)匹配前面的子表达式零次或多次。</td></tr><tr><td style="text-align:center">+</td><td style="text-align:left">(限定符)匹配前面的子表达式一次或多次。</td></tr><tr><td style="text-align:center">?</td><td style="text-align:left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。</td></tr></tbody></table><div style="color:#f92672;">这里顺带说一声，如果在markdown中直接用table标签的话要所有html代码压缩才可以，要不会多出很多&lt;br/&gt;</div><h3 id="其他元字符">其他元字符</h3><table><thead><tr><th style="text-align:center">字符</th><th>简单说明</th></tr></thead><tbody><tr><td style="text-align:center">[xyz]</td><td>字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td></tr><tr><td style="text-align:center">[^xyz]</td><td>负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、‘l’、‘i’、‘n’。</td></tr><tr><td style="text-align:center">\b</td><td>匹配一个单词边界，也就是指单词和空格间的位置。‘er\b’ 可以匹配&quot;never&quot; 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td></tr><tr><td style="text-align:center">\B</td><td>匹配非单词边界。‘er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td></tr><tr><td style="text-align:center">\d</td><td>匹配一个数字字符。等价于 [0-9]。 \D同上。</td></tr><tr><td style="text-align:center">\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。\S同上。</td></tr><tr><td style="text-align:center">\w</td><td>匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。\W同上。</td></tr><tr><td style="text-align:center">x{n}</td><td>n 是一个非负整数。匹配x的 n 次。例如，‘o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td style="text-align:center">x{n,}</td><td>n 是一个非负整数。至少匹配x的n 次。例如，‘o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。‘o{1,}’ 等价于 ‘o+’。‘o{0,}’ 则等价于 ‘o*’。</td></tr></tbody></table><!--<table><thead><tr><th>字符</th><th>简单说明</th></tr></thead><tbody><tr><td>()</td><td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。</td></tr><tr><td>*</td><td>(限定符)匹配前面的子表达式零次或多次。</td></tr><tr><td>+</td><td>(限定符)匹配前面的子表达式一次或多次。</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次，或知名一个非贪婪限定符。</td></tr></tbody></table>--><h3 id="使用正则的方法">使用正则的方法:</h3><h4 id="1-exec">1. exec</h4><p>搜索字符串制定的值，返回找到的值，如果没有匹配，返回Null</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myRe = <span class="hljs-regexp">/d(b+)d/g</span>;<span class="hljs-comment">//使用g全局匹配,符合d开始,d结尾</span><span class="hljs-keyword">var</span> myArray = myRe.exec(<span class="hljs-string">"cdbbdbsbz"</span>);<span class="hljs-comment">/*["dbbd", "bb"]*/</span><span class="hljs-keyword">var</span> myArray2 = myRe.exec(<span class="hljs-string">"a"</span>);<span class="hljs-comment">/*null*/</span></code></pre></div><h4 id="2-test">2. test()</h4><p>搜索字符串指定的值，返回真假</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myRe = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"e"</span>);<span class="hljs-built_in">console</span>.log(myRe.test(<span class="hljs-string">"The best"</span>));<span class="hljs-comment">/*true*/</span><span class="hljs-built_in">console</span>.log(myRe.test(<span class="hljs-string">"a"</span>));<span class="hljs-comment">/*false*/</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>Regular Expression</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从DocumentFragment看到GUI渲染</title>
    <link href="/2017/02/05/js/gui_engine/"/>
    <url>/2017/02/05/js/gui_engine/</url>
    
    <content type="html"><![CDATA[<p>这里主要说说<span style="color:#f92672">重绘(repaint)</span>和<span style="color:#f92672">回流(reflow)</span>的问题</p><a id="more"></a><h4 id="犹记得某个项目要求使用经典的下拉刷新功能-其中就有ajax在后面添加某些信息；">犹记得某个项目要求使用经典的下拉刷新功能，其中就有ajax在后面添加某些信息；</h4><h4 id="其中要使用documentfragmentmdn手册">其中要使用DocumentFragment<a href="https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment" target="_blank" rel="noopener">MDN手册</a></h4><p>先看下以下代码</p><div class="hljs"><pre><code class="language-javascript">window.onload = function(){/*一个大致的ajax动态获取信息并添加到DOM中的代码*//*ajax*/var xhr;if(window.XMLHttpRequest){xhr = new window.XMLHttpRequest();}else{xhr = new ActiveXObject('Microsoft.XMLHttp');/*IE6没什么X用*/}xhr.open('get',this.getAtrribute('data-url'),true);xhr.send(null);xhr.onreadystatechange = function(){if(xhr.readyState == 4 &amp;&amp; xhr.status == 200){/*核心*/var frag = document.createDocumentFragment();/*创建一个文档节点，其实和用一串字符串存储在一个变量中一样*/for(var x = 0; x&lt;10;x++){var li = document.createElement(&quot;li&quot;);li.innerHTML = &quot;List item&quot;+x;frag.appendChild(li);}Node.appendChild(frag);frag = null;/*清空Documentfragment缓存*/}}}</code></pre></div><p>上面这样写的好处就是：创建一个DocumentFragment(),这样在appendChild()的时候就只会触发一次reflow</p><p>因为暂时没有现成网站，暂时先当作一个笔记吧：</p><h3 id="回流-reflow">回流(reflow)</h3><p>Render Tree中一部分或全部因为元素尺寸、布局、隐藏等改变而需要重新构建，每个页面在一开始加载的时候都会回流，以下一些建议：1. 如要修改，尽量修改DOM中下层的class，避免上层父级class改变2. 避免使用table（一开始接触就听说这玩意有问题）3. 避免在html中设置style，尽量在外部css设置style，跟documentFragment()是一个道理</p><h3 id="重绘-repaint">重绘(repaint)</h3><p>Render Tree中一些只影响颜色、风格，最重要跟以上reflow不同的关键就是不影响DOM结构，比如一些absolute或者fixed定位元素就基本可以随便移动（假设他们的父元素不变啦）</p>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown学习记录</title>
    <link href="/2017/02/01/markdown/"/>
    <url>/2017/02/01/markdown/</url>
    
    <content type="html"><![CDATA[<p>很久不用，今天就从这里开始重新学习吧！</p><a id="more"></a><div style="color:#f92672">注意：Markdown是可以内嵌html的，所以忘了或有特殊样式就直接套html吧,比如这个</div><div style="color:#4d8fc0">注意：内嵌了html标签的，要空一行才可以接markdown,否则会出问题</div><h2 id="标题"><strong>标题</strong></h2><h3 id="有两种：">有两种：</h3><h3 id="①setext类：">①Setext类：</h3><h4 id="写法">写法:</h4><div class="hljs"><pre><code>This is an H1=============This is an H2-------------</code></pre></div><h4 id="效果">效果:</h4><h1>This is an H1</h1><h2 id="this-is-an-h2">This is an H2</h2><h3 id="②atx类：">②ATX类：</h3><h4 id="写法：行首插入1到6个-注意-后面要加一个空格">写法：行首插入1到6个#,注意#后面要加<strong>一个空格</strong>!</h4><div class="hljs"><pre><code># 这个是一级标题，前面一个`#`## 这个是二级标题，前面两个`##`</code></pre></div><h4 id="效果-v2">效果:</h4><h1>这个是一级标题，前面一个<code>#</code></h1><h2 id="这个是二级标题-前面两个">这个是二级标题，前面两个<code>##</code></h2><h2 id="列表"><strong>列表</strong></h2><h3 id="无序列表">无序列表</h3><h4 id="写法：前面用星号或加号或减号来标记">写法：前面用星号或加号或减号来标记</h4><h4 id="效果：">效果：</h4><ul><li>Red</li><li>Green</li><li>Blue</li></ul><h3 id="有序列表">有序列表</h3><h4 id="写法-v2">写法:</h4><div class="hljs"><pre><code>1. Red2. Green3. Blue</code></pre></div><h4 id="效果-v3">效果:</h4><ol><li>Red</li><li>Green</li><li>Blue</li></ol><h2 id="图片"><strong>图片</strong></h2><h4 id="写法-v3">写法:</h4><div class="hljs"><pre><code class="hljs undefined">![<span class="hljs-string">Alt text</span>](<span class="hljs-link">/path/to/img.jpg</span>)![<span class="hljs-string">Alt text</span>](<span class="hljs-link">/path/to/img.jpg "Optional title"</span>)</code></pre></div><h4 id="即：">即：</h4><ul><li>一个惊叹号 !</li><li>接着一个方括号，里面放上图片的替代文字</li><li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。</li></ul><p>这里的图片是基于这个hexo固定文件生成结构的,位于<span style="color:#f92672">public/Year/Month/Day/article_title/</span>中，所以，我只能用相对路径找到public内的css/images/图片<span style="color:#f92672">…/…/…/…/css/images/图片</span></p><h4 id="效果-v4">效果:</h4><p><img src="../../../../css/images/mp1.jpg" srcset="/img/loading.gif" alt="显示在下面的文字"></p><h2 id="代码"><strong>代码</strong></h2><h4 id="写法-v4">写法:</h4><p>1、可以用三个```包裹一段代码,第一个```后面加个<span style="color:#f92672">空格</span>，再加上代码类型：比如javascript、python等,可以高亮</p><div class="hljs"><pre><code class="hljs javascript">&lt;div style=<span class="hljs-string">"color:#eee;"</span>&gt;foo&lt;<span class="hljs-regexp">/div&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span>:</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span></code></pre></div><p>2、可以用一个`包裹一段代码<code>&lt;div style=&quot;color:#eee;&quot;&gt;foo&lt;/div&gt;</code></p><div style="text-decoration:line-through"><h4> 3、可以用4空格缩进</h4></div><div style="color:#f92672">这里很奇怪,不知道为啥↑,初步估计是html标签是不能直接tab的,如下<span style="color: #4d8fc0">链接</span>写法就可以</div><h2 id="引用"><strong>引用</strong></h2><h4 id="写法-v5">写法:</h4><p>加上 &gt;&gt;</p><blockquote><blockquote><p>This is a quote</p></blockquote></blockquote><h2 id="链接"><strong>链接</strong></h2><h4 id="写法-v6">写法:</h4><p>1、文字连接:<a href="http://xn--ses510ahtve0t" target="_blank" rel="noopener">链接文字</a>2、网址链接:<a href="http://xn--ses510ahtve0t" target="_blank" rel="noopener">http://链接网址</a>3、链接到本页锚处:<a href="#anchor_lowercase_name">link</a></p><p><span style="color:#f92672">PS:一般只对header有用,还会遵循以下原则（不清楚为什么部分不生效）:</span></p><ol><li>标点符号会被丢弃</li><li>首空格会被丢弃</li><li>大写字母会被转换为小写字母（并不会。。。）</li><li>字母之间的空格会被转换为 -  (实际上.也会被转化)</li></ol><div class="hljs"><pre><code class="hljs undefined">[<span class="hljs-string">link1</span>](<span class="hljs-link">#hello</span>)[<span class="hljs-string">link2</span>](<span class="hljs-link">#new-hello</span>)<span class="hljs-section">#Hello or &lt;a name="hello"&gt;&lt;/a&gt;</span><span class="hljs-section">#New Hello</span></code></pre></div><h4 id="效果-v5">效果:</h4><p><a href="https://www.baidu.com" target="_blank" rel="noopener">百度</a><a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a></p><p><a href="#1-12-Test">GoToTest</a>............test</p><h3 id="1-12-test">1.12 Test</h3><div style="color: #f92672">暂时记录到这里吧，差不多够用了，这些都是从网上找的教程，在此感谢那些博客主Orz</div>]]></content>
    
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My Understanding towards Promise/A+</title>
    <link href="/2017/01/07/js/js-Promise/"/>
    <url>/2017/01/07/js/js-Promise/</url>
    
    <content type="html"><![CDATA[<p>Personal comprehension about ES6 promise,including simulated promise implementation</p><a id="more"></a><h2 id="for-a-stupid-instance">For a stupid Instance</h2><p>There’s a scene that you’re going to order a cup of coffee.The pretty waitress may say ‘Please come to get your coffee later’.So this is a <div style="color:#f92672">Promise</div>.She promised that you can get a coffee soon.Besides, your waiting process is called <div style="color:#4d8fc0">pending</div>.After you sucessfully get your coffee from the waitress,this’s called <div style="color:#4d8fc0">resolved(fulfilled)</div>.But it’s possible that her coffee beans are out of <a href="http://stock.As" target="_blank" rel="noopener">stock.As</a> a result you can’t get your coffee,so this is <div style="color:#4d8fc0">rejected</div>.Furthermore,after you got the promise,the following operation is called  <div style="color:#f92672">then</div>;</p><h2 id="definition">Definition</h2><p>The Promise object represents the eventual completion (or failure) of an asynchronous operation, and its resulting value.<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">MDN</a></p><p>Essentially, a promise is a returned object to which you attach callbacks, instead of passing callbacks into a function.(That’s why it can avoid callback hell,once you call then() method,it will implicitly <div style="color:#f92672">create a new promise object and return it;</div> ) <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises" target="_blank" rel="noopener">MDN</a></p><h3 id="more-advantages">More advantages:</h3><p>Unlike old-style passed-in callbacks, a promise comes with some guarantees:</p><div class="hljs"><pre><code>1. Callbacks will never be called before the completion of the current run of the JavaScript event loop.2. Callbacks added with .then even after the success or failure of the asynchronous operation, will be called, as above.3. Multiple callbacks may be added by calling .then several times, to be executed independently in insertion order.</code></pre></div><p>But the most immediate benefit of promises is chaining.</p><p>For more detail:<a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise A+</a></p><p>Following my code about a simple promise implementation:</p><div class="hljs"><pre><code class="language-javascript"></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>From SetTimeout to Js Scope</title>
    <link href="/2017/01/01/js/js-Scope/"/>
    <url>/2017/01/01/js/js-Scope/</url>
    
    <content type="html"><![CDATA[<p>There’s a chinese word ‘温故而知新’.</p><a id="more"></a><p>Today I saw a code:</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)&#123;    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timer</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(i);    &#125;,i*<span class="hljs-number">1000</span>);&#125;</code></pre></div><p>And the result is:</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-number">34</span><span class="hljs-comment">//a random number,it's different any time after u reopen your browser</span><span class="hljs-number">6</span><span class="hljs-comment">//run 5 times</span></code></pre></div><p>Directly go to <a href="#The-1stQ-solution">Solution</a> !!!</p><p>To explain above,We begin with some of the characteristics of <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout" target="_blank" rel="noopener">setTimeout</a>##Syntax</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">var</span> timeoutID = scope.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>[,<span class="hljs-title">delay</span>,<span class="hljs-title">param1</span>,<span class="hljs-title">param2</span>]);</span></code></pre></div><h2 id="return-value">Return value</h2><p>we should know about the setTimeout() return a <strong>timeoutID</strong>.</p><ol><li>this is an positive integer value</li><li>this value identifies the timer created by setTimeout()(this is the reason why it’s different all the time)</li><li>setTimeout() and setInterval() share the same pool of IDs,which means setInterval() may effect the timer if u use them at the same object(window or a worker);</li></ol><h2 id="this-problem">“This” problem</h2><p>Let’s first see a simpler example:</p><div class="hljs"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">this</span>.fuck = <span class="hljs-literal">false</span>;    Console.log(<span class="hljs-string">"OMG!"</span>);    <span class="hljs-keyword">var</span> timer = setTimeout((<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">this</span>.fuck = <span class="hljs-literal">true</span>;        Console.log(<span class="hljs-string">"timeout Fuck!"</span>);    &#125;),<span class="hljs-number">3000</span>);&#125;)</code></pre></div><p>The problem of above example is :The <span style="color:#f92672">this</span> always refers to the<span style="color:#f92672">this</span> of the current scope,which changes any time I wrap something in <span style="color:#f92672">function(){}</span></p><p>So there is###one solution:</p><div class="hljs"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> symbol = <span class="hljs-keyword">this</span>;<span class="hljs-comment">//now refers to the Window object </span>    symbol.fuck = <span class="hljs-literal">false</span>;    Console.log(<span class="hljs-string">"OMG!"</span>);    <span class="hljs-keyword">var</span> timer = setTimeout((<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        symbol.fuck = <span class="hljs-literal">true</span>;<span class="hljs-comment">//still refers to the Window Object</span>        Console.log(<span class="hljs-string">"timeout Fuck!"</span>);    &#125;),<span class="hljs-number">3000</span>);&#125;)</code></pre></div><p>###SecondES5 Function.prototype.bind()</p><div class="hljs"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">this</span>.fuck = <span class="hljs-literal">false</span>;    Console.log(<span class="hljs-string">"OMG!"</span>);    <span class="hljs-keyword">var</span> timer = setTimeout((<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">this</span>.fuck = <span class="hljs-literal">true</span>;        Console.log(<span class="hljs-string">"timeout Fuck!"</span>);    &#125;).bind(<span class="hljs-keyword">this</span>),<span class="hljs-number">3000</span>);<span class="hljs-comment">//bind the scope</span>&#125;)</code></pre></div><p>###ThirdES6 [Arrow Function()]</p><div class="hljs"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">this</span>.fuck = <span class="hljs-literal">false</span>;    Console.log(<span class="hljs-string">"OMG!"</span>);    <span class="hljs-keyword">var</span> timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span> &#123;        <span class="hljs-keyword">this</span>.fuck = <span class="hljs-literal">true</span>;        Console.log(<span class="hljs-string">"timeout Fuck!"</span>);    &#125;,<span class="hljs-number">3000</span>);<span class="hljs-comment">//no binding in Arrow Functions!!!</span>&#125;)</code></pre></div><p>I think now it’s clear that why the first code resulted in that,The solution:</p><p>###The 1stQ solution</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)&#123;        (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>)</span>&#123;<span class="hljs-comment">//1.set the self-invoking anonymous function to set the scope</span>        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timer</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(i);        &#125;,i*<span class="hljs-number">1000</span>);    &#125;)(i)<span class="hljs-comment">//2.Then call the value of i </span>&#125;</code></pre></div><p>Also u can try this,result is the same:</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)&#123;    setTimeout((<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timer</span>(<span class="hljs-params">i</span>)</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-comment">//set return value as an anonymous function</span>            <span class="hljs-built_in">console</span>.log(i);        &#125;    &#125;)(i),i*<span class="hljs-number">1000</span>);&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于javascript中时间的一系列函数</title>
    <link href="/2017/01/01/js/js-time/"/>
    <url>/2017/01/01/js/js-time/</url>
    
    <content type="html"><![CDATA[<p>很久以前就很混乱对这个，最近实习的时候突然要用到，现在来做个总结</p><a id="more"></a><p>总结之前先说明几个名词:</p><h4 id="1-span-style-color-f92672-时间戳-span">1、<span style="color:#f92672">时间戳</span></h4><p>指的是<div style="color:#f92672">格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。</div>而这个东西的用处挺大的，比如：在书面合同中，文件签署的日期和签名一样均是十分重要的防止文件被伪造和篡改的关键性内容。数字时间戳服务（DTS：digital time stamp service）是网上电子商务安全服务项目之一，能提供电子文件的日期和时间信息的安全保护等等。</p><h4 id="2-span-style-color-f92672-utc-span">2、<span style="color:#f92672">UTC</span></h4><p>协调世界时（英：Coordinated Universal Time ，法：Temps Universel Coordonné），又称世界统一时间，世界标准时间，国际协调时间。英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称UTC。中国大陆、中国香港、中国澳门、中国台湾、蒙古国、新加坡、马来西亚、菲律宾、西澳大利亚州的时间与UTC的时差均为+8，也就是UTC+8。</p><h4 id="3-span-style-color-f92672-gmt-span">3、<span style="color:#f92672">GMT</span></h4><p>格林尼治标准时间（Greenwich Mean Time，GMT）是指位于伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。</p><p>说了那么多，现在就先来看看javascript中<span style="color:#f92672">Date</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank" rel="noopener">MDN手册</a>这个对象吧。</p><h4 id="创建对象"><strong>创建对象</strong></h4><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myDate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<span class="hljs-comment">//返回当天的日期和时间</span></code></pre></div><h5 id="语法">语法</h5><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]]);<span class="hljs-keyword">var</span> myDate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2016</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)<span class="hljs-comment">//for example</span></code></pre></div><h5 id="结果：">结果：</h5><div class="hljs"><pre><code>Tue Mar 01 2016 01:10:00 GMT+0800 (ä¸­å½æ åæ¶é´)</code></pre></div><p><span style="color:#f92672">你可能已经注意到<strong>月份</strong>中是要加1，才是最终的时间,因为原本的Date的月份是从0开始算的</span></p><p>有趣的是：溢出了也可以用，比如：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myDate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2016</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">70</span>)<span class="hljs-comment">//Second overflow</span><span class="hljs-keyword">var</span> myDate2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2015</span>,<span class="hljs-number">14</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)<span class="hljs-comment">//Month overflow</span></code></pre></div><p>结果和上面的是一模一样</p><h4 id="常用方法">常用方法:</h4><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> Date1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();Date1.getDate();<span class="hljs-comment">//返回一个月中的某一天(1~31)</span>Date1.getDay();<span class="hljs-comment">//返回一周中的某一天(0~6)</span>Date1.getMonth();<span class="hljs-comment">//返回月份(0~11)</span>Date1.getFullYear();<span class="hljs-comment">//四位数返回年份</span><span class="hljs-comment">/*还可以根据世界时返回时间*/</span>Date1.getUTCDate();<span class="hljs-comment">//同上，多余就不写了</span></code></pre></div><h4 id="重要方法">重要方法:</h4><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> Date2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();Date2.parse();<span class="hljs-comment">//这个主要用来计算时间戳,得出单位是ms</span><span class="hljs-keyword">var</span> d = <span class="hljs-built_in">Date</span>.UTC(<span class="hljs-number">2005</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>);<span class="hljs-comment">//这个Date.UTC()是静态方法，不可以通过Date对象调用</span><span class="hljs-comment">//只能用构造函数Date()调用</span><span class="hljs-comment">//也是计算时间戳，得出单位也是ms</span>Date2.toString();<span class="hljs-comment">//挺明显的，转换成string</span>Date2.toLocaleString();<span class="hljs-comment">//根据本地时间，转换成字符串</span><span class="hljs-comment">//举例:</span><span class="hljs-comment">//var born = new Date("July 21, 1983 01:15:00");</span><span class="hljs-comment">//结果:</span><span class="hljs-comment">//1983/7/21 上午1:15:00</span></code></pre></div><h5 id="div-style-color-f92672-其实实际工作运用中就很少用到原生的方法-一般直接套用别人的format函数-而这些format函数中用到一些-strong-正则匹配-strong-这个下次再说-div"><div style="color:#f92672">  其实实际工作运用中就很少用到原生的方法，一般直接套用别人的format函数，而这些format函数中用到一些<strong>正则匹配</strong>，这个下次再说…</div></h5>]]></content>
    
    
    
    <tags>
      
      <tag>Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css-clip问题</title>
    <link href="/2016/01/07/js/css-clip/"/>
    <url>/2016/01/07/js/css-clip/</url>
    
    <content type="html"><![CDATA[<p>今天在网上看见一个很好玩的属性<span style="color:#f92672;font-weight: bold;font-size: 2rem;">clip</span> <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/clip" target="_blank" rel="noopener">MDN手册</a></p><a id="more"></a><p>主要是看见这个东西可以用在图片切换上面，实现一个简单的裁剪切换效果</p><h3 id="summary">Summary:</h3><blockquote><p>The clip CSS property defines what portion of an element is visible. The clip property applies only to absolutely positioned elements, that is elements with position:absolute or position:fixed.</p></blockquote><h5 id="意思就是这玩意儿只能用在-span-style-color-f92672-绝对定位-span-上面">意思就是这玩意儿只能用在<span style="color:#f92672">绝对定位</span>上面.</h5><h4 id="语法">语法:</h4><div class="hljs"><pre><code class="hljs undefined">clip:rect(<span class="hljs-built_in">top</span> <span class="hljs-built_in">right</span> <span class="hljs-built_in">bottom</span> <span class="hljs-built_in">left</span>)</code></pre></div><p>顺时针，是不是和<strong>margin</strong>、<strong>padding</strong>的一样呢？</p><div style="color:#f92672">注意：要满足 top < bottom 和left < right </div><div style="color:#4d8fc0">注意：其中bottom和top一样，是以上边缘为开始计算距离;同样，right是和left一样，都是从左边缘算起</div><p>同时，取值<strong>auto</strong>或不满足上面条件的时候，rect就不显示。</p><p>从以上特性看来，好像是可以实现css sprite的效果，而且不用background-position，兼容性得到大幅度提升!</p><p>然而我并不想做那个，我自己做了一个图片切换的demo:<a href="https://codepen.io/doujohner/pen/QNrGZw" target="_blank" rel="noopener">点我</a></p><h5 id="原理很简单-就是从横截面减少right值">原理很简单，就是从横截面减少right值。</h5>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从setTimeout()看到js异步机制</title>
    <link href="/2016/01/05/js/js-async/"/>
    <url>/2016/01/05/js/js-async/</url>
    
    <content type="html"><![CDATA[<h3 id="格式">格式</h3><div class="hljs"><pre><code>var timeoutID = window.setTimeout(func, [delay, param1, param2, ...])</code></pre></div><p>指的是若干毫秒后执行func，大概是一个闹钟的功能; <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout" target="_blank" rel="noopener">MDN手册</a></p><a id="more"></a><h4 id="值得注意的问题">值得注意的问题</h4><p>以前想过setTimeout(func,0)指的是不是立即执行呢？下面看个例子:</p><div class="hljs"><pre><code class="hljs javascript">alert(<span class="hljs-number">1</span>);setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;alert(<span class="hljs-number">2</span>);&#125;,<span class="hljs-number">0</span>);alert(<span class="hljs-number">3</span>);</code></pre></div><p>结果却是</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-number">1</span><span class="hljs-number">3</span><span class="hljs-number">2</span></code></pre></div><p>是不是感到很奇怪，这个意思就是setTimeout(func,0)并不是立即执行;</p><p>在网上查了资料，发现这个要从<span style="color:#f92672">js引擎</span>说起</p><h4 id="js引擎的单线程性">js引擎的单线程性</h4><p>首先区分两个概念:<span style="color:#f92672">js引擎</span>和<span style="color:#f92672">浏览器内核</span></p><p>js引擎是单线程的这个没错，但是，就因为js引擎是单线程的，它没法再为其他功能服务；同时，<span style="color:#f92672">浏览器是多线程的</span>,这就说的通了：比如浏览器事件触发、定时器计时、网络请求、渲染等都是由浏览器内核分配的其他线程完成的，js引擎只占其中一个线程。</p><p>再举个经典例子：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> end = ture;<span class="hljs-built_in">window</span>.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;end = <span class="hljs-literal">false</span>;&#125;,<span class="hljs-number">1000</span>);<span class="hljs-keyword">while</span>(end);alert(<span class="hljs-string">'end'</span>);</code></pre></div><p>上面的例子结果就是 while(end)处死循环，永远到不了alert(‘end’)，意思就是setTimeout里边的函数没有执行;</p><p>下面就引入这个事件队列的问题，用一张图表示：<img src="../../../../css/images/jsengine.jpg" srcset="/img/loading.gif" alt="js事件队列"></p><p>js是基于事件驱动的语言,所以遵循一个叫事件队列的机制。从图中可看出浏览器的各种各样的线程，比如事件触发器、网络请求、定时器等，js引擎处理到与其他线程相关的代码，会把他们分发到其他线程，他们处理完后需要js引擎计算时就是在事件队列添加一个任务。然而在这个过程中，js并不会阻塞代码等待其他线程执行完毕，而是直接跳过这个分发给别的进程的代码，执行下一串代码。</p><p>很明显上面while(end)的死循环问题就得到解决，执行到setTimeout的时候，把这个东西（定时器）扔到了事件队列后边，然后执行while(end)但这时end是true，所以造成死循环，与第一个setTimeout(func,0)的例子一样得到解释。</p><div style="color:#f92672">PS:实现异步加载</div>1.现代浏览器prefetch（预加载）优化，即浏览器会另开新线程，提前下载js、css文件，prefetch不会改变dom结构.<div class="hljs"><pre><code>&lt;link rel=&quot;prefetch&quot; href=&quot;http://&quot;&gt; &lt;!--利用空余时间加载剩下的网页--&gt;</code></pre></div><p>2.HTML5的defer async标签实现异步加载</p><div class="hljs"><pre><code class="hljs javascript">&lt;script defer="true" type="text/javascript"&gt;&lt;/script&gt;&lt;!--不等js加载完成就加载后边的图片--&gt;&lt;script async="true" type="text/javascript"&gt;&lt;/script&gt;</code></pre></div><p>3.动态加载js</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.write(<span class="hljs-string">"&lt;script src="</span>a.js<span class="hljs-string">"&gt;&lt;/script&gt;"</span>);<span class="hljs-comment">/*还有修改src路径、创建script标签再将其放进DOM中，这些都是对DOM操作*/</span></code></pre></div><h4 id="settimeout-func-0-特殊功效">setTimeout(func,0)特殊功效</h4><p><span style="color:#f92672;font-size:1.8rem">换个角度想，是不是可以用setTimeout(func,0)强行将func放到队列后边延迟执行呢？！这也算是个小技巧吧？</span></p><p>而这个技巧在同样情况下（打开一个标签，就测试环境差不多）不同浏览器上出现的时间会不同，我个人认为这也可以看出浏览器的性能;</p>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
