

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content>
  <meta name="author" content="Doujohner">
  <meta name="keywords" content>
  <title>Golang Context - 兜的破烂</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/darcula.min.css">
  

  


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2019-06-21 11:40" pubdate>
      June 21, 2019 am
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      3.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      56
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">Golang Context</h1>
            
            <div class="markdown-body" id="post-body">
              <p>Golang出色的协程为其增添不少色彩，而Context在协程间的协作，同步发挥了很大的作用</p>
<a id="more"></a>
<p><img src="/img/golangContextMascot.jpg" srcset="/img/loading.gif" alt="Context"></p>
<h2 id="作用">作用</h2>
<p>开头已经说道，Context主要用于在goroutine之间传递上下文信息，而这些信息包括key-value pair，cancel信号，timeout信号等
http包，sql包里面都用到了context，比如http包里面，API可以由外部执行cancel操作，可以设置timeout信号来cancel
http请求服务如果过慢，则可以用timeout进行释放资源
举例：获取商品的默认库存数量等</p>
<p><strong><em>参考 go在今日头条的实践</em></strong></p>
<p>另外，之前的<img src="/Concurrency" srcset="/img/loading.gif" alt="Concurrency"> 有谈到协程之前如何同步（比如 channel和select）
但如果要共享一些全局变量，或者需要同时被关闭，就可以用context来实现</p>
<h2 id="源码">源码</h2>
<p>可以参考官方blog<img src="https://blog.golang.org/context" srcset="/img/loading.gif" alt="context blog"></p>
<p>整体提供了：</p>
<table>
  <tr>
    <th>Name</th>
    <th>Type</th>
    <th>Usage</th>
    <th>Comment</th>
  </tr>
  <tr>
    <td>Context</td>
    <td>Interface</td>
    <td>Define four methods:<br><br>Deadline() (deadline time.Time, ok bool)<br>Done()&lt;-chan struct{}<br>Err() error<br>Value(key interface{}) interface{}</td>
    <td></td>
  </tr>
  <tr>
    <td>emptyCtx</td>
    <td>struct</td>
    <td>Also define interface, but it's empty</td>
    <td></td>
  </tr>
  <tr>
    <td>CancelFunc</td>
    <td>func</td>
    <td>cancel func</td>
    <td></td>
  </tr>
  <tr>
    <td>CancelCtx</td>
    <td>struct</td>
    <td>mark as cancelable</td>
    <td rowspan="3">都有实现自己的方法<br><br><br>Cancel()</td>
  </tr>
  <tr>
    <td>timerCtx</td>
    <td>struct</td>
    <td>canceled if timeout</td>
  </tr>
  <tr>
    <td>valueCtx</td>
    <td>struct</td>
    <td>save K-V pair</td>
  </tr>
  <tr>
    <td>Background</td>
    <td>func</td>
    <td>Background returns a non-nil, empty Context. It is never canceled, has no<br>values, and has no deadline. It is typically used by the main function,<br> initialization, and tests, and as the top-level Context for incoming requests.</td>
    <td>返回空的context，常用做top-level context</td>
  </tr>
  <tr>
    <td>TODO</td>
    <td>func</td>
    <td>TODO returns a non-nil, empty Context.<br>Code should use context.TODO when it' s unclear which Context to use or it is not yet available<br> (because the surrounding function has not yet been extended to accept a Context<br>parameter). TODO is recognized by static analysis tools that determine<br>whether Contexts are propagated correctly in a program.</td>
    <td>返回空的context</td>
  </tr>
  <tr>
    <td>WithCancel</td>
    <td>func</td>
    <td>Based on parent context, generate a cancelable context</td>
    <td>基于父context生成可取消context<br>(自然就会调用下面的propagateCancel)</td>
  </tr>
  <tr>
    <td>newCancelCtx</td>
    <td>func</td>
    <td>create a cancelable context</td>
    <td>返回一个CancelCtx</td>
  </tr>
  <tr>
    <td>propagateCancel</td>
    <td>func</td>
    <td>propagateCancel arranges for child to be canceled</td>
    <td>向下传递context的关系</td>
  </tr>
  <tr>
    <td>parentCancelCtx</td>
    <td>func </td>
    <td>parentCancelCtx follows a chain of parent references until it finds a<br><br>*cancelCtx. This function understands how each of the concrete types in this<br><br>package represents its parent.</td>
    <td>找到第一个可取消的父节点</td>
  </tr>
  <tr>
    <td>removeChild</td>
    <td>func</td>
    <td>remove child</td>
    <td>去掉父节点的孩子节点</td>
  </tr>
  <tr>
    <td>init</td>
    <td>func</td>
    <td>init this package</td>
    <td></td>
  </tr>
  <tr>
    <td>WithDeadLine</td>
    <td>func</td>
    <td>Create a context with deadline</td>
    <td rowspan="3">同理，都是为了创建不同功能的context</td>
  </tr>
  <tr>
    <td>WithTimeout</td>
    <td>func</td>
    <td></td>
  </tr>
  <tr>
    <td>WIthValue</td>
    <td>func</td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
</table>
<p>context里面的类图：</p>
<p><img src="/img/go_context.png" srcset="/img/loading.gif" alt="contextClass"></p>
<p>如上图所示，展开</p>
<h3 id="interface">Interface</h3>
<h4 id="context">Context</h4>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span> &#123;
	<span class="hljs-comment">//deadline会返回 这个context应该被取消的时间， 如果ok==false，指没有deadline设置（即返回deadline的时间或者返回没有设置deadline）</span>
	Deadline() (deadline time.Time, ok <span class="hljs-keyword">bool</span>)
    <span class="hljs-comment">//返回一个关闭的只读channel ，代表着这个context应该被cancel或者到了deadline</span>
    
	Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;
    <span class="hljs-comment">//channel Done（）关闭后，返回关闭原因</span>
	Err() error
    <span class="hljs-comment">//获取key对应的value值</span>
	Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125;
&#125;</code></pre></div>
<p>关于 <strong>Done()</strong> 需要注意的是这个是一个<strong>只读</strong> 的 <strong>channel</strong>！</p>
<ol>
<li>只有在其被关闭后，才可以从里面读出值， 而且这个值是相应类型的 <strong>零值</strong>，所以goroutine可以在其关闭后读出零值，判断后继续做后面的事情</li>
<li>其具有关联性，即所有用到这个context的goroutine，一旦有一方关闭了(Done())，其他的也会被关闭</li>
</ol>
<h4 id="canceler">Canceler</h4>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// A canceler is a context type that can be canceled directly. The</span>
<span class="hljs-comment">// implementations are *cancelCtx and *timerCtx.</span>
<span class="hljs-keyword">type</span> canceler <span class="hljs-keyword">interface</span> &#123;
	cancel(removeFromParent <span class="hljs-keyword">bool</span>, err error)
	Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;
&#125;</code></pre></div>
<p>源码说的很清楚了，这个接口会被 *cancelCtx和 *timerCtx 实现</p>
<p>//todo 为啥 Canceler里面有 cancel()，而Context里面 没有呢,是种设计问题吧？context有一些不会用到cancel，比如emptyCtx？</p>
<h3 id="struct">struct</h3>
<h4 id="emptyctx">emptyCtx</h4>
<p>这个暂时略过，只要知道把这个当成一个占位符即可，有些函数可能以后会用到context，暂时把它当作一个参数传进去而已
它的相关方法有background() 和 TODO()</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// An emptyCtx is never canceled, has no values, and has no deadline. It is not</span>
<span class="hljs-comment">// struct&#123;&#125;, since vars of this type must have distinct addresses.</span></code></pre></div>
<h4 id="cancelctx">cancelCtx</h4>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// A cancelCtx can be canceled. When canceled, it also cancels any children</span>
<span class="hljs-comment">// that implement canceler.</span>
<span class="hljs-keyword">type</span> cancelCtx <span class="hljs-keyword">struct</span> &#123;
	Context
	mu       sync.Mutex            <span class="hljs-comment">// protects following fields</span>
	done     <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;         <span class="hljs-comment">// created lazily, closed by first cancel call</span>
	children <span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">// set to nil by the first cancel call</span>
	err      error                 <span class="hljs-comment">// set to non-nil by the first cancel call</span>
&#125;</code></pre></div>
<p>这个cancelCtx 有实现了接口 <strong>Context</strong>
我们注意到源码中说到 done是 created lazily，即这个不是初始化就会有;发现这个在其下的Done()方法里面才会初始化：</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span> <span class="hljs-title">Done</span><span class="hljs-params">()</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">struct</span></span>&#123;&#125; &#123;
	c.mu.Lock()
	<span class="hljs-keyword">if</span> c.done == <span class="hljs-literal">nil</span> &#123;
		c.done = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<span class="hljs-comment">//这里</span>
	&#125;
	d := c.done
	c.mu.Unlock()
	<span class="hljs-keyword">return</span> d
&#125;</code></pre></div>
<p>前面说到 这个 <strong>&lt;-chan struct{}</strong> 指的是只读 channel，在其他地方如果读取的话（还没关闭）会block住</p>
<p>紧接着**cancel()**方法</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// cancel closes c.done, cancels each of c's children, and, if</span>
<span class="hljs-comment">// removeFromParent is true, removes c from its parent's children.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span> <span class="hljs-title">cancel</span><span class="hljs-params">(removeFromParent <span class="hljs-keyword">bool</span>, err error)</span></span> &#123;
	<span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-built_in">panic</span>(<span class="hljs-string">"context: internal error: missing cancel error"</span>)
	&#125;
	c.mu.Lock()
	<span class="hljs-keyword">if</span> c.err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">//前面说道err是当timeout或者cancel的时候会添加，所以有err就一定是被取消了（var Canceled = errors.New("context canceled")）</span>
		c.mu.Unlock()
		<span class="hljs-keyword">return</span> <span class="hljs-comment">// already canceled</span>
	&#125;
	c.err = err
	<span class="hljs-keyword">if</span> c.done == <span class="hljs-literal">nil</span> &#123;
		c.done = closedchan <span class="hljs-comment">//var closedchan = make(chan struct&#123;&#125;)</span>
	&#125; <span class="hljs-keyword">else</span> &#123;
		<span class="hljs-built_in">close</span>(c.done)
	&#125;
	<span class="hljs-keyword">for</span> child := <span class="hljs-keyword">range</span> c.children &#123;<span class="hljs-comment">//loop所有的children，每个都调用cancel（）</span>
		<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> acquiring the child's lock while holding parent's lock.//为啥要锁住呢，golang里面没有可重入锁，所以child和parent的锁都是分开的</span>
		child.cancel(<span class="hljs-literal">false</span>, err)
	&#125;
	c.children = <span class="hljs-literal">nil</span><span class="hljs-comment">//把children字段设为nil</span>
	c.mu.Unlock()

	<span class="hljs-keyword">if</span> removeFromParent &#123;<span class="hljs-comment">//从父context移除自己</span>
		removeChild(c.Context, c)
	&#125;
&#125;</code></pre></div>
<p>源码注释写着</p>
<ol>
<li>cancel会关闭掉 done这个channel，还会cancel掉c的所有children</li>
<li>如果removeFromparent 是true，最后调用removeChild()</li>
</ol>
<h5 id="cancel-方法的流程：">Cancel（）方法的流程：</h5>
<ol>
<li>关闭c.Done() channel，然后不断地cancel它的子节点</li>
<li>并从父节点移除自己（removeFromParent）</li>
</ol>
<p>自然地，我们先看看removeChild()函数</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// removeChild removes a context from its parent.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeChild</span><span class="hljs-params">(parent Context, child canceler)</span></span> &#123;
	p, ok := parentCancelCtx(parent)<span class="hljs-comment">//拿出父context，这里是p</span>
	<span class="hljs-keyword">if</span> !ok &#123;
		<span class="hljs-keyword">return</span>
	&#125;
	p.mu.Lock()
	<span class="hljs-keyword">if</span> p.children != <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-built_in">delete</span>(p.children, child)<span class="hljs-comment">//直接从map里面删除这个child（删除自己）</span>
	&#125;
	p.mu.Unlock()
&#125;</code></pre></div>
<p><del>PS：里面的parentCancelCtx（）后来发现问题出在 valueCtx上面，我们放在 <a href>valueCtx</a> 讲 </del></p>
<h5 id="withcancel-流程：">WithCancel（）流程：</h5>
<p>我们回到上面的<strong>cancel()</strong> 方法，输入的removeFromParent什么时候是true or false呢，全局查找后发现在**WithCancel()**里面有用到，
同时这也是一个Export出去（大写）的方法，目的是创建一个可cancel的Context：</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// A CancelFunc tells an operation to abandon its work.</span>
<span class="hljs-comment">// A CancelFunc does not wait for the work to stop.</span>
<span class="hljs-comment">// After the first call, subsequent calls to a CancelFunc do nothing.</span>
<span class="hljs-keyword">type</span> CancelFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>

<span class="hljs-comment">// WithCancel returns a copy of parent with a new Done channel. The returned</span>
<span class="hljs-comment">// context's Done channel is closed when the returned cancel function is called</span>
<span class="hljs-comment">// or when the parent context's Done channel is closed, whichever happens first.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Canceling this context releases resources associated with it, so code should</span>
<span class="hljs-comment">// call cancel as soon as the operations running in this Context complete.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithCancel</span><span class="hljs-params">(parent Context)</span> <span class="hljs-params">(ctx Context, cancel CancelFunc)</span></span> &#123;
	c := newCancelCtx(parent)<span class="hljs-comment">//这个就是复制parent</span>
	propagateCancel(parent, &amp;c)
	<span class="hljs-keyword">return</span> &amp;c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">true</span>, Canceled) &#125;
&#125;</code></pre></div>
<ol>
<li>传入parent Context（一般是background），返回一个parentcontext的复制，这个parent contex有 <strong>新的Done channel</strong></li>
<li>这个新（复制）的Done channel会在两种情况被关闭（不管哪个先发生）：
返回的cancel CancelFunc （复制的） 被called （注意，<strong>CancelFunc只能被调用一次，接下来的都会do nothing</strong>）
parent context的 Done channel被关闭</li>
</ol>
<p><strong>那么删除前该怎么办（调用返回的cancel CancelFunc前），直接断开当前context和其parent的链接？</strong>
不行，还要把当前context的children全部cancel掉：
这里走到propagateCancel()函数</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// propagateCancel arranges for child to be canceled when parent is.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">propagateCancel</span><span class="hljs-params">(parent Context, child canceler)</span></span> &#123;
	<span class="hljs-keyword">if</span> parent.Done() == <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">//没有初始化操作，即没有调用Done()操作，所以自然不存在cancel</span>
		<span class="hljs-keyword">return</span> <span class="hljs-comment">// parent is never canceled</span>
	&#125;
	<span class="hljs-keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;
		p.mu.Lock()
		<span class="hljs-keyword">if</span> p.err != <span class="hljs-literal">nil</span> &#123;
            <span class="hljs-comment">// parent has already been canceled</span>
            
			child.cancel(<span class="hljs-literal">false</span>, p.err)<span class="hljs-comment">//这里传入的就是false，因为父context已经被cancel掉了（父与当前child的链接断开），只需要把child和其下面的</span>
		&#125; <span class="hljs-keyword">else</span> &#123;
			<span class="hljs-keyword">if</span> p.children == <span class="hljs-literal">nil</span> &#123;
				p.children = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>&#123;&#125;)
			&#125;
			p.children[child] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;
		&#125;
		p.mu.Unlock()
	&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果没有找到parent context（它自己是空的），就新建一个goroutine监视parent context或者child context的done信号</span>
		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
			<span class="hljs-keyword">select</span> &#123;
			<span class="hljs-keyword">case</span> &lt;-parent.Done():<span class="hljs-comment">//如果找不到父节点，这个就不会调用</span>
				child.cancel(<span class="hljs-literal">false</span>, parent.Err())
			<span class="hljs-keyword">case</span> &lt;-child.Done():<span class="hljs-comment">//可能父节点取消了，这个会重复让子节点再取消一次</span>
			&#125;
		&#125;()
	&#125;
&#125;</code></pre></div>
<p>从源码知道，propagateCancel()主要目的是当parent被cancel，把child给取消;（跟<strong>cancel（）方法重叠？？？</strong>）
会不断的传播传播下去，把parent的children字段全部设为空的struct</p>
<h4 id="parentcancelctx特殊性">parentCancelCtx特殊性</h4>
<p>之前说到的在这个parentCancelCtx() for循环里面，万一把当前context嵌套在一个struct里面，</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// parentCancelCtx follows a chain of parent references until it finds a</span>
<span class="hljs-comment">// *cancelCtx. This function understands how each of the concrete types in this</span>
<span class="hljs-comment">// package represents its parent.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parentCancelCtx</span><span class="hljs-params">(parent Context)</span> <span class="hljs-params">(*cancelCtx, <span class="hljs-keyword">bool</span>)</span></span> &#123;
	<span class="hljs-keyword">for</span> &#123;<span class="hljs-comment">//很奇怪？？？为啥要for呢？？？</span>
		<span class="hljs-keyword">switch</span> c := parent.(<span class="hljs-keyword">type</span>) &#123;
		<span class="hljs-keyword">case</span> *cancelCtx:
			<span class="hljs-keyword">return</span> c, <span class="hljs-literal">true</span>
		<span class="hljs-keyword">case</span> *timerCtx:
			<span class="hljs-keyword">return</span> &amp;c.cancelCtx, <span class="hljs-literal">true</span>
		<span class="hljs-keyword">case</span> *valueCtx:
			parent = c.Context<span class="hljs-comment">//for的问题在这里</span>
		<span class="hljs-keyword">default</span>:
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>
		&#125;
	&#125;
&#125;</code></pre></div>
<h4 id="valuectx">valueCtx</h4>
<p>结构体：</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// A valueCtx carries a key-value pair. It implements Value for that key and</span>
<span class="hljs-comment">// delegates all other calls to the embedded Context.</span>
<span class="hljs-keyword">type</span> valueCtx <span class="hljs-keyword">struct</span> &#123;
	Context
	key, val <span class="hljs-keyword">interface</span>&#123;&#125;
&#125;</code></pre></div>
<p>一个简单的kv结构，但是一个ctx只支持一对kv，多了的话会构成一颗<strong>树型</strong>的结构</p>
<p>首先可以确认它是一个<strong>Context</strong> ，它的独立方法只有两个，其他都是继承context：</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *valueCtx)</span> <span class="hljs-title">String</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;
	<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">"%v.WithValue(%#v, %#v)"</span>, c.Context, c.key, c.val)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *valueCtx)</span> <span class="hljs-title">Value</span><span class="hljs-params">(key <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;
	<span class="hljs-keyword">if</span> c.key == key &#123;
		<span class="hljs-keyword">return</span> c.val
	&#125;
	<span class="hljs-keyword">return</span> c.Context.Value(key)
&#125;</code></pre></div>
<p>Value（）的方法是取出对应key的value，但返回值是 <strong>c.Context.Value(key)</strong>，明显是递归调用，
其会一直往它的parent context查找，key是否等于输入的key，一直到终点（background）
前面也说到 <strong>background=new（emptyCtx）</strong>，所以在终点调用的其实是**emptyCtx.Value()**返回的是nil值</p>
<p>Export出去的创建一个valueCtx的方法：</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// WithValue returns a copy of parent in which the value associated with key is</span>
<span class="hljs-comment">// val.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Use context Values only for request-scoped data that transits processes and</span>
<span class="hljs-comment">// APIs, not for passing optional parameters to functions.</span>

<span class="hljs-comment">//这里很明白地说明了，context值是被设计为在进程间或者API间request的存储值，而不是为了传入一些可选的参数给函数</span>

<span class="hljs-comment">// The provided key must be comparable and should not be of type</span>
<span class="hljs-comment">// string or any other built-in type to avoid collisions between</span>
<span class="hljs-comment">// packages using context. Users of WithValue should define their own</span>
<span class="hljs-comment">// types for keys. </span>
<span class="hljs-comment">//还要注意这里，WithValue的key必须是可比较的，不能是string或者其他built-in type，目的是避免不同用的context包的冲突</span>

<span class="hljs-comment">//To avoid allocating when assigning to an</span>
<span class="hljs-comment">// interface&#123;&#125;, context keys often have concrete type</span>
<span class="hljs-comment">// struct&#123;&#125;. Alternatively, exported context key variables' static</span>
<span class="hljs-comment">// type should be a pointer or interface.</span>
<span class="hljs-comment">//为了避免？？？ context的key一般是有确切的类型struct，或者是exported出去的key静态类型为指针或者interface</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithValue</span><span class="hljs-params">(parent Context, key, val <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">Context</span></span> &#123;
	<span class="hljs-keyword">if</span> key == <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-built_in">panic</span>(<span class="hljs-string">"nil key"</span>)
	&#125;
	<span class="hljs-keyword">if</span> !reflect.TypeOf(key).Comparable() &#123;
		<span class="hljs-built_in">panic</span>(<span class="hljs-string">"key is not comparable"</span>)
	&#125;
	<span class="hljs-keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;
&#125;</code></pre></div>
<p>WithValue（）适用范围：<strong>只用与在request作用域内的数据，这种数据是在进程或API传输所用，而不是作为函数的parameter使用</strong></p>
<p>WithValue（）规定了：</p>
<ol>
<li>其key不应该是string或者其他内置的类型，主要是为了防止使用context包的其他包之间产生冲突</li>
<li>所以key应该是用户自己设置的，要自己覆盖Comparable（）方法才行
这里给出 **Comparable()**的源码解释</li>
</ol>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// Methods applicable only to some types, depending on Kind.</span>
	<span class="hljs-comment">// The methods allowed for each kind are:</span>
	<span class="hljs-comment">//</span>
	<span class="hljs-comment">//	Int*, Uint*, Float*, Complex*: Bits</span>
	<span class="hljs-comment">//	Array: Elem, Len</span>
	<span class="hljs-comment">//	Chan: ChanDir, Elem</span>
	<span class="hljs-comment">//	Func: In, NumIn, Out, NumOut, IsVariadic.</span>
	<span class="hljs-comment">//	Map: Key, Elem</span>
	<span class="hljs-comment">//	Ptr: Elem</span>
	<span class="hljs-comment">//	Slice: Elem</span>
    <span class="hljs-comment">//	Struct: Field, FieldByIndex, FieldByName, FieldByNameFunc, NumField</span></code></pre></div>
<ol start="3">
<li>为了防止赋值给interface{}，context的key经常是有具体类型的struct，此外，export出去的key的静态类型应该是指针或者interface</li>
</ol>
<h5 id="流程">流程</h5>
<ol>
<li>判断key是否为空，key的类型是否合法</li>
<li>返回一个有parent指针的valueCtx;所以，创建valueCtx是可以从parent开始一级一级往下创建(树)，如下图：
<img src="/img/valueCtx.png" srcset="/img/loading.gif" alt="valueCtx"></li>
</ol>
<h4 id="timerctx">timerCtx</h4>
<p>结构体：</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// A timerCtx carries a timer and a deadline. It embeds a cancelCtx to</span>
<span class="hljs-comment">// implement Done and Err. It implements cancel by stopping its timer then</span>
<span class="hljs-comment">// delegating to cancelCtx.cancel.</span>
<span class="hljs-keyword">type</span> timerCtx <span class="hljs-keyword">struct</span> &#123;
	cancelCtx
	timer *time.Timer <span class="hljs-comment">// Under cancelCtx.mu.</span>

	deadline time.Time
&#125;</code></pre></div>
<p>它的cancel方法</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *timerCtx)</span> <span class="hljs-title">cancel</span><span class="hljs-params">(removeFromParent <span class="hljs-keyword">bool</span>, err error)</span></span> &#123;
	c.cancelCtx.cancel(<span class="hljs-literal">false</span>, err)
	<span class="hljs-keyword">if</span> removeFromParent &#123;
		<span class="hljs-comment">// Remove this timerCtx from its parent cancelCtx's children.</span>
		removeChild(c.cancelCtx.Context, c)
	&#125;
	c.mu.Lock()
	<span class="hljs-keyword">if</span> c.timer != <span class="hljs-literal">nil</span> &#123;
		c.timer.Stop()
		c.timer = <span class="hljs-literal">nil</span>
	&#125;
	c.mu.Unlock()
&#125;</code></pre></div>
<p>流程：</p>
<ol>
<li>先调用里面的cancelCtx的cancel（）方法，取消其子节点</li>
<li>如果要</li>
</ol>
<p>哪里用到timerCtx.cancel（）呢，我们看看创建一个timerCtx的函数：</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Canceling this context releases resources associated with it, so code should</span>
<span class="hljs-comment">// call cancel as soon as the operations running in this Context complete:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// 	func slowOperationWithTimeout(ctx context.Context) (Result, error) &#123;</span>
<span class="hljs-comment">// 		ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)</span>
<span class="hljs-comment">// 		defer cancel()  // releases resources if slowOperation completes before timeout elapses</span>
<span class="hljs-comment">// 		return slowOperation(ctx)</span>
<span class="hljs-comment">// 	&#125;</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithTimeout</span><span class="hljs-params">(parent Context, timeout time.Duration)</span> <span class="hljs-params">(Context, CancelFunc)</span></span> &#123;
	<span class="hljs-keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))
&#125;</code></pre></div>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// WithDeadline returns a copy of the parent context with the deadline adjusted</span>
<span class="hljs-comment">// to be no later than d. If the parent's deadline is already earlier than d,</span>
<span class="hljs-comment">// WithDeadline(parent, d) is semantically equivalent to parent. The returned</span>
<span class="hljs-comment">// context's Done channel is closed when the deadline expires, when the returned</span>
<span class="hljs-comment">// cancel function is called, or when the parent context's Done channel is</span>
<span class="hljs-comment">// closed, whichever happens first.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Canceling this context releases resources associated with it, so code should</span>
<span class="hljs-comment">// call cancel as soon as the operations running in this Context complete.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithDeadline</span><span class="hljs-params">(parent Context, d time.Time)</span> <span class="hljs-params">(Context, CancelFunc)</span></span> &#123;
	<span class="hljs-keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;
		<span class="hljs-comment">// The current deadline is already sooner than the new one.</span>
		<span class="hljs-keyword">return</span> WithCancel(parent)
	&#125;
	c := &amp;timerCtx&#123;
		cancelCtx: newCancelCtx(parent),
		deadline:  d,
	&#125;
	propagateCancel(parent, c)
	dur := time.Until(d)
	<span class="hljs-keyword">if</span> dur &lt;= <span class="hljs-number">0</span> &#123;
		c.cancel(<span class="hljs-literal">true</span>, DeadlineExceeded) <span class="hljs-comment">// deadline has already passed</span>
		<span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">true</span>, Canceled) &#125;
	&#125;
	c.mu.Lock()
	<span class="hljs-keyword">defer</span> c.mu.Unlock()
	<span class="hljs-keyword">if</span> c.err == <span class="hljs-literal">nil</span> &#123;
		c.timer = time.AfterFunc(dur, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
			c.cancel(<span class="hljs-literal">true</span>, DeadlineExceeded)
		&#125;)
	&#125;
	<span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">true</span>, Canceled) &#125;
&#125;</code></pre></div>
<p>我们发现WithTimeout和WithDeadline（）都可以创建timerCtx
区别： withTimeout第二个参数是传入duration，即距离现在的时间，withDeadline第二个参数指的是绝对时间，即几时几分</p>
<p>withDeadline（）流程：</p>
<ol>
<li>
<p>检查当前的deadline，如果存在且当前deadline比传入的时间要早，那么就退化成WithCancel（）</p>
</li>
<li>
<p>如果不存在deadline或者传入时间较晚，把当前timerCtx加入到parent Context里面;
但是注意，还要计算现在的时间是否大于了传入的时间，如果大于说明已经过了传入的deadline，直接退化成cancel（），并传入exceed错误信息：</p>
 <div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">var</span> DeadlineExceeded error = deadlineExceededError&#123;&#125;
<span class="hljs-keyword">type</span> deadlineExceededError <span class="hljs-keyword">struct</span>&#123;&#125;
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(deadlineExceededError)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span>   &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">"context deadline exceeded"</span> &#125;</code></pre></div>
</li>
<li>
<p>如果上述都不成立，调用time.AfterFunc()，规定时间后调用cancel()</p>
</li>
</ol>
<h3 id="使用例子">使用例子</h3>
<p>这个经典的goroutine泄漏：</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">repeatGen</span><span class="hljs-params">()</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">int</span></span>&#123;
    c:=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)
    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;;i++&#123;
            c&lt;-i
        &#125;
    &#125;()
    <span class="hljs-keyword">return</span> c
&#125;
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;
    <span class="hljs-keyword">for</span> v:=<span class="hljs-keyword">range</span> repeatGen()&#123;
        fmt.Println(v)
        <span class="hljs-keyword">if</span> v==<span class="hljs-number">3</span>&#123;
            <span class="hljs-keyword">break</span>
        &#125;
    &#125;
&#125;</code></pre></div>
<p>当v==3的时候，break出来，但这时候repeatGen里面的goroutine仍然在跑，不会被终止,goroutine发生泄漏</p>
<p>用context改进：</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">repeatGen</span><span class="hljs-params">(ctx context.Context)</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">int</span></span>&#123;
    c:=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)
    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">for</span> i:<span class="hljs-number">0</span>;;i++&#123;
            <span class="hljs-keyword">select</span> &#123;
                <span class="hljs-keyword">case</span> &lt;-ctx.Done():<span class="hljs-comment">//等待done信号</span>
                    <span class="hljs-keyword">return</span>
                <span class="hljs-keyword">case</span> c&lt;-i:
            &#125;
        &#125;
    &#125;
&#125;
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;
    ctx,cancelFunc:=WithCancel(context.Background())
    <span class="hljs-keyword">defer</span> cancelFunc()<span class="hljs-comment">//最后无论怎么样也要调用确保一定能关掉（为保万一而已，不一定要）</span>
    <span class="hljs-keyword">for</span> v:=<span class="hljs-keyword">range</span> repeatGen(ctx)&#123;
        fmt.Println(v)
        <span class="hljs-keyword">if</span> v==<span class="hljs-number">3</span>&#123;
            cancelFunc()<span class="hljs-comment">//完成直接调用cancel</span>
            <span class="hljs-keyword">break</span>
        &#125;
    &#125;
&#125;</code></pre></div>
<p><strong><em>参考《go语言圣经》</em></strong></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/golang/">golang</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2019/06/26/ToMyLover/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">To my lover</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2019/06/21/Go/fmt/">
                        <span class="hidden-mobile">Fmt 输出包</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Golang Context&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
