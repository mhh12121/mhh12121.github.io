

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content>
  <meta name="author" content="Doujohner">
  <meta name="keywords" content>
  <title>Go Scheduler - 兜的破烂</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/ocean.min.css">
  

  


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Doujohner</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2019-07-09 01:00" pubdate>
      July 9, 2019 am
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      17.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      268
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">Go Scheduler</h1>
            
            <div class="markdown-body" id="post-body">
              <p>东抄西拼，Goroutine 的模型，调度等，它与普通thread有何区别？先留个坑</p>
<a id="more"></a>
<h2 id="为什么有这个东西？">为什么有这个东西？</h2>
<ol>
<li>
<p>传统OS自带的线程一个占栈1MB，明显大的过分，所以编程语言自身得另外实现一些小的线程, 而goroutines一般就4KB左右，当然这个数值是可以调整的；</p>
</li>
<li>
<p>切换上下文的时候一般一个线程就消耗1μs,但是goroutine的切换则仅仅有0.2μs左右，大约快了80%;（里面避免了内核和用户态上的切换）</p>
</li>
</ol>
<h3 id="引用">引用</h3>
<p>《 Scalable Go Scheduler Design Doc》中有描述</p>
<blockquote>
<p>Goroutines are part of making concurrency easy to use. The idea, which has been around for a while, is to multiplex independently    executing functions—coroutines—onto a set of threads. When a coroutine blocks, such as by calling a blocking system call, the run-time automatically moves other coroutines on the same operating system thread to a different, runnable thread so they won’t be blocked. The programmer sees none of this, which is the point. The result, which we call goroutines, can be very cheap: unless they spend a lot of time in long-running system calls, they cost little more than the memory for the stack, which is just a few kilobytes.</p>
</blockquote>
<p>大概意思就是 当系统调用阻塞，runtime环境会自动把被阻塞在当前线程内的coroutines移到另一个线程，这种在go里面就叫goroutines;</p>
<p>而针对goroutines的大小，也做了如下设计:</p>
<blockquote>
<p>To make the stacks small, Go’s run-time uses segmented stacks. A newly minted goroutine is given a few kilobytes, which is almost always enough. When it isn’t, the run-time allocates (and frees) extension segments automatically. The overhead averages about three cheap instructions per function call. It is practical to create hundreds of thousands of goroutines in the same address space. If goroutines were just threads, system resources would run out at a much smaller number.</p>
</blockquote>
<p>然后对于goroutine的栈设计，使用了<strong>分段</strong>的栈， 而且对于分段的栈增加了灵活性，当空间不足的话就会自动分配更多的空间，而且因为这个不涉及内核层面，不用保存过多信息，所以你可以在同一个地址空间里创建上千个goroutines</p>
<ul>
<li>
<p>这些分段栈的基本功能</p>
<ol>
<li>保护回复上下文的函数</li>
<li>运行队列processQueue</li>
</ol>
</li>
</ul>
<p>要时刻明白对于线程来讲，其<strong>阻塞指的是切换了调度队列</strong>，不再进行当前的<strong>数据控制流</strong>，如果其他流满足条件，则会移出当前队列，调度会之前的数据流。同理goroutine也只是一个结构，记录了运行的函数，运行的位置等</p>
<h2 id="大致工作原理">大致工作原理</h2>
<p>首先go现在版本(1.13)已经是基于协作的抢占式调度;</p>
<p>根据历史提交，有多个部分与其相关:</p>
<ul>
<li>
<p><code>goroutine.stackgurad0 = stackPreempt</code>证明在抢占中</p>
</li>
<li>
<p><code>runtime.preemptone</code>和<code>runtime.preemptall</code>会改变<code>stackguard0</code>字段</p>
</li>
<li>
<p><code>runtime.stoptheworld</code>调用<code>runtime.preemptall</code>设置所有cpu上运行的goroutine<code>stackguard0</code>=stackPreempt</p>
</li>
<li>
<p><code>runtime.newstack</code>增加了抢占的代码，<code>canPreempt()</code>方法会让出当前goroutine</p>
</li>
<li>
<p>在sysmon下,运行超过10ms的goroutine,<code>runtime.retake</code>和<code>runtime.preemptone</code>会被执行</p>
</li>
</ul>
<p>综上，实现其调度大概步骤:</p>
<ol>
<li>编译器在其函数前插入<code>runtime.morestack</code></li>
<li>在垃圾回收stw，sysmon发现goroutine运行超过10ms，就发出抢占<code>stackPreempt</code></li>
<li>有函数被call时，可能会触发编译器插入的<code>morestack</code>,其调用了<code>newstack()</code>会检查goroutine的<code>stackguard0</code>字段,如果是<code>stackPreempt</code>,就可以被抢占</li>
</ol>
<p>以上造成的一些后果，loop下死循环等等，大部分在1.14得以解决</p>
<p>在1.14版本中，实现了非协作式抢占调度(增加了新的状态和字段);</p>
<ul>
<li>
<p>挂起的goroutine是在gc的栈扫描(<code>markroot</code>)时完成的，由<code>runtime.suspendG</code>和<code>runtime.resumeG</code>两个函数重构栈扫描这一过程；
<code>runtime.suspendG</code>会将处于<code>_Grunning</code>状态的goroutine的<code>preemptStop</code>设为true;
<code>runtime.preemptPark</code>(<code>newstack</code>也用到,当<code>preemptStop</code>为true时进行挂起)可以挂起当前goroutine，将其状态更新为<code>_Gpreempted</code>，触发重新调度,并让出当前线程控制权；</p>
</li>
<li>
<p>增加<code>runtime.asyncPreempt</code> 和 <code>runtime.asyncPreempt2</code>异步抢占 (汇编实现???)todo，并在<code>runtime.preemptone</code>增加异步逻辑;</p>
</li>
<li>
<p>支持向goroutine发送信号来暂停，<code>runtime.sighandler</code>函数注册<code>SIGURG</code>(<s>为什么是这个信号?为啥不是<code>SIGALRM</code>或者其他???</s>见下面)处理函数<code>runtime.doSigPreempt</code>
实现<code>runtime.preemptM</code>,通过<code>SIGURG</code>向线程发送抢占;</p>
</li>
</ul>
<p>为什么使用<code>SIGURG</code>,注释中写了:</p>
<blockquote>
<blockquote>
<blockquote>
<p>// 1. It should be a signal that’s passed-through by debuggers by
	// default. On Linux, this is SIGALRM, SIGURG, SIGCHLD, SIGIO,
	// SIGVTALRM, SIGPROF, and SIGWINCH, plus some glibc-internal signals.
	//
	// 2. It shouldn’t be used internally by libc in mixed Go/C binaries
	// because libc may assume it’s the only thing that can handle these
	// signals. For example SIGCANCEL or SIGSETXID.
	//
	// 3. It should be a signal that can happen spuriously without
	// consequences. For example, SIGALRM is a bad choice because the
	// signal handler can’t tell if it was caused by the real process
	// alarm or not (arguably this means the signal is broken, but I
	// digress). SIGUSR1 and SIGUSR2 are also bad because those are often
	// used in meaningful ways by applications.
	//
	// 4. We need to deal with platforms without real-time signals (like
	// macOS), so those are out.</p>
</blockquote>
</blockquote>
</blockquote>
<p>大概意思就是</p>
<ol>
<li>要可以被debugger传输</li>
<li>不应该被libc使用</li>
<li>要有基本时序性，可以随意出现(SIGALARM就不行，不知道是不是由进程引起还是其他原因)</li>
<li>一些平台无实时信号(macOS)</li>
</ol>
<h2 id="调度模型">调度模型</h2>
<p>一般来说多线程调度模型有 work-sharing 和 work-stealing模型</p>
<p>go采用了后者，可以看看有关<a href="http://supertech.csail.mit.edu/papers/steal.pdf" target="_blank" rel="noopener">work-stealing的论文</a></p>
<p>架构：
GPM</p>
<ul>
<li>G（goroutine）指的是go语言的goroutine（有些人叫它为协程，但其实跟coroutine有一点区别，因为coroutine单纯在用户态使用）</li>
</ul>
<h3 id="scheduler调度过程">Scheduler调度过程</h3>
<h4 id="大概流程">大概流程</h4>
<p>调度前的检查:</p>
<ol>
<li>是否分配有gc mark，如果有则要做gc mark</li>
<li>检查有无localq，有就运行</li>
<li>没有则看globalq</li>
<li>看一下net中有无poll的出来</li>
<li>从其他的p 偷一部分</li>
</ol>
<h4 id="相关状态转换">相关状态转换</h4>
<p><img src="/img/gstatus.png" srcset="/img/loading.gif" alt="一个状态图"></p>
<p>状态的详细描述:</p>
<ul>
<li><code>_Gidle</code>:刚刚被分配还没有初始化</li>
<li><code>_Grunnable</code>:	没有执行代码，没有栈的所有权，存储在runq（local or global???）中；</li>
<li><code>_Grunning</code>:可以执行代码，拥有栈的所有权，绑定了M，P；</li>
<li><code>_Gsyscall</code>: 正在执行系统调用，拥有栈的所有权，没有执行用户代码，被赋予了内核线程 M 但是不在运行队列上;</li>
<li><code>_Gwaiting</code>:由于运行时而被阻塞，没有执行用户代码并且不在runq上，但是可能存在于<code>Channel</code>的等待队列上或者<code>lock</code>内等等;</li>
<li><code>_Gdead</code>:	没有被使用，没有执行代码，<strong>可能有分配的栈???</strong>,或者在<code>gFree</code>(g的一个字段,全部状态都是<code>Gdead</code>);</li>
<li><code>_Gcopystack</code>:栈正在被拷贝，没有执行代码，不在运行队列上;</li>
<li><code>_Gpreempted</code>:由于抢占而被阻塞，没有执行用户代码并且不在运行队列上，等待唤醒;</li>
<li><code>_Gscan</code>: GC 正在扫描栈空间，没有执行代码，可以与其他状态同时存（其值为0x1000,其他有些状态比如<code>_GscanRunning</code>=2，直接加上去）</li>
</ul>
<p>当有新的Goroutine被创建或者是现存的goroutine更新为runnable状态，它会被push到当前P的runnable goroutine list里面，
当P完成了执行goroutine，它会</p>
<ul>
<li>首先从自己的runnable g list里面pop一个goroutine，如果list是空的，它会随机选取其他P，并且偷取其list的一半runnable goroutine</li>
</ul>
<p>当M 创建了新的goroutine，它要保证有其他M执行这个goroutine
同样的，如果M进入了syscall阶段，它也要保证有其他M可以执行这个goroutine</p>
<h4 id="禁止抢占">禁止抢占:</h4>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runtime_procPin</span><span class="hljs-params">()</span> <span class="hljs-title">int</span> //标记当前<span class="hljs-title">G</span>在<span class="hljs-title">M</span>上不会被抢占，并返回当前<span class="hljs-title">P</span>的<span class="hljs-title">ID</span></span></code></pre></div>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runtime_procUnpin</span><span class="hljs-params">()</span> //解除抢占标志</span></code></pre></div>
<p>这里我们有两种方法：
我们可以立即block或unblock多个M，或使其自旋；
但这里会有性能损耗和花费不必要的cpu周期，方法是使用自旋而且burn CPU cycles(???)
然而，这不应该影响在GOMAXPROCS=1的程序（command line，appengine这些）</p>
<p>自旋有两个等级：</p>
<ol>
<li>一个已经附着了一个P的idle M 会不断自旋寻找新的Goroutines</li>
<li>一个已经附着了一个P的M 自旋等待其他可用的P
以上中，最多有GOMAXPROCS个自旋的goroutines， 等级（1）的idle M 不会阻塞 即使有等级（2）的idle M；
当新的goroutine被创建或者M进入syscall或者M从idle变成busy，它会保证至少存在一个自旋M （或者所有P是busy），</li>
<li>这就保证了不会有当前运行着的Goroutines被其他 M 运行</li>
<li>也避免了过多的 M 同时 阻塞和释放阻塞</li>
</ol>
<h3 id="sysmon">Sysmon</h3>
<h4 id="用途">用途</h4>
<p>如果一个syscall或者是G本身的任务太长，当前G一直阻塞（因为本地队列的G是顺序执行），中止长任务就要由另外一个监控程序，即Sysmon</p>
<h4 id="详情">详情</h4>
<p>sysmon是在<strong>runtime初始化之后，执行代码之前</strong>，由runtime启动且<strong>不与任何P绑定</strong>（所以才可以不被阻塞）直接由一个M执行的协程，类似于linux的一些系统任务内核线程</p>
<p>具体设置如<img src="/img/sysmon.png" srcset="/img/loading.gif" alt="sysmon状态转换图"></p>
<p>具体流程为:</p>
<ol>
<li>main函数启动时:</li>
</ol>
<ul>
<li>调用<code>newm</code>创建一个存储了待执行函数（这里是<code>sysmon</code>的结构体<code>runtime.m</code>),注意其不需要P的绑定，所以goroutine会直接在这个m上面建立;</li>
</ul>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// The main goroutine.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	...
	<span class="hljs-keyword">if</span> GOARCH != <span class="hljs-string">"wasm"</span> &#123; <span class="hljs-comment">// no threads on wasm yet, so no sysmon</span>
		systemstack(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
			newm(sysmon, <span class="hljs-literal">nil</span>)
		&#125;)
	&#125;
&#125;
<span class="hljs-comment">// Create a new m. It will start off with a call to fn, or else the scheduler.</span>
<span class="hljs-comment">// fn needs to be static and not a heap allocated closure.</span>
<span class="hljs-comment">// May run with m.p==nil, so write barriers are not allowed.</span>
<span class="hljs-comment">//go:nowritebarrierrec</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newm</span><span class="hljs-params">(fn <span class="hljs-keyword">func</span>()</span>, _<span class="hljs-title">p_</span> *<span class="hljs-title">p</span>)</span> &#123;
	mp := allocm(_p_, fn)
	mp.nextp.set(_p_)
	mp.sigmask = initSigmask
	...
	newm1(mp)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newm1</span><span class="hljs-params">(mp *m)</span></span> &#123;
	...
	execLock.rlock() <span class="hljs-comment">// Prevent process clone.</span>
	newosproc(mp)
	execLock.runlock()
&#125;</code></pre></div>
<p>一直调用到<code>newosproc</code>函数中，会<code>clone</code>一个新线程并在新线程中执行<code>runtime.mstart</code></p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// May run with m.p==nil, so write barriers are not allowed.</span>
<span class="hljs-comment">//go:nowritebarrier</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newosproc</span><span class="hljs-params">(mp *m)</span></span> &#123;
	stk := unsafe.Pointer(mp.g0.stack.hi)
	<span class="hljs-comment">// Disable signals during clone, so that the new thread starts</span>
	<span class="hljs-comment">// with signals disabled. It will enable them in minit.</span>
	<span class="hljs-keyword">var</span> oset sigset
	sigprocmask(_SIG_SETMASK, &amp;sigset_all, &amp;oset)
	ret := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))
	sigprocmask(_SIG_SETMASK, &amp;oset, <span class="hljs-literal">nil</span>)
&#125;</code></pre></div>
<p>在新线程上，会运行传入的<code>sysmon</code>函数:</p>
<ul>
<li>最初的休眠时间为20μs,最长的休眠时间是10ms，当sysmon在50个循环都无法唤醒goroutine时，休眠时间在每个循环都加倍</li>
</ul>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">//go:nowritebarrierrec</span>
<span class="hljs-comment">//显然不同p绑定则不需要写屏障</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sysmon</span><span class="hljs-params">()</span></span>&#123;
	<span class="hljs-comment">//为了将绑定的M不作deadlock检查</span>
	lock(&amp;sched.lock)
	sched.nmsys++
	checkdead()
	unlock(&amp;sched.lock)
	<span class="hljs-keyword">for</span>&#123;
		...
	&#125;
	...
&#125;</code></pre></div>
<p><code>sysmon</code>中有一些值得探究的函数:</p>
<ol start="2">
<li>检测死锁<code>checkdead()</code></li>
</ol>
<p>大致分为:</p>
<ul>
<li>检查是否存在正在运行的线程；</li>
<li>检查是否存在正在运行的goroutine；</li>
<li>检查P上是否有计时器；</li>
</ul>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// Check for deadlock situation.</span>
<span class="hljs-comment">// The check is based on number of running M's, if 0 -&gt; deadlock.</span>
<span class="hljs-comment">// sched.lock must be held.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkdead</span><span class="hljs-params">()</span></span> &#123;
	...
	<span class="hljs-comment">//上面都是一些panic，buildmode问题</span>
	<span class="hljs-comment">//mcount：根据下一个待创建的线程id和释放的线程数得到系统中存在的线程数</span>
	<span class="hljs-comment">//即(sched.mnext - sched.nmfreed)</span>
	<span class="hljs-comment">//sched.nmidle 处于空闲状态的M数量</span>
	<span class="hljs-comment">//sched.nmidlelocked处于锁定状态的M数量</span>
	<span class="hljs-comment">//sched.nmsys处于系统调用的M数量</span>
	run := mcount() - sched.nmidle - sched.nmidlelocked - sched.nmsys
	<span class="hljs-keyword">if</span> run &gt; run0 &#123;
		<span class="hljs-comment">//无死锁</span>
		<span class="hljs-keyword">return</span>
	&#125;
	<span class="hljs-keyword">if</span> run &lt; <span class="hljs-number">0</span> &#123;
		<span class="hljs-comment">//当前程序状态不一致</span>
		<span class="hljs-built_in">print</span>(<span class="hljs-string">"runtime: checkdead: nmidle="</span>, sched.nmidle, <span class="hljs-string">" nmidlelocked="</span>, sched.nmidlelocked, <span class="hljs-string">" mcount="</span>, mcount(), <span class="hljs-string">" nmsys="</span>, sched.nmsys, <span class="hljs-string">"\n"</span>)
		throw(<span class="hljs-string">"checkdead: inconsistent counts"</span>)
	&#125;

	<span class="hljs-comment">//run==0</span>
	grunning := <span class="hljs-number">0</span>
	lock(&amp;allglock)
	<span class="hljs-comment">//2.是否有运行的goroutine</span>
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(allgs); i++ &#123;
		gp := allgs[i]
		<span class="hljs-keyword">if</span> isSystemGoroutine(gp, <span class="hljs-literal">false</span>) &#123;
			<span class="hljs-keyword">continue</span>
		&#125;
		s := readgstatus(gp)
		<span class="hljs-keyword">switch</span> s &amp;^ _Gscan &#123;
		<span class="hljs-keyword">case</span> _Gwaiting,
			_Gpreempted:
			grunning++
		<span class="hljs-keyword">case</span> _Grunnable,
			_Grunning,
			_Gsyscall:
			<span class="hljs-comment">//有死锁</span>
			unlock(&amp;allglock)
			<span class="hljs-built_in">print</span>(<span class="hljs-string">"runtime: checkdead: find g "</span>, gp.goid, <span class="hljs-string">" in status "</span>, s, <span class="hljs-string">"\n"</span>)
			throw(<span class="hljs-string">"checkdead: runnable g"</span>)
		&#125;
	&#125;
	unlock(&amp;allglock)
	<span class="hljs-comment">//循环下来，所有M都在Gidle，Gdead，Gcopystack状态下</span>
	<span class="hljs-keyword">if</span> grunning == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// possible if main goroutine calls runtime·Goexit()</span>
		<span class="hljs-comment">//调用了goexit()</span>
		unlock(&amp;sched.lock) <span class="hljs-comment">// unlock so that GODEBUG=scheddetail=1 doesn't hang</span>
		throw(<span class="hljs-string">"no goroutines (main called runtime.Goexit) - deadlock!"</span>)
	&#125;

	<span class="hljs-comment">// Maybe jump time forward for playground.</span>
	<span class="hljs-keyword">if</span> faketime != <span class="hljs-number">0</span> &#123;
		when, _p_ := timeSleepUntil()
		<span class="hljs-keyword">if</span> _p_ != <span class="hljs-literal">nil</span> &#123;
			faketime = when
			<span class="hljs-keyword">for</span> pp := &amp;sched.pidle; *pp != <span class="hljs-number">0</span>; pp = &amp;(*pp).ptr().link &#123;
				<span class="hljs-keyword">if</span> (*pp).ptr() == _p_ &#123;
					*pp = _p_.link
					<span class="hljs-keyword">break</span>
				&#125;
			&#125;
			mp := mget()
			<span class="hljs-keyword">if</span> mp == <span class="hljs-literal">nil</span> &#123;
				<span class="hljs-comment">// There should always be a free M since</span>
				<span class="hljs-comment">// nothing is running.</span>
				throw(<span class="hljs-string">"checkdead: no m for timer"</span>)
			&#125;
			mp.nextp.set(_p_)
			notewakeup(&amp;mp.park)
			<span class="hljs-keyword">return</span>
		&#125;
	&#125;

	<span class="hljs-comment">// There are no goroutines running, so we can look at the P's.</span>
	<span class="hljs-comment">//3. 存在等待的goroutine切不存在running的goroutine，检查P中的计时器</span>
	<span class="hljs-keyword">for</span> _, _p_ := <span class="hljs-keyword">range</span> allp &#123;
		<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(_p_.timers) &gt; <span class="hljs-number">0</span> &#123;
			<span class="hljs-comment">//如果有等待的计时器，则goroutine陷入Gidle是合理的，如果没有，那就永远不会唤醒，就是死锁</span>
			<span class="hljs-keyword">return</span>
		&#125;
	&#125;

	getg().m.throwing = <span class="hljs-number">-1</span> <span class="hljs-comment">// do not dump full stacks</span>
	unlock(&amp;sched.lock)    <span class="hljs-comment">// unlock so that GODEBUG=scheddetail=1 doesn't hang</span>
	throw(<span class="hljs-string">"all goroutines are asleep - deadlock!"</span>)
&#125;</code></pre></div>
<ol start="3">
<li>一个forloop 会不断进行以下工作:</li>
</ol>
<ul>
<li>计时器，获得下一个需要被触发的timer</li>
</ul>
<p>PS: timer中管理了一个<code>最小堆</code>,堆顶timer就是最小时间，<code>checkTimers</code>方法会触发一次（但是其还不够，因为可能M都在忙，所以这里还要sysmon进行处理）</p>
<ul>
<li>netpoll，轮询获得需要处理的到期的fd</li>
<li>抢占(retake函数)运行时间较长的或者syscall的goroutine</li>
<li>gc，符合条件时强制回收</li>
</ul>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sysmon</span><span class="hljs-params">()</span></span>&#123;
	...
	<span class="hljs-keyword">for</span>&#123;
		<span class="hljs-comment">//一些延迟设定，每隔一定时间再去扫描</span>
		<span class="hljs-keyword">if</span> idle == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// start with 20us sleep...</span>
			delay = <span class="hljs-number">20</span>
			<span class="hljs-comment">//50个循环，加倍</span>
		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> idle &gt; <span class="hljs-number">50</span> &#123; <span class="hljs-comment">// start doubling the sleep after 1ms...</span>
			delay *= <span class="hljs-number">2</span>
		&#125;
		<span class="hljs-comment">//超出最大，设为最大</span>
		<span class="hljs-keyword">if</span> delay &gt; <span class="hljs-number">10</span>*<span class="hljs-number">1000</span> &#123; <span class="hljs-comment">// up to 10ms</span>
			delay = <span class="hljs-number">10</span> * <span class="hljs-number">1000</span>
		&#125;
		usleep(delay)
		<span class="hljs-comment">//----------------------1.timer 计时-----------------</span>
		<span class="hljs-comment">//next为下次tick应该发生的时间，只会由sysmon()和checkdead()调用</span>
		now := nanotime()
		next, _ := timeSleepUntil()
		
		<span class="hljs-keyword">if</span> debug.schedtrace &lt;= <span class="hljs-number">0</span> &amp;&amp; (sched.gcwaiting != <span class="hljs-number">0</span> || atomic.Load(&amp;sched.npidle) == <span class="hljs-keyword">uint32</span>(gomaxprocs)) &#123;
			lock(&amp;sched.lock)
			<span class="hljs-keyword">if</span> atomic.Load(&amp;sched.gcwaiting) != <span class="hljs-number">0</span> || atomic.Load(&amp;sched.npidle) == <span class="hljs-keyword">uint32</span>(gomaxprocs) &#123;
				<span class="hljs-comment">//当前垃圾回收和所有处理器都处于闲置状态(npidle=gomaxprocs)，且没有要触发的计时器，sysmon陷入休眠</span>
				<span class="hljs-keyword">if</span> next &gt; now &#123;
					atomic.Store(&amp;sched.sysmonwait, <span class="hljs-number">1</span>)
					unlock(&amp;sched.lock)
					<span class="hljs-comment">// Make wake-up period small enough</span>
					<span class="hljs-comment">// for the sampling to be correct.</span>
					<span class="hljs-comment">//计算休眠的时间</span>
					sleep := forcegcperiod / <span class="hljs-number">2</span>
					<span class="hljs-keyword">if</span> next-now &lt; sleep &#123;
						sleep = next - now
					&#125;
					shouldRelax := sleep &gt;= osRelaxMinNS
					<span class="hljs-keyword">if</span> shouldRelax &#123;
						osRelax(<span class="hljs-literal">true</span>)
					&#125;
					<span class="hljs-comment">//信号量同步系统监控即将进入休眠的状态</span>
					notetsleep(&amp;sched.sysmonnote, sleep)
					<span class="hljs-keyword">if</span> shouldRelax &#123;
						osRelax(<span class="hljs-literal">false</span>)
					&#125;
					<span class="hljs-comment">//唤醒</span>
					now = nanotime()
					next, _ = timeSleepUntil()
					lock(&amp;sched.lock)
					atomic.Store(&amp;sched.sysmonwait, <span class="hljs-number">0</span>)
					<span class="hljs-comment">//唤醒之后通知 系统监控被唤醒</span>
					noteclear(&amp;sched.sysmonnote)
				&#125;
				<span class="hljs-comment">//唤醒后重置休眠时间</span>
				idle = <span class="hljs-number">0</span>
				delay = <span class="hljs-number">20</span>
				<span class="hljs-comment">//如果在这之后，我们发现下一个计时器需要触发的时间小于当前时间，这也就说明所有的线程可能正在忙于运行 Goroutine，系统监控会启动新的线程来触发计时器，避免计时器的到期时间有较大的偏差。???</span>
			&#125;
			unlock(&amp;sched.lock)
		&#125;

		<span class="hljs-comment">//----------------2. netpolll-------------------</span>
		<span class="hljs-comment">// poll network if not polled for more than 10ms</span>
		<span class="hljs-comment">//先检查网络上的调用，超过10ms没有poll过则会poll一次</span>
		lastpoll := <span class="hljs-keyword">int64</span>(atomic.Load64(&amp;sched.lastpoll))
		<span class="hljs-keyword">if</span> netpollinited() &amp;&amp; lastpoll != <span class="hljs-number">0</span> &amp;&amp; lastpoll+<span class="hljs-number">10</span>*<span class="hljs-number">1000</span>*<span class="hljs-number">1000</span> &lt; now &#123;
			<span class="hljs-comment">//更新sched.lastpoll=now</span>
			atomic.Cas64(&amp;sched.lastpoll, <span class="hljs-keyword">uint64</span>(lastpoll), <span class="hljs-keyword">uint64</span>(now))
			<span class="hljs-comment">// netpoll checks for ready network connections.</span>
			<span class="hljs-comment">// Returns list of goroutines that become runnable.</span>
			<span class="hljs-comment">//返回runnable的goroutine list</span>
			list := netpoll(<span class="hljs-number">0</span>) <span class="hljs-comment">// non-blocking - returns list of goroutines</span>
			<span class="hljs-keyword">if</span> !list.empty() &#123;
				<span class="hljs-comment">// Need to decrement number of idle locked M's</span>
				<span class="hljs-comment">// (pretending that one more is running) before injectglist.</span>
				<span class="hljs-comment">// Otherwise it can lead to the following situation:</span>
				<span class="hljs-comment">// injectglist grabs all P's but before it starts M's to run the P's,</span>
				<span class="hljs-comment">// another M returns from syscall, finishes running its G,</span>
				<span class="hljs-comment">// observes that there is no work to do and no other running M's</span>
				<span class="hljs-comment">// and reports deadlock.</span>
				<span class="hljs-comment">//需要先减少lockedM的理由：</span>
				<span class="hljs-comment">//injectglist会获取所有P 但是 在sched会启动M去运行一个P的G之前，另外一个M从syscall中返回，完成了这个G，这个时候sched启动的这个M就发现没东西去做，而且没有其他运行的M，会报deadlock todo???</span>
				incidlelocked(<span class="hljs-number">-1</span>)
				<span class="hljs-comment">// Injects the list of runnable G's into the scheduler and clears glist.</span>
				<span class="hljs-comment">//实际上会将所有goroutine状态从_Gwaiting切换到_Grunnable并加入到全局队列等待，</span>
				<span class="hljs-comment">//如果有空闲的P，就会通过startm()来启动线程执行这些任务</span>
				injectglist(&amp;list)
				incidlelocked(<span class="hljs-number">1</span>)
			&#125;
		&#125;
		<span class="hljs-comment">//todo ???为什么next&lt;now可以说明</span>
		<span class="hljs-comment">//有timers本来应该被运行但未运行，一种可能就是有不可抢占的P，尝试开启一个M来运行</span>
		<span class="hljs-keyword">if</span> next &lt; now &#123;
			<span class="hljs-comment">// There are timers that should have already run,</span>
			<span class="hljs-comment">// perhaps because there is an unpreemptible P.</span>
			<span class="hljs-comment">// Try to start an M to run them.</span>
			startm(<span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>)
		&#125;
		<span class="hljs-comment">//---------------------3. 抢占retake()---------------</span>
		<span class="hljs-comment">//重点，重新拿取在syscall的P，并且抢占长久运行的G</span>
		<span class="hljs-comment">// retake P's blocked in syscalls</span>
		<span class="hljs-comment">// and preempt long running G's</span>
		<span class="hljs-keyword">if</span> retake(now) != <span class="hljs-number">0</span> &#123;
			<span class="hljs-comment">//抢占了，恢复20μs的间隔</span>
			idle = <span class="hljs-number">0</span>
		&#125; <span class="hljs-keyword">else</span> &#123;
			idle++
		&#125;
		<span class="hljs-comment">//-----------------------4. gc force--------------</span>
		<span class="hljs-comment">//还有检查是否要强制GC</span>
		<span class="hljs-comment">// check if we need to force a GC</span>
		<span class="hljs-keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerTime, now: now&#125;); t.test() &amp;&amp; atomic.Load(&amp;forcegc.idle) != <span class="hljs-number">0</span> &#123;
			lock(&amp;forcegc.lock)
			forcegc.idle = <span class="hljs-number">0</span>
			<span class="hljs-keyword">var</span> list gList
			<span class="hljs-comment">//会将用于gc的goroutine加入全局队列，让scheduler去选择p处理</span>
			list.push(forcegc.g)
			injectglist(&amp;list)
			unlock(&amp;forcegc.lock)
		&#125;
		...
		<span class="hljs-comment">//trace相关</span>
	&#125;
&#125;</code></pre></div>
<p>主要讲一下抢占<code>retake()</code>,其sysmontick结构如下：</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> sysmontick <span class="hljs-keyword">struct</span> &#123;
	schedtick   <span class="hljs-keyword">uint32</span> <span class="hljs-comment">//处理器调度次数</span>
	schedwhen   <span class="hljs-keyword">int64</span><span class="hljs-comment">//处理器上次调度时间</span>
	syscalltick <span class="hljs-keyword">uint32</span><span class="hljs-comment">//系统调用次数</span>
	syscallwhen <span class="hljs-keyword">int64</span><span class="hljs-comment">//系统调用时间</span>
&#125;</code></pre></div>
<p><code>retake()</code>函数:</p>
<ul>
<li>当P处于 <code>_Prunning</code> 或者 <code>_Psyscall</code> 状态时，如果上一次触发调度的时间已经过去了 10ms，我们就会通过 runtime.preemptone 抢占当前处理器；</li>
<li>当P处于 <code>_Psyscall</code> 状态时，当<strong>处理器的运行队列不为空或者不存在空闲处理器时</strong> 或者 <strong>当系统调用时间超过了 10ms</strong>，都会调用 <code>runtime.handoffp</code> 让出处理器的使用权：</li>
</ul>
<div class="hljs"><pre><code class="hljs go">
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">retake</span><span class="hljs-params">(now <span class="hljs-keyword">int64</span>)</span> <span class="hljs-title">uint32</span></span> &#123;
	n := <span class="hljs-number">0</span>
	<span class="hljs-comment">// Prevent allp slice changes. This lock will be completely</span>
	<span class="hljs-comment">// uncontended unless we're already stopping the world.</span>
	<span class="hljs-comment">//allp       []*p  // len(allp) == gomaxprocs; may change at safe points, otherwise immutable</span>
	<span class="hljs-comment">//防止p的数目变化</span>
	lock(&amp;allpLock)
	<span class="hljs-comment">// We can't use a range loop over allp because we may</span>
	<span class="hljs-comment">// temporarily drop the allpLock. Hence, we need to re-fetch</span>
	<span class="hljs-comment">// allp each time around the loop.</span>
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(allp); i++ &#123;
		_p_ := allp[i]
		<span class="hljs-keyword">if</span> _p_ == <span class="hljs-literal">nil</span> &#123;
			<span class="hljs-comment">// This can happen if procresize has grown</span>
			<span class="hljs-comment">// allp but not yet created new Ps.</span>
			<span class="hljs-keyword">continue</span>
		&#125;
		pd := &amp;_p_.sysmontick
		s := _p_.status
		sysretake := <span class="hljs-literal">false</span>
		<span class="hljs-comment">//1. 处于Prunning或者Psyscall，</span>
		<span class="hljs-keyword">if</span> s == _Prunning || s == _Psyscall &#123;
			<span class="hljs-comment">//p在running或者syscall太久，进行抢占!</span>
			<span class="hljs-comment">// Preempt G if it's running for too long.</span>
			t := <span class="hljs-keyword">int64</span>(_p_.schedtick)
			<span class="hljs-keyword">if</span> <span class="hljs-keyword">int64</span>(pd.schedtick) != t &#123;
				pd.schedtick = <span class="hljs-keyword">uint32</span>(t)
				pd.schedwhen = now
			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> pd.schedwhen+forcePreemptNS &lt;= now &#123;
			<span class="hljs-comment">//超过10ms</span>
				<span class="hljs-comment">//抢占</span>
				preemptone(_p_)
				<span class="hljs-comment">// In case of syscall, preemptone() doesn't</span>
				<span class="hljs-comment">// work, because there is no M wired to P.</span>
				<span class="hljs-comment">//syscall下preemptone不会作用，因为没有M同P联系住，这里设为true只是让下面的代码少跑一轮</span>
				sysretake = <span class="hljs-literal">true</span>
			&#125;
		&#125;
		<span class="hljs-comment">//2. Psyscall下</span>
		<span class="hljs-keyword">if</span> s == _Psyscall &#123;
			<span class="hljs-comment">// Retake P from syscall if it's there for more than 1 sysmon tick (at least 20us).</span>
			t := <span class="hljs-keyword">int64</span>(_p_.syscalltick)
			<span class="hljs-keyword">if</span> !sysretake &amp;&amp; <span class="hljs-keyword">int64</span>(pd.syscalltick) != t &#123;
				pd.syscalltick = <span class="hljs-keyword">uint32</span>(t)
				pd.syscallwhen = now
				<span class="hljs-keyword">continue</span>
			&#125;
			<span class="hljs-comment">// On the one hand we don't want to retake Ps if there is no other work to do,</span>
			<span class="hljs-comment">// but on the other hand we want to retake them eventually</span>
			<span class="hljs-comment">// because they can prevent the sysmon thread from deep sleep.</span>
			<span class="hljs-keyword">if</span> runqempty(_p_) &amp;&amp; atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) &gt; <span class="hljs-number">0</span> &amp;&amp; pd.syscallwhen+<span class="hljs-number">10</span>*<span class="hljs-number">1000</span>*<span class="hljs-number">1000</span> &gt; now &#123;
				<span class="hljs-keyword">continue</span>
			&#125;
			<span class="hljs-comment">// Drop allpLock so we can take sched.lock.</span>
			unlock(&amp;allpLock)
			<span class="hljs-comment">// Need to decrement number of idle locked M's</span>
			<span class="hljs-comment">// (pretending that one more is running) before the CAS.</span>
			<span class="hljs-comment">// Otherwise the M from which we retake can exit the syscall,</span>
			<span class="hljs-comment">// increment nmidle and report deadlock.</span>
			<span class="hljs-comment">//同上面一样，防止 当前retake的M退出syscall，导致idle的M增加(nmide++)，死锁发生</span>
			incidlelocked(<span class="hljs-number">-1</span>)
			<span class="hljs-comment">//1.当前P运行队列不为空或者不存在空闲的P时</span>
			<span class="hljs-comment">//2. 系统调用时间超时10ms</span>
			<span class="hljs-keyword">if</span> atomic.Cas(&amp;_p_.status, s, _Pidle) &#123;
				<span class="hljs-keyword">if</span> trace.enabled &#123;
					traceGoSysBlock(_p_)
					traceProcStop(_p_)
				&#125;
				n++
				_p_.syscalltick++
				<span class="hljs-comment">//执行syscall，handoff当前P，让出P，因为syscall的时候G是直接同M绑定的！！！</span>
				handoffp(_p_)
			&#125;
			incidlelocked(<span class="hljs-number">1</span>)
			lock(&amp;allpLock)
		&#125;
	&#125;
	unlock(&amp;allpLock)
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">uint32</span>(n)
&#125;</code></pre></div>
<p><code>retake</code>中的<code>handoffp</code>：</p>
<ul>
<li>先检查本地runq有无g，如果有，直接调用<code>startm</code>运行</li>
<li>检查有无gc <code>work</code>(todo???是一个全局的垃圾回收结构体)，如果有，调用<code>startm</code>开始</li>
<li></li>
</ul>
<div class="hljs"><pre><code class="hljs go">
<span class="hljs-comment">// Hands off P from syscall or locked M.</span>
<span class="hljs-comment">// Always runs without a P, so write barriers are not allowed.</span>
<span class="hljs-comment">//go:nowritebarrierrec</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handoffp</span><span class="hljs-params">(_p_ *p)</span></span> &#123;
	<span class="hljs-comment">// handoffp must start an M in any situation where</span>
	<span class="hljs-comment">// findrunnable would return a G to run on _p_.</span>

	<span class="hljs-comment">// if it has local work, start it straight away</span>
	<span class="hljs-keyword">if</span> !runqempty(_p_) || sched.runqsize != <span class="hljs-number">0</span> &#123;
		startm(_p_, <span class="hljs-literal">false</span>)
		<span class="hljs-keyword">return</span>
	&#125;
	<span class="hljs-comment">// if it has GC work, start it straight away</span>
	<span class="hljs-keyword">if</span> gcBlackenEnabled != <span class="hljs-number">0</span> &amp;&amp; gcMarkWorkAvailable(_p_) &#123;
		startm(_p_, <span class="hljs-literal">false</span>)
		<span class="hljs-keyword">return</span>
	&#125;
	<span class="hljs-comment">// no local work, check that there are no spinning/idle M's,</span>
	<span class="hljs-comment">// otherwise our help is not required</span>
	<span class="hljs-keyword">if</span> atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) == <span class="hljs-number">0</span> &amp;&amp; atomic.Cas(&amp;sched.nmspinning, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> fast atomic</span>
		startm(_p_, <span class="hljs-literal">true</span>)
		<span class="hljs-keyword">return</span>
	&#125;
	lock(&amp;sched.lock)
	<span class="hljs-keyword">if</span> sched.gcwaiting != <span class="hljs-number">0</span> &#123;
		_p_.status = _Pgcstop
		sched.stopwait--
		<span class="hljs-keyword">if</span> sched.stopwait == <span class="hljs-number">0</span> &#123;
			notewakeup(&amp;sched.stopnote)
		&#125;
		unlock(&amp;sched.lock)
		<span class="hljs-keyword">return</span>
	&#125;
	<span class="hljs-keyword">if</span> _p_.runSafePointFn != <span class="hljs-number">0</span> &amp;&amp; atomic.Cas(&amp;_p_.runSafePointFn, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) &#123;
		sched.safePointFn(_p_)
		sched.safePointWait--
		<span class="hljs-keyword">if</span> sched.safePointWait == <span class="hljs-number">0</span> &#123;
			notewakeup(&amp;sched.safePointNote)
		&#125;
	&#125;
	<span class="hljs-keyword">if</span> sched.runqsize != <span class="hljs-number">0</span> &#123;
		unlock(&amp;sched.lock)
		startm(_p_, <span class="hljs-literal">false</span>)
		<span class="hljs-keyword">return</span>
	&#125;
	<span class="hljs-comment">// If this is the last running P and nobody is polling network,</span>
	<span class="hljs-comment">// need to wakeup another M to poll network.</span>
	<span class="hljs-keyword">if</span> sched.npidle == <span class="hljs-keyword">uint32</span>(gomaxprocs<span class="hljs-number">-1</span>) &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != <span class="hljs-number">0</span> &#123;
		unlock(&amp;sched.lock)
		startm(_p_, <span class="hljs-literal">false</span>)
		<span class="hljs-keyword">return</span>
	&#125;
	<span class="hljs-keyword">if</span> when := nobarrierWakeTime(_p_); when != <span class="hljs-number">0</span> &#123;
		wakeNetPoller(when)
	&#125;
	pidleput(_p_)
	unlock(&amp;sched.lock)
&#125;</code></pre></div>
<ol start="4">
<li>最后还要判断一下是否要gc</li>
</ol>
<ul>
<li>将传入的<code>forcegc.g</code>的list，每个g状态改为<code>Grunnable</code>然后放入全局<code>sched.list</code>;</li>
<li>接着还会检查一次<code>sched.npidle</code>看下有无空闲的p，调用<code>startm(nil, false)</code>立即开始</li>
<li>最后清空传入的<code>forcegc.g</code> 的list</li>
</ul>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sysmon</span><span class="hljs-params">()</span></span> &#123;
	...
	<span class="hljs-keyword">for</span>&#123;
		....
		<span class="hljs-comment">// 4. check if we need to force a GC</span>
		<span class="hljs-keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerTime, now: now&#125;); t.test() &amp;&amp; atomic.Load(&amp;forcegc.idle) != <span class="hljs-number">0</span> &#123;
			lock(&amp;forcegc.lock)
			forcegc.idle = <span class="hljs-number">0</span>
			<span class="hljs-keyword">var</span> list gList
			list.push(forcegc.g)
			injectglist(&amp;list)
			unlock(&amp;forcegc.lock)
		&#125;
		..<span class="hljs-comment">//trace</span>
	&#125;
&#125;</code></pre></div>
<h3 id="gpm各个结构体">GPM各个结构体</h3>
<h4 id="g-goroutine">g (goroutine)</h4>
<p>要注意几个fields:</p>
<ol>
<li>与栈相关的, 另一篇文章提到过栈(<code>stackguard0</code>用作调度器抢占式调度);</li>
</ol>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> g <span class="hljs-keyword">struct</span>&#123;
	stack       stack   <span class="hljs-comment">// offset known to runtime/cgo</span>
	<span class="hljs-comment">//栈空间[lo,hi)</span>
	<span class="hljs-comment">//type stack struct &#123;</span>
	<span class="hljs-comment">//	lo uintptr</span>
	<span class="hljs-comment">//	hi uintptr</span>
	<span class="hljs-comment">//&#125;</span>
	stackguard0 <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// offset known to liblink</span>
	stackguard1 <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// offset known to liblink</span>
&#125;</code></pre></div>
<ol start="2">
<li>与抢占相关
在之前文章也有提到过，<code>g.preemptStop</code>在抢占时会变成<code>_Gpreempted</code>
<code>g.preemptShrink</code>标记是否当前在shrink中</li>
</ol>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> g <span class="hljs-keyword">struct</span>&#123;
	preempt       <span class="hljs-keyword">bool</span> <span class="hljs-comment">// preemption signal, duplicates stackguard0 = stackpreempt</span>
	preemptStop   <span class="hljs-keyword">bool</span> <span class="hljs-comment">// transition to _Gpreempted on preemption; otherwise, just deschedule</span>
	preemptShrink <span class="hljs-keyword">bool</span> <span class="hljs-comment">// shrink stack at synchronous safe point</span>
&#125;</code></pre></div>
<ol start="3">
<li>调度字段</li>
</ol>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> g <span class="hljs-keyword">struct</span>&#123;
	m            *m      <span class="hljs-comment">// current m; offset known to arm liblink</span>
	sched        gobuf
	atomicstatus <span class="hljs-keyword">uint32</span> <span class="hljs-comment">//上面提到的几种状态</span>
&#125;</code></pre></div>
<p>其中<code>g.sched</code>字段就是调度时候保存的各种指针等信息，用来恢复上下文的时候使用:</p>
<p>依次是</p>
<ul>
<li>
<p><code>sp</code>,<code>pc</code>分别为栈指针，程序计数器</p>
</li>
<li>
<p><code>g</code>当前该gobuf的goroutine</p>
</li>
<li>
<p><code>ctxt</code>在之前的文章讲过，复制栈的时候要把这部分指针复制,用作</p>
</li>
<li>
<p><code>ret</code>系统用的return</p>
</li>
</ul>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> gobuf <span class="hljs-keyword">struct</span> &#123;
	<span class="hljs-comment">// The offsets of sp, pc, and g are known to (hard-coded in) libmach.</span>
	<span class="hljs-comment">//</span>
	<span class="hljs-comment">// ctxt is unusual with respect to GC: it may be a</span>
	<span class="hljs-comment">// heap-allocated funcval, so GC needs to track it, but it</span>
	<span class="hljs-comment">// needs to be set and cleared from assembly, where it's</span>
	<span class="hljs-comment">// difficult to have write barriers. However, ctxt is really a</span>
	<span class="hljs-comment">// saved, live register, and we only ever exchange it between</span>
	<span class="hljs-comment">// the real register and the gobuf. Hence, we treat it as a</span>
	<span class="hljs-comment">// root during stack scanning, which means assembly that saves</span>
	<span class="hljs-comment">// and restores it doesn't need write barriers. It's still</span>
	<span class="hljs-comment">// typed as a pointer so that any other writes from Go get</span>
	<span class="hljs-comment">// write barriers.</span>
	sp   <span class="hljs-keyword">uintptr</span>
	pc   <span class="hljs-keyword">uintptr</span>
	g    guintptr
	ctxt unsafe.Pointer
	ret  sys.Uintreg
	lr   <span class="hljs-keyword">uintptr</span>
	bp   <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// for GOEXPERIMENT=framepointer</span>
&#125;</code></pre></div>
<p>较全的结构</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> g <span class="hljs-keyword">struct</span> &#123;
	goid           <span class="hljs-keyword">int64</span>
	<span class="hljs-comment">// Stack parameters.</span>
	<span class="hljs-comment">// stack describes the actual stack memory: [stack.lo, stack.hi).</span>
	<span class="hljs-comment">// stackguard0 is the stack pointer compared in the Go stack growth prologue.</span>
	<span class="hljs-comment">//stackguard0用作栈的指针</span>
	<span class="hljs-comment">// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.</span>
	<span class="hljs-comment">// stackguard1 is the stack pointer compared in the C stack growth prologue.</span>
	<span class="hljs-comment">// It is stack.lo+StackGuard on g0 and gsignal stacks.</span>
	<span class="hljs-comment">// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).</span>
	stack       stack   <span class="hljs-comment">// offset known to runtime/cgo</span>
	<span class="hljs-comment">//栈空间[lo,hi)</span>
	<span class="hljs-comment">//type stack struct &#123;</span>
	<span class="hljs-comment">//	lo uintptr</span>
	<span class="hljs-comment">//	hi uintptr</span>
	<span class="hljs-comment">//&#125;</span>
	stackguard0 <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// offset known to liblink</span>
	stackguard1 <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// offset known to liblink</span>
    ...
	m              *m      <span class="hljs-comment">// current m; offset known to arm liblink</span>
	<span class="hljs-comment">//调度器,上下文保存的信息所在地</span>
	sched          gobuf
    ...
	param          unsafe.Pointer <span class="hljs-comment">// passed parameter on wakeup</span>
	...
	
	schedlink      guintptr
	waitsince      <span class="hljs-keyword">int64</span>      <span class="hljs-comment">// approx time when the g become blocked</span>
	waitreason     waitReason <span class="hljs-comment">// if status==Gwaiting</span>
	...
	preemptscan    <span class="hljs-keyword">bool</span>       <span class="hljs-comment">// preempted g does scan for gc</span>
	gcscandone     <span class="hljs-keyword">bool</span>       <span class="hljs-comment">// g has scanned stack; protected by _Gscan bit in status</span>
	gcscanvalid    <span class="hljs-keyword">bool</span>       <span class="hljs-comment">// false at start of gc cycle, true if G has not run since last scan; <span class="hljs-doctag">TODO:</span> remove?</span>
	...
	raceignore     <span class="hljs-keyword">int8</span>       <span class="hljs-comment">// ignore race detection events</span>
	sysblocktraced <span class="hljs-keyword">bool</span>       <span class="hljs-comment">// StartTrace has emitted EvGoInSyscall about this goroutine</span>
	sysexitticks   <span class="hljs-keyword">int64</span>      <span class="hljs-comment">// cputicks when syscall has returned (for tracing)</span>
	traceseq       <span class="hljs-keyword">uint64</span>     <span class="hljs-comment">// trace event sequencer</span>
	tracelastp     puintptr   <span class="hljs-comment">// last P emitted an event for this goroutine</span>
    lockedm        muintptr
    
    <span class="hljs-comment">//本身的寄存器状态</span>
	sig            <span class="hljs-keyword">uint32</span>
	writebuf       []<span class="hljs-keyword">byte</span>
	sigcode0       <span class="hljs-keyword">uintptr</span>
	sigcode1       <span class="hljs-keyword">uintptr</span>
	sigpc          <span class="hljs-keyword">uintptr</span>
    gopc           <span class="hljs-keyword">uintptr</span>         <span class="hljs-comment">// pc of go statement that created this goroutine</span>
    ....
	startpc        <span class="hljs-keyword">uintptr</span>         <span class="hljs-comment">// pc of goroutine function</span>
	racectx        <span class="hljs-keyword">uintptr</span>
	waiting        *sudog         <span class="hljs-comment">// sudog structures this g is waiting on (that have a valid elem ptr); in lock order</span>

	.....
	<span class="hljs-comment">// Per-G GC state</span>

	<span class="hljs-comment">// gcAssistBytes is this G's GC assist credit in terms of</span>
	<span class="hljs-comment">// bytes allocated. If this is positive, then the G has credit</span>
	<span class="hljs-comment">// to allocate gcAssistBytes bytes without assisting. If this</span>
	<span class="hljs-comment">// is negative, then the G must correct this by performing</span>
	<span class="hljs-comment">// scan work. We track this in bytes to make it fast to update</span>
	<span class="hljs-comment">// and check for debt in the malloc hot path. The assist ratio</span>
	<span class="hljs-comment">// determines how this corresponds to scan work debt.</span>
	gcAssistBytes <span class="hljs-keyword">int64</span>
&#125;</code></pre></div>
<h4 id="m-machine">M（machine）</h4>
<p>指的就是OS原生线程,是真正调度资源的单位，M是idle或者syscall中，需要P的调度</p>
<ol>
<li>其中<code>m.curg</code>为当前线程上运行的用户goroutine(注意，<code>getg()</code>拿到的是m的当前所有类型的goroutine)</li>
</ol>
<p><code>m.g0</code>为持有调度栈的goroutine</p>
<ol start="2">
<li>还有几个处理器相关的字段:
<code>m.p</code>: 正在运行的处理器
<code>m.nextp</code>:暂存的处理器
<code>m.oldp</code>:执行系统调用之前使用的线程处理器</li>
</ol>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> m <span class="hljs-keyword">struct</span> &#123;
	id            <span class="hljs-keyword">int64</span>
    <span class="hljs-comment">//g0是一个调用栈</span>
	g0      *g     <span class="hljs-comment">// goroutine with scheduling stack</span>
	morebuf gobuf  <span class="hljs-comment">// gobuf arg to morestack</span>
	procid        <span class="hljs-keyword">uint64</span>       <span class="hljs-comment">// for debuggers, but offset not hard-coded</span>
	<span class="hljs-comment">//底层的线程id</span>
    ...
    <span class="hljs-comment">//这个信号处理的goroutines</span>
	gsignal       *g           <span class="hljs-comment">// signal-handling g</span>
	goSigStack    gsignalStack <span class="hljs-comment">// Go-allocated signal handling stack</span>
    sigmask       sigset       <span class="hljs-comment">// storage for saved signal mask</span>
	<span class="hljs-comment">//TLS启动时候要使用</span>
	<span class="hljs-comment">//传给FS寄存器的局部变量</span>
	tls           [<span class="hljs-number">6</span>]<span class="hljs-keyword">uintptr</span>   <span class="hljs-comment">// thread-local storage (for x86 extern register)</span>
	<span class="hljs-comment">//m启动时的函数，会传给clone</span>
	mstartfn      <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;&#125;  <span class="hljs-comment">//当前运行的goroutine,&#123;&#125;在语法中是错误的，这里为了使markdown解析而加上</span>
	<span class="hljs-comment">//当前运行代码的g</span>
    curg          *g       <span class="hljs-comment">// current running goroutine</span>
    
	caughtsig     guintptr <span class="hljs-comment">// goroutine running during fatal signal</span>

	<span class="hljs-comment">//处理器相关,与P绑定</span>
    p             puintptr <span class="hljs-comment">// attached p for executing go code (nil if not executing go code)</span>
	nextp         puintptr
    oldp          puintptr <span class="hljs-comment">// the p that was attached before executing a syscall</span>

	mallocing     <span class="hljs-keyword">int32</span>
    throwing      <span class="hljs-keyword">int32</span>
    <span class="hljs-comment">//如果不等于"",没有发生抢占</span>
    preemptoff    <span class="hljs-keyword">string</span> <span class="hljs-comment">// if != "", keep curg running on this m</span>
    
	locks         <span class="hljs-keyword">int32</span>
	....
    
    <span class="hljs-comment">//m正在自旋，寻找可以attach的工作对象(P), m找不到可运行的g</span>
	spinning      <span class="hljs-keyword">bool</span> <span class="hljs-comment">// m is out of work and is actively looking for work</span>
	blocked       <span class="hljs-keyword">bool</span> <span class="hljs-comment">// m is blocked on a note</span>
    .....
    <span class="hljs-comment">//如果=0，则可以清空g0以及清除该m，是原子性的操作</span>
	freeWait      <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// if == 0, safe to free g0 and delete m (atomic)</span>
	fastrand      [<span class="hljs-number">2</span>]<span class="hljs-keyword">uint32</span>
	needextram    <span class="hljs-keyword">bool</span>
    traceback     <span class="hljs-keyword">uint8</span>
	...<span class="hljs-comment">//里面一些cgo的代码</span>
	park          note
    alllink       *m <span class="hljs-comment">// on allm</span>
    <span class="hljs-comment">//调度链，是一个m的指针</span>
    schedlink     muintptr
	<span class="hljs-comment">//每一个P(Per-thread)的用于存储小对象的cache,没有锁，因为都在一个P内，运行代码时绑定的p中的mcache</span>
    mcache        *mcache
    
	<span class="hljs-comment">//goroutine的指针,uintptr可以避过写屏障, 主要用于Gobuf goroutine状态或者是那些不经过P的调度列表</span>
	<span class="hljs-comment">//是否与某个g一直绑定</span>
    lockedg       guintptr
    <span class="hljs-comment">//创建当前thread的栈</span>
	createstack   [<span class="hljs-number">32</span>]<span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// stack that created this thread.</span>
    
    ...<span class="hljs-comment">//track用</span>
    <span class="hljs-comment">//下一个等待锁的M</span>
	nextwaitm     muintptr    <span class="hljs-comment">// next m waiting for lock</span>
    <span class="hljs-comment">//一些锁的操作</span>
    waitunlockf   <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*g, unsafe.Pointer)</span> <span class="hljs-title">bool</span>
	<span class="hljs-title">waitlock</span>      <span class="hljs-title">unsafe</span>.<span class="hljs-title">Pointer</span>
	<span class="hljs-title">waittraceev</span>   <span class="hljs-title">byte</span>
	<span class="hljs-title">waittraceskip</span> <span class="hljs-title">int</span>
	<span class="hljs-title">startingtrace</span> <span class="hljs-title">bool</span>
	<span class="hljs-title">syscalltick</span>   <span class="hljs-title">uint32</span>
	<span class="hljs-title">thread</span>        <span class="hljs-title">uintptr</span> // <span class="hljs-title">thread</span> <span class="hljs-title">handle</span>
	<span class="hljs-title">freelink</span>      *<span class="hljs-title">m</span>      // <span class="hljs-title">on</span> <span class="hljs-title">sched</span>.<span class="hljs-title">freem</span>
    ...
    //<span class="hljs-title">debug</span>
	<span class="hljs-title">dlogPerM</span>
    //表明操作系统相关
	<span class="hljs-title">mOS</span>
&#125;</span></code></pre></div>
<h4 id="p-process">P（Process）</h4>
<p>指的是go语言中的调度器，M就是用P才能调度G;</p>
<p>可以看到P是内嵌于 M 和 G 之间的，其提供线程需要的上下文，都会负责调度线程上的waitq，使每个M可以执行多个G，并在IO时候切换G，提高效率;</p>
<p><code>p.status</code>字段也有几种状态:</p>
<ol>
<li><code>_Pidle</code>:处理器没有运行用户代码或者调度器，被空闲队列或者改变其状态的结构持有，运行队列为空</li>
<li><code>_Prunning</code>:被线程 M 持有，并且正在执行用户代码或者调度器</li>
<li><code>_Psyscall</code>:没有执行用户代码，当前线程陷入系统调用</li>
<li><code>_Pgcstop</code>:被线程 M 持有，当前处理器由于垃圾回收被停止</li>
<li><code>_Pdead</code>:当前处理器已经不被使用</li>
</ol>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> p <span class="hljs-keyword">struct</span> &#123;
    <span class="hljs-comment">//每一个p都有自己的id</span>
    id          <span class="hljs-keyword">int32</span>
    <span class="hljs-comment">//状态，有_Pidle ,_Prunning,_Psyscall, _Pgcstop, _Pdead</span>
    status      <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// one of pidle/prunning/...</span>
    
    link        puintptr
    
    <span class="hljs-comment">//每次调度都会自增</span>
	schedtick   <span class="hljs-keyword">uint32</span>     <span class="hljs-comment">// incremented on every scheduler call</span>
    syscalltick <span class="hljs-keyword">uint32</span>     <span class="hljs-comment">// incremented on every system call</span>
    <span class="hljs-comment">//go程序启动时候的sysmon用</span>
    sysmontick  sysmontick <span class="hljs-comment">// last tick observed by sysmon</span>
    <span class="hljs-comment">//指的是后面指针连接的一个m,同时该m也有一个指针连向自己 ???</span>
    m           muintptr   <span class="hljs-comment">// back-link to associated m (nil if idle)</span>
    <span class="hljs-comment">//</span>
	mcache      *mcache
	raceprocctx <span class="hljs-keyword">uintptr</span>

    <span class="hljs-comment">//defer的池,defer函数，结构在此</span>
	deferpool    [<span class="hljs-number">5</span>][]*_defer <span class="hljs-comment">// pool of available defer structs of different sizes (see panic.go)</span>
	deferpoolbuf [<span class="hljs-number">5</span>][<span class="hljs-number">32</span>]*_defer

    <span class="hljs-comment">//goroutine的id生成，能平均分到每一个idgen中</span>
	<span class="hljs-comment">// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.</span>
	goidcache    <span class="hljs-keyword">uint64</span>
	goidcacheend <span class="hljs-keyword">uint64</span>


    <span class="hljs-comment">//这个就是连接的可运行的goroutines队列,可以不加锁访问（都在一个P里面，没必要加锁）</span>
	<span class="hljs-comment">// Queue of runnable goroutines. Accessed without lock.</span>
	runqhead <span class="hljs-keyword">uint32</span>
	runqtail <span class="hljs-keyword">uint32</span>
	runq     [<span class="hljs-number">256</span>]guintptr
	<span class="hljs-comment">// runnext, if non-nil, is a runnable G that was ready'd by</span>
	<span class="hljs-comment">// the current G and should be run next instead of what's in</span>
	<span class="hljs-comment">// runq if there's time remaining in the running G's time</span>
	<span class="hljs-comment">// slice. It will inherit the time left in the current time</span>
	<span class="hljs-comment">// slice. If a set of goroutines is locked in a</span>
	<span class="hljs-comment">// communicate-and-wait pattern, this schedules that set as a</span>
	<span class="hljs-comment">// unit and eliminates the (potentially large) scheduling</span>
	<span class="hljs-comment">// latency that otherwise arises from adding the ready'd</span>
	<span class="hljs-comment">// goroutines to the end of the run queue.</span>
	<span class="hljs-comment">//如果runnext非空，则是一个runnable状态的g，如果在当前时间片中还有剩余，则runnext指向的就是下一个应该运行的g而不使用runq里面的g，其会继承剩下的时间；</span>
	runnext guintptr

	<span class="hljs-comment">// Available G's (status == Gdead)</span>
	gFree <span class="hljs-keyword">struct</span> &#123;
		gList
		n <span class="hljs-keyword">int32</span>
	&#125;

    <span class="hljs-comment">//sudog相关</span>
	sudogcache []*sudog
	sudogbuf   [<span class="hljs-number">128</span>]*sudog

	...<span class="hljs-comment">//trace的一些东西</span>

	palloc persistentAlloc <span class="hljs-comment">// per-P to avoid mutex</span>

    <span class="hljs-comment">//用作优化内存对齐</span>
	_ <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// Alignment for atomic fields below</span>

	<span class="hljs-comment">// Per-P GC state</span>
	gcAssistTime         <span class="hljs-keyword">int64</span>    <span class="hljs-comment">// Nanoseconds in assistAlloc</span>
	gcFractionalMarkTime <span class="hljs-keyword">int64</span>    <span class="hljs-comment">// Nanoseconds in fractional mark worker (atomic)</span>
	gcBgMarkWorker       guintptr <span class="hljs-comment">// (atomic)</span>
	gcMarkWorkerMode     gcMarkWorkerMode

	<span class="hljs-comment">// gcMarkWorkerStartTime is the nanotime() at which this mark</span>
	<span class="hljs-comment">// worker started.</span>
	gcMarkWorkerStartTime <span class="hljs-keyword">int64</span>

	<span class="hljs-comment">// gcw is this P's GC work buffer cache. The work buffer is</span>
	<span class="hljs-comment">// filled by write barriers, drained by mutator assists, and</span>
	<span class="hljs-comment">// disposed on certain GC state transitions.</span>
	gcw gcWork

	<span class="hljs-comment">// wbBuf is this P's GC write barrier buffer.</span>
	<span class="hljs-comment">//</span>
	<span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Consider caching this in the running G.</span>
	wbBuf wbBuf

	runSafePointFn <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// if 1, run sched.safePointFn at next safe point</span>

	pad cpu.CacheLinePad
&#125;</code></pre></div>
<p>ps：其实可以注意下<code>p.runq</code>是一个256位(？？？这里为什么是256呢，有一个讲法就是一般一个cache line是128，在多核情况下，256的设置会避免拿cache的失败)的循环列表</p>
<h3 id="scheddt-调度器">SchedDt 调度器</h3>
<p>主要在<code>runtime.schedinit()</code>上:</p>
<ul>
<li>设置了maxcount，可以有10000个线程，但是同时运行的线程仍然受<code>GOMAXPROCS</code>设置影响</li>
<li>获取最大运行procs后会调用<code>procresize</code>来更新程序中处理器数量，调度器进入锁定状态，不会执行任何goroutine</li>
</ul>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// The bootstrap sequence is:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//	call osinit</span>
<span class="hljs-comment">//	call schedinit</span>
<span class="hljs-comment">//	make &amp; queue new G</span>
<span class="hljs-comment">//	call runtime·mstart</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// The new G calls runtime·main.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">schedinit</span><span class="hljs-params">()</span></span> &#123;
		<span class="hljs-comment">// raceinit must be the first call to race detector.</span>
	<span class="hljs-comment">// In particular, it must be done before mallocinit below calls racemapshadow.</span>
	_g_ := getg()
	...
	sched.maxmcount = <span class="hljs-number">10000</span>
	....
	sched.lastpoll = <span class="hljs-keyword">uint64</span>(nanotime())
	procs := ncpu
	<span class="hljs-keyword">if</span> n, ok := atoi32(gogetenv(<span class="hljs-string">"GOMAXPROCS"</span>)); ok &amp;&amp; n &gt; <span class="hljs-number">0</span> &#123;
		procs = n
	&#125;
	<span class="hljs-keyword">if</span> procresize(procs) != <span class="hljs-literal">nil</span> &#123;
		throw(<span class="hljs-string">"unknown runnable goroutine during bootstrap"</span>)
	&#125;
&#125;</code></pre></div>
<p>P在GOMAXPROCS中，所有的P被组织成一个数组，当GOMAXPROCS改变时会触发 stop the world来重新调整P 数组的长度
一些变量会从sched中分离出到P中
<code>procresize</code>大概流程:</p>
<ol>
<li>如果全局<code>allp</code> slice 小于期望值，会对其扩容</li>
<li>new一个新的处理器结构体，并调用<code>runtime.p.init</code>方法初始化(会将其状态设为<code>_Pgcstop</code>,这个函数可用于创建新的p或复用之前销毁的p)；</li>
<li>将<code>m0</code>和<code>allp[0]</code>绑定(如果目前m持有p的话，会继续使用该P，但是是另外一个地方<code>startTheWorldWithSema</code>使用<code>procresize</code>方法，这里<code>schedinit</code>是不可能进入的)</li>
<li><code>destroy</code>方法释放不使用的旧P</li>
<li>Trim一下<code>allp</code>使其跟传入的<code>nproc</code>长度相等</li>
<li>初始化所有p(除了<code>allp[0]</code> ???为什么呢，因为m0和allp[0]绑定)的状态为<code>_Pidle</code></li>
</ol>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// Change number of processors. The world is stopped, sched is locked.</span>
<span class="hljs-comment">// gcworkbufs are not being modified by either the GC or</span>
<span class="hljs-comment">// the write barrier code.</span>
<span class="hljs-comment">// Returns list of Ps with local work, they need to be scheduled by the caller.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">procresize</span><span class="hljs-params">(nprocs <span class="hljs-keyword">int32</span>)</span> *<span class="hljs-title">p</span></span> &#123;
	old := gomaxprocs
	<span class="hljs-keyword">if</span> old &lt; <span class="hljs-number">0</span> || nprocs &lt;= <span class="hljs-number">0</span> &#123;
		throw(<span class="hljs-string">"procresize: invalid arg"</span>)
	&#125;
	<span class="hljs-keyword">if</span> trace.enabled &#123;
		traceGomaxprocs(nprocs)
	&#125;

	<span class="hljs-comment">// update statistics</span>
	now := nanotime()
	<span class="hljs-keyword">if</span> sched.procresizetime != <span class="hljs-number">0</span> &#123;
		sched.totaltime += <span class="hljs-keyword">int64</span>(old) * (now - sched.procresizetime)
	&#125;
	sched.procresizetime = now

	<span class="hljs-comment">// Grow allp if necessary.</span>
	<span class="hljs-comment">//1. 扩容allp</span>
	<span class="hljs-keyword">if</span> nprocs &gt; <span class="hljs-keyword">int32</span>(<span class="hljs-built_in">len</span>(allp)) &#123;
		<span class="hljs-comment">// Synchronize with retake, which could be running</span>
		<span class="hljs-comment">// concurrently since it doesn't run on a P.</span>
		lock(&amp;allpLock)
		<span class="hljs-keyword">if</span> nprocs &lt;= <span class="hljs-keyword">int32</span>(<span class="hljs-built_in">cap</span>(allp)) &#123;
			allp = allp[:nprocs]
		&#125; <span class="hljs-keyword">else</span> &#123;
			nallp := <span class="hljs-built_in">make</span>([]*p, nprocs)
			<span class="hljs-comment">// Copy everything up to allp's cap so we</span>
			<span class="hljs-comment">// never lose old allocated Ps.</span>
			<span class="hljs-built_in">copy</span>(nallp, allp[:<span class="hljs-built_in">cap</span>(allp)])
			allp = nallp
		&#125;
		unlock(&amp;allpLock)
	&#125;

	<span class="hljs-comment">// initialize new P's</span>
	<span class="hljs-comment">//2. 初始化新P</span>
	<span class="hljs-keyword">for</span> i := old; i &lt; nprocs; i++ &#123;
		pp := allp[i]
		<span class="hljs-keyword">if</span> pp == <span class="hljs-literal">nil</span> &#123;
			pp = <span class="hljs-built_in">new</span>(p)
		&#125;
		pp.init(i)
		atomicstorep(unsafe.Pointer(&amp;allp[i]), unsafe.Pointer(pp))
	&#125;

	_g_ := getg()
	<span class="hljs-keyword">if</span> _g_.m.p != <span class="hljs-number">0</span> &amp;&amp; _g_.m.p.ptr().id &lt; nprocs &#123;
		<span class="hljs-comment">// continue to use the current P</span>
		_g_.m.p.ptr().status = _Prunning
		_g_.m.p.ptr().mcache.prepareForSweep()
	&#125; <span class="hljs-keyword">else</span> &#123;
		<span class="hljs-comment">//3. 将`m0`和`allp[0]`绑定???</span>
		<span class="hljs-comment">// release the current P and acquire allp[0].</span>
		<span class="hljs-comment">//</span>
		<span class="hljs-comment">// We must do this before destroying our current P</span>
		<span class="hljs-comment">// because p.destroy itself has write barriers, so we</span>
		<span class="hljs-comment">// need to do that from a valid P.</span>
		<span class="hljs-keyword">if</span> _g_.m.p != <span class="hljs-number">0</span> &#123;
			<span class="hljs-keyword">if</span> trace.enabled &#123;
				<span class="hljs-comment">// Pretend that we were descheduled</span>
				<span class="hljs-comment">// and then scheduled again to keep</span>
				<span class="hljs-comment">// the trace sane.</span>
				traceGoSched()
				traceProcStop(_g_.m.p.ptr())
			&#125;
			_g_.m.p.ptr().m = <span class="hljs-number">0</span>
		&#125;
		_g_.m.p = <span class="hljs-number">0</span>
		_g_.m.mcache = <span class="hljs-literal">nil</span>
		p := allp[<span class="hljs-number">0</span>]
		p.m = <span class="hljs-number">0</span>
		p.status = _Pidle
		acquirep(p)
		<span class="hljs-keyword">if</span> trace.enabled &#123;
			traceGoStart()
		&#125;
	&#125;

	<span class="hljs-comment">// release resources from unused P's</span>
	<span class="hljs-keyword">for</span> i := nprocs; i &lt; old; i++ &#123;
		p := allp[i]
		p.destroy()
		<span class="hljs-comment">// can't free P itself because it can be referenced by an M in syscall</span>
	&#125;

	<span class="hljs-comment">// Trim allp.</span>
	<span class="hljs-keyword">if</span> <span class="hljs-keyword">int32</span>(<span class="hljs-built_in">len</span>(allp)) != nprocs &#123;
		lock(&amp;allpLock)
		allp = allp[:nprocs]
		unlock(&amp;allpLock)
	&#125;

	<span class="hljs-keyword">var</span> runnablePs *p
	<span class="hljs-keyword">for</span> i := nprocs - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;
		p := allp[i]
		<span class="hljs-keyword">if</span> _g_.m.p.ptr() == p &#123;
			<span class="hljs-keyword">continue</span>
		&#125;
		p.status = _Pidle
		<span class="hljs-keyword">if</span> runqempty(p) &#123;
			pidleput(p)
		&#125; <span class="hljs-keyword">else</span> &#123;
			p.m.set(mget())
			p.link.set(runnablePs)
			runnablePs = p
		&#125;
	&#125;
	stealOrder.reset(<span class="hljs-keyword">uint32</span>(nprocs))
	<span class="hljs-keyword">var</span> int32p *<span class="hljs-keyword">int32</span> = &amp;gomaxprocs <span class="hljs-comment">// make compiler check that gomaxprocs is an int32</span>
	atomic.Store((*<span class="hljs-keyword">uint32</span>)(unsafe.Pointer(int32p)), <span class="hljs-keyword">uint32</span>(nprocs))
	<span class="hljs-keyword">return</span> runnablePs
&#125;</code></pre></div>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> schedt <span class="hljs-keyword">struct</span>&#123;
	lock mutex<span class="hljs-comment">//锁用于调用globalq的时候使用</span>

	<span class="hljs-comment">// When increasing nmidle, nmidlelocked, nmsys, or nmfreed, be</span>
	<span class="hljs-comment">// sure to call checkdead().</span>
	<span class="hljs-comment">//空闲的m</span>
	midle        muintptr <span class="hljs-comment">// idle m's waiting for work</span>
	nmidle       <span class="hljs-keyword">int32</span>    <span class="hljs-comment">// number of idle m's waiting for work</span>
	nmidlelocked <span class="hljs-keyword">int32</span>    <span class="hljs-comment">// number of locked m's waiting for work</span>
	mnext        <span class="hljs-keyword">int64</span>    <span class="hljs-comment">// number of m's that have been created and next M ID</span>
	maxmcount    <span class="hljs-keyword">int32</span>    <span class="hljs-comment">// maximum number of m's allowed (or die)</span>
	nmsys        <span class="hljs-keyword">int32</span>    <span class="hljs-comment">// number of system m's not counted for deadlock</span>
	nmfreed      <span class="hljs-keyword">int64</span>    <span class="hljs-comment">// cumulative number of freed m's</span>

	ngsys <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// number of system goroutines; updated atomically</span>
	<span class="hljs-comment">//空闲的p</span>
	pidle      puintptr <span class="hljs-comment">// idle p's</span>
	npidle     <span class="hljs-keyword">uint32</span>
	<span class="hljs-comment">//在spinning状态的m的数量</span>
	nmspinning <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// See "Worker thread parking/unparking" comment in proc.go.</span>

	<span class="hljs-comment">// Global runnable queue.</span>
	<span class="hljs-comment">//可运行 的globalq</span>
	runq     gQueue
	runqsize <span class="hljs-keyword">int32</span>

	<span class="hljs-comment">// disable controls selective disabling of the scheduler.</span>
	<span class="hljs-comment">//</span>
	<span class="hljs-comment">// Use schedEnableUser to control this.</span>
	<span class="hljs-comment">//</span>
	<span class="hljs-comment">// disable is protected by sched.lock.</span>
	disable <span class="hljs-keyword">struct</span> &#123;
		<span class="hljs-comment">// user disables scheduling of user goroutines.</span>
		user     <span class="hljs-keyword">bool</span>
		runnable gQueue <span class="hljs-comment">// pending runnable Gs</span>
		n        <span class="hljs-keyword">int32</span>  <span class="hljs-comment">// length of runnable</span>
	&#125;

	<span class="hljs-comment">// Global cache of dead G's.</span>
	<span class="hljs-comment">//全局空余剩下的g</span>
	gFree <span class="hljs-keyword">struct</span> &#123;
		lock    mutex
		stack   gList <span class="hljs-comment">// Gs with stacks</span>
		noStack gList <span class="hljs-comment">// Gs without stacks</span>
		n       <span class="hljs-keyword">int32</span>
	&#125;
&#125;</code></pre></div>
<p>相关结构可以在runtime/runtime2.go 中找到</p>
<h3 id="生成新的goroutine">生成新的goroutine</h3>
<p>语言层面上，当然是编译器先检查有无<code>go</code>关键字，在编译期:
<code>cmd/compile/internal/gc.state.stmt</code>和<code>cmd/compile/internal/gc.state.call</code>会将其转换成<code>runtime.newproc</code>函数</p>
<p>??? 不懂，ssa要学一下才行了</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *state)</span> <span class="hljs-title">call</span><span class="hljs-params">(n *Node, k callKind)</span> *<span class="hljs-title">ssa</span>.<span class="hljs-title">Value</span></span> &#123;
	<span class="hljs-keyword">if</span> k == callDeferStack &#123;
		...
	&#125; <span class="hljs-keyword">else</span> &#123;
		<span class="hljs-keyword">switch</span> &#123;
		<span class="hljs-keyword">case</span> k == callGo:
			call = s.newValue1A(ssa.OpStaticCall, types.TypeMem, newproc, s.mem())
		<span class="hljs-keyword">default</span>:
		&#125;
	&#125;
	...
&#125;</code></pre></div>
<p><code>runtime.newproc</code>函数，传入siz，还有go后面接着的function，因为其假定了<strong>函数的传入参数一定跟在fn的地址后面</strong>，如果split了栈，则无法寻找到对应的传入参数，所以加上nosplit</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// Create a new g running fn with siz bytes of arguments.</span>
<span class="hljs-comment">// Put it on the queue of g's waiting to run.</span>
<span class="hljs-comment">// The compiler turns a go statement into a call to this.</span>
<span class="hljs-comment">// Cannot split the stack because it assumes that the arguments</span>
<span class="hljs-comment">// are available sequentially after &amp;fn; they would not be</span>
<span class="hljs-comment">// copied if a stack split occurred.</span>
<span class="hljs-comment">//go:nosplit</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newproc</span><span class="hljs-params">(siz <span class="hljs-keyword">int32</span>, fn *funcval)</span></span> &#123;
	argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)
	gp := getg()
	pc := getcallerpc()
	systemstack(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
		newproc1(fn, argp, siz, gp, pc)
	&#125;)
&#125;</code></pre></div>
<p>注意到会在系统栈下调用<code>newproc1</code>，传入的是go关键字后函数的地址，这个函数caller的pc值、goroutine，传入参数地址大小等等信息</p>
<ol>
<li>首先就是创建<code>newg</code>,会调用<code>gfget</code>从<code>gfree</code>列表拿到空闲的goroutine或者创建一个新的goroutine</li>
</ol>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// Create a new g running fn with narg bytes of arguments starting</span>
<span class="hljs-comment">// at argp. callerpc is the address of the go statement that created</span>
<span class="hljs-comment">// this. The new g is put on the queue of g's waiting to run.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newproc1</span><span class="hljs-params">(fn *funcval, argp unsafe.Pointer, narg <span class="hljs-keyword">int32</span>, callergp *g, callerpc <span class="hljs-keyword">uintptr</span>)</span></span> &#123;
	_g_ := getg()

	<span class="hljs-keyword">if</span> fn == <span class="hljs-literal">nil</span> &#123;
		_g_.m.throwing = <span class="hljs-number">-1</span> <span class="hljs-comment">// do not dump full stacks</span>
		throw(<span class="hljs-string">"go of nil func value"</span>)
	&#125;
	acquirem() <span class="hljs-comment">// disable preemption because it can be holding p in a local var</span>
	siz := narg
	siz = (siz + <span class="hljs-number">7</span>) &amp;^ <span class="hljs-number">7</span>

	<span class="hljs-comment">// We could allocate a larger initial stack if necessary.</span>
	<span class="hljs-comment">// Not worth it: this is almost always an error.</span>
	<span class="hljs-comment">// 4*sizeof(uintreg): extra space added below</span>
	<span class="hljs-comment">// sizeof(uintreg): caller's LR (arm) or return address (x86, in gostartcall).</span>
	<span class="hljs-keyword">if</span> siz &gt;= _StackMin<span class="hljs-number">-4</span>*sys.RegSize-sys.RegSize &#123;
		throw(<span class="hljs-string">"newproc: function arguments too large for new goroutine"</span>)
	&#125;

	_p_ := _g_.m.p.ptr()
	newg := gfget(_p_)
	<span class="hljs-keyword">if</span> newg == <span class="hljs-literal">nil</span> &#123;
		newg = malg(_StackMin)
		casgstatus(newg, _Gidle, _Gdead)
		allgadd(newg) <span class="hljs-comment">// publishes with a g-&gt;status of Gdead so GC scanner doesn't look at uninitialized stack.</span>
	&#125;
	...
&#125;</code></pre></div>
<p>注意到获得<code>newg</code>的方法中，有<code>gfget</code>和<code>malg</code>两种</p>
<ul>
<li>
<p><code>gfget</code>:如果是当前p的<code>gfree</code> list为空，就从全局调度器<code>sched.gFree</code>转移到当前p上，上限为32;</p>
</li>
<li>
<p>如果充足的话就会从<code>gfree</code>列表<strong>头部</strong>返回一个新的goroutine；</p>
</li>
</ul>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// Get from gfree list.</span>
<span class="hljs-comment">// If local list is empty, grab a batch from global list.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gfget</span><span class="hljs-params">(_p_ *p)</span> *<span class="hljs-title">g</span></span> &#123;
retry:
	<span class="hljs-keyword">if</span> _p_.gFree.empty() &amp;&amp; (!sched.gFree.stack.empty() || !sched.gFree.noStack.empty()) &#123;
		lock(&amp;sched.gFree.lock)
		<span class="hljs-comment">// Move a batch of free Gs to the P.</span>
		<span class="hljs-keyword">for</span> _p_.gFree.n &lt; <span class="hljs-number">32</span> &#123;
			<span class="hljs-comment">// Prefer Gs with stacks.</span>
			gp := sched.gFree.stack.pop()
			<span class="hljs-keyword">if</span> gp == <span class="hljs-literal">nil</span> &#123;
				gp = sched.gFree.noStack.pop()
				<span class="hljs-keyword">if</span> gp == <span class="hljs-literal">nil</span> &#123;
					<span class="hljs-keyword">break</span>
				&#125;
			&#125;
			sched.gFree.n--
			_p_.gFree.push(gp)
			_p_.gFree.n++
		&#125;
		unlock(&amp;sched.gFree.lock)
		<span class="hljs-keyword">goto</span> retry
	&#125;</code></pre></div>
<ul>
<li><code>malg</code>:
call <code>newg</code>方法，然后分配2KB栈空间,
并且其返回的值，会放入到全局<code>allg</code> slice上面，因为是<code>Gdead</code>状态，所以gc也不会扫描这个未初始化的栈</li>
</ul>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// Allocate a new g, with a stack big enough for stacksize bytes.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">malg</span><span class="hljs-params">(stacksize <span class="hljs-keyword">int32</span>)</span> *<span class="hljs-title">g</span></span> &#123;
	newg := <span class="hljs-built_in">new</span>(g)
	<span class="hljs-keyword">if</span> stacksize &gt;= <span class="hljs-number">0</span> &#123;
		<span class="hljs-comment">//stacksize = 2KB</span>
		stacksize = round2(_StackSystem + stacksize)
		systemstack(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
			newg.stack = stackalloc(<span class="hljs-keyword">uint32</span>(stacksize))
		&#125;)
		newg.stackguard0 = newg.stack.lo + _StackGuard
		newg.stackguard1 = ^<span class="hljs-keyword">uintptr</span>(<span class="hljs-number">0</span>)
		<span class="hljs-comment">// Clear the bottom word of the stack. We record g</span>
		<span class="hljs-comment">// there on gsignal stack during VDSO on ARM and ARM64.</span>
		*(*<span class="hljs-keyword">uintptr</span>)(unsafe.Pointer(newg.stack.lo)) = <span class="hljs-number">0</span>
	&#125;
	<span class="hljs-keyword">return</span> newg
&#125;</code></pre></div>
<ol start="2">
<li>接下来就用<code>memove</code>copy fn的所有参数到栈中,<code>argp</code>和<code>narg</code>分别为参数内存地址和大小</li>
</ol>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newproc1</span><span class="hljs-params">(fn *funcval, argp unsafe.Pointer, narg <span class="hljs-keyword">int32</span>, callergp *g, callerpc <span class="hljs-keyword">uintptr</span>)</span></span> &#123;
	....
	totalSize := <span class="hljs-number">4</span>*sys.RegSize + <span class="hljs-keyword">uintptr</span>(siz) + sys.MinFrameSize <span class="hljs-comment">// extra space in case of reads slightly beyond frame</span>
	totalSize += -totalSize &amp; (sys.SpAlign - <span class="hljs-number">1</span>)                  <span class="hljs-comment">// align to spAlign</span>
	sp := newg.stack.hi - totalSize
	<span class="hljs-comment">//栈的地址</span>
	spArg := sp
	<span class="hljs-keyword">if</span> usesLR &#123;
		<span class="hljs-comment">// caller's LR</span>
		*(*<span class="hljs-keyword">uintptr</span>)(unsafe.Pointer(sp)) = <span class="hljs-number">0</span>
		prepGoExitFrame(sp)
		spArg += sys.MinFrameSize
	&#125;
	<span class="hljs-keyword">if</span> narg &gt; <span class="hljs-number">0</span> &#123;
		memmove(unsafe.Pointer(spArg), argp, <span class="hljs-keyword">uintptr</span>(narg))
		<span class="hljs-comment">// This is a stack-to-stack copy. If write barriers</span>
		<span class="hljs-comment">// are enabled and the source stack is grey (the</span>
		<span class="hljs-comment">// destination is always black), then perform a</span>
		<span class="hljs-comment">// barrier copy. We do this *after* the memmove</span>
		<span class="hljs-comment">// because the destination stack may have garbage on</span>
		<span class="hljs-comment">// it.</span>
		<span class="hljs-keyword">if</span> writeBarrier.needed &amp;&amp; !_g_.m.curg.gcscandone &#123;
			f := findfunc(fn.fn)
			stkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))
			<span class="hljs-keyword">if</span> stkmap.nbit &gt; <span class="hljs-number">0</span> &#123;
				<span class="hljs-comment">// We're in the prologue, so it's always stack map index 0.</span>
				bv := stackmapdata(stkmap, <span class="hljs-number">0</span>)
				bulkBarrierBitmap(spArg, spArg, <span class="hljs-keyword">uintptr</span>(bv.n)*sys.PtrSize, <span class="hljs-number">0</span>, bv.bytedata)
			&#125;
		&#125;
	&#125;
	...</code></pre></div>
<ol start="3">
<li>然后复制之后，继续设置一些新的结构体(栈指针sp，pc等等)，并将其状态改为<code>Grunnable</code></li>
</ol>
<p>其中<code>gostartcallfn</code>方法在(后面)[#调度循环]会详细聊到</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newproc1</span><span class="hljs-params">(fn *funcval, argp unsafe.Pointer, narg <span class="hljs-keyword">int32</span>, callergp *g, callerpc <span class="hljs-keyword">uintptr</span>)</span></span> &#123;
	...
	<span class="hljs-comment">//// memclrNoHeapPointers clears n bytes starting at ptr.</span>
	<span class="hljs-comment">//清除所有sched</span>
	memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))
	newg.sched.sp = sp
	newg.stktopsp = sp

	<span class="hljs-comment">//注意这里， 将pc改为,runtime.goexit 函数和</span>
	<span class="hljs-comment">//将g改为新的goroutine</span>
	newg.sched.pc = funcPC(goexit) + sys.PCQuantum <span class="hljs-comment">// +PCQuantum so that previous instruction is in same function</span>
	newg.sched.g = guintptr(unsafe.Pointer(newg))
	gostartcallfn(&amp;newg.sched, fn)


	newg.gopc = callerpc
	newg.ancestors = saveAncestors(callergp)
	newg.startpc = fn.fn
	<span class="hljs-keyword">if</span> _g_.m.curg != <span class="hljs-literal">nil</span> &#123;
		newg.labels = _g_.m.curg.labels
	&#125;
	<span class="hljs-keyword">if</span> isSystemGoroutine(newg, <span class="hljs-literal">false</span>) &#123;
		atomic.Xadd(&amp;sched.ngsys, +<span class="hljs-number">1</span>)
	&#125;
	<span class="hljs-comment">//更改状态</span>
	casgstatus(newg, _Gdead, _Grunnable)

	<span class="hljs-keyword">if</span> _p_.goidcache == _p_.goidcacheend &#123;
		<span class="hljs-comment">// Sched.goidgen is the last allocated id,</span>
		<span class="hljs-comment">// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].</span>
		<span class="hljs-comment">// At startup sched.goidgen=0, so main goroutine receives goid=1.</span>
		_p_.goidcache = atomic.Xadd64(&amp;sched.goidgen, _GoidCacheBatch)
		_p_.goidcache -= _GoidCacheBatch - <span class="hljs-number">1</span>
		_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch
	&#125;
	newg.goid = <span class="hljs-keyword">int64</span>(_p_.goidcache)
	_p_.goidcache++
	...</code></pre></div>
<ol start="4">
<li>最后将初始化好的goroutine放入runq</li>
</ol>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">//接上面</span>
...
<span class="hljs-comment">//放入runq,传入是true，放入runnext，如果是false就会放入runq的尾部</span>
runqput(_p_, newg, <span class="hljs-literal">true</span>)

<span class="hljs-keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="hljs-number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="hljs-number">0</span> &amp;&amp; mainStarted &#123;
	wakep()
&#125;
releasem(_g_.m)</code></pre></div>
<p>注意这个<code>runqput</code>方法中</p>
<ul>
<li>首先会将其放入local runnable q，并将其放入<code>_p_.runnext</code></li>
<li>如果传入next为<code>false</code>且本地runq未满，就会放入本地runq尾部</li>
<li>如果传入next为<code>true</code>,并将其放入<code>_p_.runnext</code></li>
<li>如果本地runq满了，runnext会将其放入全局<code>sched.runq</code>(这里创建goroutine传入的是true)</li>
<li>这个只会被其拥有者P运行;</li>
</ul>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// runqput tries to put g on the local runnable queue.</span>
<span class="hljs-comment">// If next is false, runqput adds g to the tail of the runnable queue.</span>
<span class="hljs-comment">// If next is true, runqput puts g in the _p_.runnext slot.</span>
<span class="hljs-comment">// If the run queue is full, runnext puts g on the global queue.</span>
<span class="hljs-comment">// Executed only by the owner P.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runqput</span><span class="hljs-params">(_p_ *p, gp *g, next <span class="hljs-keyword">bool</span>)</span></span> &#123;
	<span class="hljs-keyword">if</span> randomizeScheduler &amp;&amp; next &amp;&amp; fastrand()%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;
		next = <span class="hljs-literal">false</span>
	&#125;

	<span class="hljs-keyword">if</span> next &#123;
	retryNext:
		oldnext := _p_.runnext
		<span class="hljs-keyword">if</span> !_p_.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) &#123;
			<span class="hljs-keyword">goto</span> retryNext
		&#125;
		<span class="hljs-keyword">if</span> oldnext == <span class="hljs-number">0</span> &#123;
			<span class="hljs-keyword">return</span>
		&#125;
		<span class="hljs-comment">// Kick the old runnext out to the regular run queue.</span>
		gp = oldnext.ptr()
	&#125;
retry:
	h := atomic.LoadAcq(&amp;_p_.runqhead) <span class="hljs-comment">// load-acquire, synchronize with consumers</span>
	t := _p_.runqtail
	<span class="hljs-keyword">if</span> t-h &lt; <span class="hljs-keyword">uint32</span>(<span class="hljs-built_in">len</span>(_p_.runq)) &#123;
		_p_.runq[t%<span class="hljs-keyword">uint32</span>(<span class="hljs-built_in">len</span>(_p_.runq))].set(gp)
		atomic.StoreRel(&amp;_p_.runqtail, t+<span class="hljs-number">1</span>) <span class="hljs-comment">// store-release, makes the item available for consumption</span>
		<span class="hljs-keyword">return</span>
	&#125;
	<span class="hljs-keyword">if</span> runqputslow(_p_, gp, h, t) &#123;
		<span class="hljs-keyword">return</span>
	&#125;
	<span class="hljs-comment">// the queue is not full, now the put above must succeed</span>
	<span class="hljs-keyword">goto</span> retry
&#125;</code></pre></div>
<p>最后自选<code>wakeup</code>新的P来处理goroutine</p>
<h3 id="调度循环">调度循环</h3>
<p>上面提到<code>gostartcallfn</code>方法，其还会对<code>sched.pc</code>和<code>sched.sp</code>进行一些处理:
其注释说的就是还有一些对<code>g.sched</code>还有一些</p>
<ul>
<li>
<p>上面讲到pc实际上保存的就是程序接下来的运行地址,<code>buf.pc = uintptr(fn)</code>就是从fn开始运行</p>
</li>
<li>
<p>但是这个<code>sp</code>老实说我不看这文章我tm让我找都找不到原因;</p>
</li>
</ul>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// adjust Gobuf as if it executed a call to fn</span>
<span class="hljs-comment">// and then did an immediate gosave.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gostartcallfn</span><span class="hljs-params">(gobuf *gobuf, fv *funcval)</span></span> &#123;
	<span class="hljs-keyword">var</span> fn unsafe.Pointer
	<span class="hljs-keyword">if</span> fv != <span class="hljs-literal">nil</span> &#123;
		fn = unsafe.Pointer(fv.fn)
	&#125; <span class="hljs-keyword">else</span> &#123;
		fn = unsafe.Pointer(funcPC(nilfunc))
	&#125;
	gostartcall(gobuf, fn, unsafe.Pointer(fv))
&#125;


<span class="hljs-comment">// adjust Gobuf as if it executed a call to fn with context ctxt</span>
<span class="hljs-comment">// and then did an immediate gosave.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gostartcall</span><span class="hljs-params">(buf *gobuf, fn, ctxt unsafe.Pointer)</span></span> &#123;
	sp := buf.sp
	<span class="hljs-comment">//为什么???</span>
	<span class="hljs-keyword">if</span> sys.RegSize &gt; sys.PtrSize &#123;
		sp -= sys.PtrSize
		*(*<span class="hljs-keyword">uintptr</span>)(unsafe.Pointer(sp)) = <span class="hljs-number">0</span>
	&#125;
	sp -= sys.PtrSize
	*(*<span class="hljs-keyword">uintptr</span>)(unsafe.Pointer(sp)) = buf.pc
	buf.sp = sp
	buf.pc = <span class="hljs-keyword">uintptr</span>(fn)
	buf.ctxt = ctxt
&#125;</code></pre></div>
<h4 id="mstart开始">mstart开始</h4>
<p>调度从<code>runtime.mstart</code>开始，无栈要求，所以no split;其因为无P，所以暂时不需要写屏障;</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// mstart is the entry-point for new Ms.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// This must not split the stack because we may not even have stack</span>
<span class="hljs-comment">// bounds set up yet.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// May run during STW (because it doesn't have a P yet), so write</span>
<span class="hljs-comment">// barriers are not allowed.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//go:nosplit</span>
<span class="hljs-comment">//go:nowritebarrierrec</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mstart</span><span class="hljs-params">()</span></span> &#123;
	_g_ := getg()

	osStack := _g_.stack.lo == <span class="hljs-number">0</span>
	<span class="hljs-keyword">if</span> osStack &#123;
		<span class="hljs-comment">// Initialize stack bounds from system stack.</span>
		<span class="hljs-comment">// Cgo may have left stack size in stack.hi.</span>
		<span class="hljs-comment">// minit may update the stack bounds.</span>
		size := _g_.stack.hi
		<span class="hljs-keyword">if</span> size == <span class="hljs-number">0</span> &#123;
			size = <span class="hljs-number">8192</span> * sys.StackGuardMultiplier
		&#125;
		_g_.stack.hi = <span class="hljs-keyword">uintptr</span>(noescape(unsafe.Pointer(&amp;size)))
		_g_.stack.lo = _g_.stack.hi - size + <span class="hljs-number">1024</span>
	&#125;
	<span class="hljs-comment">// Initialize stack guard so that we can start calling regular</span>
	<span class="hljs-comment">// Go code.</span>
	_g_.stackguard0 = _g_.stack.lo + _StackGuard
	<span class="hljs-comment">// This is the g0, so we can also call go:systemstack</span>
	<span class="hljs-comment">// functions, which check stackguard1.</span>
	_g_.stackguard1 = _g_.stackguard0
	mstart1()

	<span class="hljs-comment">// Exit this thread.</span>
	<span class="hljs-keyword">switch</span> GOOS &#123;
	<span class="hljs-keyword">case</span> <span class="hljs-string">"windows"</span>, <span class="hljs-string">"solaris"</span>, <span class="hljs-string">"illumos"</span>, <span class="hljs-string">"plan9"</span>, <span class="hljs-string">"darwin"</span>, <span class="hljs-string">"aix"</span>:
		<span class="hljs-comment">// Windows, Solaris, illumos, Darwin, AIX and Plan 9 always system-allocate</span>
		<span class="hljs-comment">// the stack, but put it in _g_.stack before mstart,</span>
		<span class="hljs-comment">// so the logic above hasn't set osStack yet.</span>
		osStack = <span class="hljs-literal">true</span>
	&#125;
	mexit(osStack)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mstart1</span><span class="hljs-params">()</span></span> &#123;
	_g_ := getg()

	<span class="hljs-keyword">if</span> _g_ != _g_.m.g0 &#123;
		throw(<span class="hljs-string">"bad runtime·mstart"</span>)
	&#125;

	<span class="hljs-comment">// Record the caller for use as the top of stack in mcall and</span>
	<span class="hljs-comment">// for terminating the thread.</span>
	<span class="hljs-comment">// We're never coming back to mstart1 after we call schedule,</span>
	<span class="hljs-comment">// so other calls can reuse the current frame.</span>
	save(getcallerpc(), getcallersp())
	asminit()
	minit()

	<span class="hljs-comment">// Install signal handlers; after minit so that minit can</span>
	<span class="hljs-comment">// prepare the thread to be able to handle the signals.</span>
	<span class="hljs-keyword">if</span> _g_.m == &amp;m0 &#123;
		mstartm0()
	&#125;

	<span class="hljs-keyword">if</span> fn := _g_.m.mstartfn; fn != <span class="hljs-literal">nil</span> &#123;
		fn()
	&#125;

	<span class="hljs-keyword">if</span> _g_.m != &amp;m0 &#123;
		acquirep(_g_.m.nextp.ptr())
		_g_.m.nextp = <span class="hljs-number">0</span>
	&#125;
	schedule()
&#125;</code></pre></div>
<p><code>mstart</code>初始化了<code>stackguard0</code> 和 <code>stackguard1</code>，<code>mstart1()</code>调用<code>runtime.schedule()</code>
大概步骤:</p>
<ul>
<li>
<p>为了保证公平(可能两个goroutine互相切换)，一段时间（判断<code>g.schedtick</code>)会先检查全局队列，如果有，会从全局队列中拿一些goroutine来运行;</p>
</li>
<li>
<p>拿不到就接着从本地runq拿</p>
</li>
<li>
<p>再拿不到就要用<code>findrunnable</code>方法来拿,注意这个方法是阻塞的</p>
</li>
</ul>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// One round of scheduler: find a runnable goroutine and execute it.</span>
<span class="hljs-comment">// Never returns.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">schedule</span><span class="hljs-params">()</span></span> &#123;
	_g_ := getg()
	...
	top:
	pp := _g_.m.p.ptr()
	pp.preempt = <span class="hljs-literal">false</span>

	<span class="hljs-keyword">if</span> sched.gcwaiting != <span class="hljs-number">0</span> &#123;
		gcstopm()
		<span class="hljs-keyword">goto</span> top
	&#125;
	<span class="hljs-keyword">if</span> pp.runSafePointFn != <span class="hljs-number">0</span> &#123;
		runSafePointFn()
	&#125;

	<span class="hljs-comment">// Sanity check: if we are spinning, the run queue should be empty.</span>
	<span class="hljs-comment">// Check this before calling checkTimers, as that might call</span>
	<span class="hljs-comment">// goready to put a ready goroutine on the local run queue.</span>
	<span class="hljs-keyword">if</span> _g_.m.spinning &amp;&amp; (pp.runnext != <span class="hljs-number">0</span> || pp.runqhead != pp.runqtail) &#123;
		throw(<span class="hljs-string">"schedule: spinning with local work"</span>)
	&#125;

	checkTimers(pp, <span class="hljs-number">0</span>)

	<span class="hljs-keyword">var</span> gp *g
	<span class="hljs-keyword">var</span> inheritTime <span class="hljs-keyword">bool</span>
	...
	<span class="hljs-comment">//先检查全局队列</span>
	<span class="hljs-keyword">if</span> gp == <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-comment">// Check the global runnable queue once in a while to ensure fairness.</span>
		<span class="hljs-comment">// Otherwise two goroutines can completely occupy the local runqueue</span>
		<span class="hljs-comment">// by constantly respawning each other.</span>
		<span class="hljs-keyword">if</span> _g_.m.p.ptr().schedtick%<span class="hljs-number">61</span> == <span class="hljs-number">0</span> &amp;&amp; sched.runqsize &gt; <span class="hljs-number">0</span> &#123;
			lock(&amp;sched.lock)
			gp = globrunqget(_g_.m.p.ptr(), <span class="hljs-number">1</span>)
			unlock(&amp;sched.lock)
		&#125;
	&#125;
	<span class="hljs-keyword">if</span> gp == <span class="hljs-literal">nil</span> &#123;
		gp, inheritTime = runqget(_g_.m.p.ptr())
		<span class="hljs-comment">// We can see gp != nil here even if the M is spinning,</span>
		<span class="hljs-comment">// if checkTimers added a local goroutine via goready.</span>
	&#125;
	<span class="hljs-keyword">if</span> gp == <span class="hljs-literal">nil</span> &#123;
		gp, inheritTime = findrunnable() <span class="hljs-comment">// blocks until work is available</span>
	&#125;

&#125;</code></pre></div>
<p>下面是<code>findrunnable</code>的大概流程:</p>
<ul>
<li>从本地，全局队列拿</li>
<li>通过<code>runtime.runqsteal</code>尝试从其他处理器§拿goroutine，这个是随机获取(可以看一下<code>RandomOrder</code>这个结构,其方法保证了公平性)这个过程还可能将其计时器都拿过来(有什么用？？？针对该goroutine，可以保持时间继续？？？)</li>
<li>还找不到，就从netpoll里面拿;</li>
<li>最后跑到<code>runtime.execute</code>方法执行获取的goroutine，做好准备工作后，就通过<code>runtime.gogo</code>(汇编，之前的文章提到过)将goroutine调度到当前线程上;</li>
</ul>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// Schedules gp to run on the current M.</span>
<span class="hljs-comment">// If inheritTime is true, gp inherits the remaining time in the</span>
<span class="hljs-comment">// current time slice. Otherwise, it starts a new time slice.</span>
<span class="hljs-comment">// Never returns.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Write barriers are allowed because this is called immediately after</span>
<span class="hljs-comment">// acquiring a P in several places.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//go:yeswritebarrierrec</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">execute</span><span class="hljs-params">(gp *g, inheritTime <span class="hljs-keyword">bool</span>)</span></span> &#123;
	_g_ := getg()

	<span class="hljs-comment">// Assign gp.m before entering _Grunning so running Gs have an</span>
	<span class="hljs-comment">// M.</span>
	_g_.m.curg = gp
	gp.m = _g_.m
	casgstatus(gp, _Grunnable, _Grunning)
	gp.waitsince = <span class="hljs-number">0</span>
	gp.preempt = <span class="hljs-literal">false</span>
	gp.stackguard0 = gp.stack.lo + _StackGuard
	<span class="hljs-keyword">if</span> !inheritTime &#123;
		_g_.m.p.ptr().schedtick++
	&#125;

	<span class="hljs-comment">// Check whether the profiler needs to be turned on or off.</span>
	hz := sched.profilehz
	<span class="hljs-keyword">if</span> _g_.m.profilehz != hz &#123;
		setThreadCPUProfiler(hz)
	&#125;

	<span class="hljs-keyword">if</span> trace.enabled &#123;
		<span class="hljs-comment">// GoSysExit has to happen when we have a P, but before GoStart.</span>
		<span class="hljs-comment">// So we emit it here.</span>
		<span class="hljs-keyword">if</span> gp.syscallsp != <span class="hljs-number">0</span> &amp;&amp; gp.sysblocktraced &#123;
			traceGoSysExit(gp.sysexitticks)
		&#125;
		traceGoStart()
	&#125;

	gogo(&amp;gp.sched)
&#125;</code></pre></div>
<p>有关于<code>gogo</code>函数，这里再次post一次(<code>linux amd64</code>上):</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// func gogo(buf *gobuf)</span>
<span class="hljs-comment">// restore state from Gobuf; longjmp</span>
TEXT runtime·gogo(SB), NOSPLIT, $<span class="hljs-number">16</span><span class="hljs-number">-8</span>
	MOVQ	buf+<span class="hljs-number">0</span>(FP), BX		<span class="hljs-comment">// gobuf获取调度信息</span>
	MOVQ	gobuf_g(BX), DX
	MOVQ	<span class="hljs-number">0</span>(DX), CX		<span class="hljs-comment">// make sure g != nil</span>
	get_tls(CX)				<span class="hljs-comment">//获得当前线程</span>
	MOVQ	DX, g(CX)
	MOVQ	gobuf_sp(BX), SP	<span class="hljs-comment">//  1.restore SP 将 runtime.goexit 函数的 PC 恢复到 SP 中</span>
	MOVQ	gobuf_ret(BX), AX
	MOVQ	gobuf_ctxt(BX), DX
	MOVQ	gobuf_bp(BX), BP
	MOVQ	$<span class="hljs-number">0</span>, gobuf_sp(BX)	<span class="hljs-comment">// clear to help garbage collector</span>
	MOVQ	$<span class="hljs-number">0</span>, gobuf_ret(BX)
	MOVQ	$<span class="hljs-number">0</span>, gobuf_ctxt(BX)
	MOVQ	$<span class="hljs-number">0</span>, gobuf_bp(BX)
	MOVQ	gobuf_pc(BX), BX	<span class="hljs-comment">// 2. 获取待执行函数的程序计数器</span>
	JMP	BX 						<span class="hljs-comment">// 3. 开始执行</span></code></pre></div>
<p><code>runtime.gobuf</code>中取出了<code>runtime.goexit</code>的pc和待执行函数的pc，其中:</p>
<ul>
<li><code>runtime.goexit</code> 的程序计数器被放到了栈 SP 上；</li>
<li>待执行函数的程序计数器被放到了寄存器 BX 上；</li>
</ul>
<p>一般来讲，go的函数调用都会使用<code>CALL</code>指令，会先将返回地址加入到栈寄存器<code>SP</code>中，然后跳转到目标函数,当目标函数返回后，会从栈中查找调用的地址，并跳转回调用方继续执行剩下的代码，上面注释的1.2.3就是该过程</p>
<p>接着，在<code>JMP BX</code>命令后，当goroutine运行的函数返回时，就会跳转到<code>runtime.goexit</code>所在位置执行函数:</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">//????</span>
TEXT runtime·goexit(SB),NOSPLIT,$<span class="hljs-number">0</span><span class="hljs-number">-0</span>
	CALL	runtime·goexit1(SB)


<span class="hljs-comment">// Finishes execution of the current goroutine.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goexit1</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">if</span> raceenabled &#123;
		racegoend()
	&#125;
	<span class="hljs-keyword">if</span> trace.enabled &#123;
		traceGoEnd()
	&#125;
	mcall(goexit0)
&#125;</code></pre></div>
<p>我们最终在当前线程的<code>m.g0</code>栈上调用了<code>goexit0</code>函数：</p>
<ul>
<li>该函数会将goroutine设为<code>_Gdead</code>状态，清除其中字段，移除goroutine和M关联;</li>
<li>调用<code>runtime.gfput</code>重新加入处理器goroutine的空闲列表<code>gFree</code></li>
<li>但是最后也会再次触发<code>runtime.schedule</code>，一切再次从头再来成为一个循环;</li>
</ul>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// goexit continuation on g0.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goexit0</span><span class="hljs-params">(gp *g)</span></span> &#123;
	_g_ := getg()

	casgstatus(gp, _Grunning, _Gdead)
	<span class="hljs-keyword">if</span> isSystemGoroutine(gp, <span class="hljs-literal">false</span>) &#123;
		atomic.Xadd(&amp;sched.ngsys, <span class="hljs-number">-1</span>)
	&#125;
	gp.m = <span class="hljs-literal">nil</span>
	locked := gp.lockedm != <span class="hljs-number">0</span>
	gp.lockedm = <span class="hljs-number">0</span>
	_g_.m.lockedg = <span class="hljs-number">0</span>
	gp.preemptStop = <span class="hljs-literal">false</span>
	gp.paniconfault = <span class="hljs-literal">false</span>
	gp._defer = <span class="hljs-literal">nil</span> <span class="hljs-comment">// should be true already but just in case.</span>
	gp._panic = <span class="hljs-literal">nil</span> <span class="hljs-comment">// non-nil for Goexit during panic. points at stack-allocated data.</span>
	gp.writebuf = <span class="hljs-literal">nil</span>
	gp.waitreason = <span class="hljs-number">0</span>
	gp.param = <span class="hljs-literal">nil</span>
	gp.labels = <span class="hljs-literal">nil</span>
	gp.timer = <span class="hljs-literal">nil</span>

	<span class="hljs-keyword">if</span> gcBlackenEnabled != <span class="hljs-number">0</span> &amp;&amp; gp.gcAssistBytes &gt; <span class="hljs-number">0</span> &#123;
		<span class="hljs-comment">// Flush assist credit to the global pool. This gives</span>
		<span class="hljs-comment">// better information to pacing if the application is</span>
		<span class="hljs-comment">// rapidly creating an exiting goroutines.</span>
		scanCredit := <span class="hljs-keyword">int64</span>(gcController.assistWorkPerByte * <span class="hljs-keyword">float64</span>(gp.gcAssistBytes))
		atomic.Xaddint64(&amp;gcController.bgScanCredit, scanCredit)
		gp.gcAssistBytes = <span class="hljs-number">0</span>
	&#125;

	dropg()

	<span class="hljs-keyword">if</span> GOARCH == <span class="hljs-string">"wasm"</span> &#123; <span class="hljs-comment">// no threads yet on wasm</span>
		gfput(_g_.m.p.ptr(), gp)
		schedule() <span class="hljs-comment">// never returns</span>
	&#125;

	<span class="hljs-keyword">if</span> _g_.m.lockedInt != <span class="hljs-number">0</span> &#123;
		<span class="hljs-built_in">print</span>(<span class="hljs-string">"invalid m-&gt;lockedInt = "</span>, _g_.m.lockedInt, <span class="hljs-string">"\n"</span>)
		throw(<span class="hljs-string">"internal lockOSThread error"</span>)
	&#125;
	<span class="hljs-comment">//加入gfree，重用</span>
	gfput(_g_.m.p.ptr(), gp)
	<span class="hljs-keyword">if</span> locked &#123;
		<span class="hljs-comment">// The goroutine may have locked this thread because</span>
		<span class="hljs-comment">// it put it in an unusual kernel state. Kill it</span>
		<span class="hljs-comment">// rather than returning it to the thread pool.</span>

		<span class="hljs-comment">// Return to mstart, which will release the P and exit</span>
		<span class="hljs-comment">// the thread.</span>
		<span class="hljs-keyword">if</span> GOOS != <span class="hljs-string">"plan9"</span> &#123; <span class="hljs-comment">// See golang.org/issue/22227.</span>
			gogo(&amp;_g_.m.g0.sched)
		&#125; <span class="hljs-keyword">else</span> &#123;
			<span class="hljs-comment">// Clear lockedExt on plan9 since we may end up re-using</span>
			<span class="hljs-comment">// this thread.</span>
			_g_.m.lockedExt = <span class="hljs-number">0</span>
		&#125;
	&#125;
	schedule()
&#125;</code></pre></div>
<ul>
<li>上面调用<code>goexit0</code>是通过<code>mcall</code>,mcall定义如下:
？？？？为什么被重新调度g，fn不可以返回?
因为这里可能进行重新一次调度，选了一个新的goroutine来占用m，详细可以见下面的<a href="#%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA">调度时机</a>
一般来将<code>mcall</code>作用是在goroutine变化时候调用的，在g0栈上执行新的函数</li>
</ul>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// mcall switches from the g to the g0 stack and invokes fn(g),</span>
<span class="hljs-comment">// where g is the goroutine that made the call.</span>
<span class="hljs-comment">// mcall saves g's current PC/SP in g-&gt;sched so that it can be restored later.</span>
<span class="hljs-comment">// It is up to fn to arrange for that later execution, typically by recording</span>
<span class="hljs-comment">// g in a data structure, causing something to call ready(g) later.</span>
<span class="hljs-comment">// mcall returns to the original goroutine g later, when g has been rescheduled.</span>

<span class="hljs-comment">//????</span>
<span class="hljs-comment">// fn must not return at all; typically it ends by calling schedule, to let the m</span>
<span class="hljs-comment">// run other goroutines.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// mcall can only be called from g stacks (not g0, not gsignal).</span>
<span class="hljs-comment">// mcall只能在g的栈被调用;</span>
<span class="hljs-comment">// This must NOT be go:noescape: if fn is a stack-allocated closure,</span>
<span class="hljs-comment">// fn puts g on a run queue, and g executes before fn returns, the</span>
<span class="hljs-comment">// closure will be invalidated while it is still executing.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mcall</span><span class="hljs-params">(fn <span class="hljs-keyword">func</span>(*g)</span>)</span></code></pre></div>
<p>综上,整个goroutine如果无抢占情况下的:调度循环如图<img src="/img/scheduleLoop.png" srcset="/img/loading.gif" alt="所示"></p>
<h3 id="调度时机">调度时机</h3>
<p>可以看这幅图<img src="/img/scheduleTrigger.png" srcset="/img/loading.gif" alt="一幅图">
其实就是看一下哪里调用了<code>runtime.schedule</code>方法:</p>
<h4 id="主动挂起">主动挂起</h4>
<p>gopark方法,由channel操作、sleep、netpoll_block、gc、select等待</p>
<p><code>runtime.gopark</code>-&gt;<code>runtime.park_m</code></p>
<p><code>runtime.gopark</code>这个方法会将当前goroutine暂停，被暂停的任务不会放回runq:</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// Puts the current goroutine into a waiting state and calls unlockf.</span>
<span class="hljs-comment">// If unlockf returns false, the goroutine is resumed.</span>
<span class="hljs-comment">// unlockf must not access this G's stack, as it may be moved between</span>
<span class="hljs-comment">// the call to gopark and the call to unlockf.</span>
<span class="hljs-comment">// Reason explains why the goroutine has been parked.</span>
<span class="hljs-comment">// It is displayed in stack traces and heap dumps.</span>
<span class="hljs-comment">// Reasons should be unique and descriptive.</span>
<span class="hljs-comment">// Do not re-use reasons, add new ones.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gopark</span><span class="hljs-params">(unlockf <span class="hljs-keyword">func</span>(*g, unsafe.Pointer)</span> <span class="hljs-title">bool</span>, <span class="hljs-title">lock</span> <span class="hljs-title">unsafe</span>.<span class="hljs-title">Pointer</span>, <span class="hljs-title">reason</span> <span class="hljs-title">waitReason</span>, <span class="hljs-title">traceEv</span> <span class="hljs-title">byte</span>, <span class="hljs-title">traceskip</span> <span class="hljs-title">int</span>)</span> &#123;
	<span class="hljs-keyword">if</span> reason != waitReasonSleep &#123;
		checkTimeouts() <span class="hljs-comment">// timeouts may expire while two goroutines keep the scheduler busy</span>
	&#125;
	mp := acquirem()
	gp := mp.curg
	status := readgstatus(gp)
	<span class="hljs-keyword">if</span> status != _Grunning &amp;&amp; status != _Gscanrunning &#123;
		throw(<span class="hljs-string">"gopark: bad g status"</span>)
	&#125;
	mp.waitlock = lock
	mp.waitunlockf = unlockf
	gp.waitreason = reason
	mp.waittraceev = traceEv
	mp.waittraceskip = traceskip
	releasem(mp)
	<span class="hljs-comment">// can't do anything that might move the G between Ms here.</span>
	mcall(park_m)
&#125;</code></pre></div>
<p><code>runtime.park_m</code>:</p>
<ul>
<li>将状态变成<code>_Gwaiting</code></li>
<li>然后<code>dropg</code>将当前用户goroutine<code>m.curg</code>与m断开</li>
<li>此时就可以调用<code>schedule</code>触发新一轮调度</li>
</ul>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// park continuation on g0.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">park_m</span><span class="hljs-params">(gp *g)</span></span> &#123;
	_g_ := getg()

	<span class="hljs-keyword">if</span> trace.enabled &#123;
		traceGoPark(_g_.m.waittraceev, _g_.m.waittraceskip)
	&#125;

	casgstatus(gp, _Grunning, _Gwaiting)
	dropg()

	<span class="hljs-keyword">if</span> fn := _g_.m.waitunlockf; fn != <span class="hljs-literal">nil</span> &#123;
		ok := fn(gp, _g_.m.waitlock)
		_g_.m.waitunlockf = <span class="hljs-literal">nil</span>
		_g_.m.waitlock = <span class="hljs-literal">nil</span>
		<span class="hljs-keyword">if</span> !ok &#123;
			<span class="hljs-keyword">if</span> trace.enabled &#123;
				traceGoUnpark(gp, <span class="hljs-number">2</span>)
			&#125;
			casgstatus(gp, _Gwaiting, _Grunnable)
			execute(gp, <span class="hljs-literal">true</span>) <span class="hljs-comment">// Schedule it back, never returns.</span>
		&#125;
	&#125;
	schedule()
&#125;</code></pre></div>
<ul>
<li>在goroutine等待的条件满足后(???哪里满足，位置???)，会调用<code>runtime.goready</code>将之前gopark进入<code>_Gwaiting</code>状态的goroutine唤醒；</li>
<li><code>runtime.ready</code>将goroutine状态从<code>_Gwaiting</code>或者<code>_Gscanwaiting</code>变为<code>_Grunnable</code>，并进入runq</li>
</ul>
<div class="hljs"><pre><code class="hljs go">
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goready</span><span class="hljs-params">(gp *g, traceskip <span class="hljs-keyword">int</span>)</span></span> &#123;
	systemstack(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
		ready(gp, traceskip, <span class="hljs-literal">true</span>)
	&#125;)
&#125;
<span class="hljs-comment">// Mark gp ready to run.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ready</span><span class="hljs-params">(gp *g, traceskip <span class="hljs-keyword">int</span>, next <span class="hljs-keyword">bool</span>)</span></span> &#123;
	<span class="hljs-keyword">if</span> trace.enabled &#123;
		traceGoUnpark(gp, traceskip)
	&#125;

	status := readgstatus(gp)

	<span class="hljs-comment">// Mark runnable.</span>
	_g_ := getg()
	mp := acquirem() <span class="hljs-comment">// disable preemption because it can be holding p in a local var</span>
	<span class="hljs-keyword">if</span> status&amp;^_Gscan != _Gwaiting &#123;
		dumpgstatus(gp)
		throw(<span class="hljs-string">"bad g-&gt;status in ready"</span>)
	&#125;

	<span class="hljs-comment">// status is Gwaiting or Gscanwaiting, make Grunnable and put on runq</span>
	casgstatus(gp, _Gwaiting, _Grunnable)
	runqput(_g_.m.p.ptr(), gp, next)
	<span class="hljs-keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="hljs-number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="hljs-number">0</span> &#123;
		wakep()
	&#125;
	releasem(mp)
&#125;</code></pre></div>
<h4 id="系统调用">系统调用</h4>
<p>这部分代码主要是汇编组成:</p>
<p><code>syscall.Syscall</code>
同样是<code>linux amd64</code>:</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">//</span>
<span class="hljs-comment">// System call support for AMD64, Darwin</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Trap # in AX, args in DI SI DX, return in AX DX</span>
<span class="hljs-comment">// func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno);</span>
TEXT	·Syscall(SB),NOSPLIT,$<span class="hljs-number">0</span><span class="hljs-number">-56</span>
	CALL	runtime·entersyscall(SB)
	MOVQ	a1+<span class="hljs-number">8</span>(FP), DI
	MOVQ	a2+<span class="hljs-number">16</span>(FP), SI
	MOVQ	a3+<span class="hljs-number">24</span>(FP), DX
	MOVQ	trap+<span class="hljs-number">0</span>(FP), AX	<span class="hljs-comment">// syscall entry</span>
	ADDQ	$<span class="hljs-number">0x2000000</span>, AX
	SYSCALL
	JCC	ok
	MOVQ	$<span class="hljs-number">-1</span>, r1+<span class="hljs-number">32</span>(FP)
	MOVQ	$<span class="hljs-number">0</span>, r2+<span class="hljs-number">40</span>(FP)
	MOVQ	AX, err+<span class="hljs-number">48</span>(FP)
	CALL	runtime·exitsyscall(SB)
	RET
ok:
	MOVQ	AX, r1+<span class="hljs-number">32</span>(FP)
	MOVQ	DX, r2+<span class="hljs-number">40</span>(FP)
	MOVQ	$<span class="hljs-number">0</span>, err+<span class="hljs-number">48</span>(FP)
	CALL	runtime·exitsyscall(SB)
	RET</code></pre></div>
<p>注意到<code>runtime.entersyscall</code>,实际就是提供syscall前保存pc、sp，以便恢复;
然后调用<code>reentersyscall</code>:</p>
<ul>
<li>首先会先<code>m.lock++</code>，不让抢占（但是这里可能会造成goroutine状态<code>atomicstatus=Gsyscall</code>与<code>g.sched</code>调度器中的状态不一致，不可以让gc发现???如何???)，会造成内存不一致？？？</li>
<li>不可以调用任何会造成split stack的函数,因为其调用了<code>gosave</code>:其会使<code>g.sched</code>指向调用者的栈(如果split，就不知道指去哪里了)以便立即返回</li>
<li><code>save(pc, sp)</code>保存当前pc和sp</li>
<li>更新goroutine状态为<code>_Gsyscall</code></li>
<li>分离goroutine和P，并将P状态更新为<code>_Psyscall</code>，这时候会陷入syscall，要等待返回;</li>
<li>释放锁<code>m.lock--</code>,可能就有其他goroutine来抢P资源了</li>
</ul>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// Standard syscall entry used by the go syscall library and normal cgo calls.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// This is exported via linkname to assembly in the syscall package.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//go:nosplit</span>
<span class="hljs-comment">//go:linkname entersyscall</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">entersyscall</span><span class="hljs-params">()</span></span> &#123;
	reentersyscall(getcallerpc(), getcallersp())
&#125;


<span class="hljs-comment">// The goroutine g is about to enter a system call.</span>
<span class="hljs-comment">// Record that it's not using the cpu anymore.</span>
<span class="hljs-comment">// This is called only from the go syscall library and cgocall,</span>
<span class="hljs-comment">// not from the low-level system calls used by the runtime.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Entersyscall cannot split the stack: the gosave must</span>
<span class="hljs-comment">// make g-&gt;sched refer to the caller's stack segment, because</span>
<span class="hljs-comment">// entersyscall is going to return immediately after.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Nothing entersyscall calls can split the stack either.</span>
<span class="hljs-comment">// We cannot safely move the stack during an active call to syscall,</span>
<span class="hljs-comment">// because we do not know which of the uintptr arguments are</span>
<span class="hljs-comment">// really pointers (back into the stack).</span>
<span class="hljs-comment">// In practice, this means that we make the fast path run through</span>
<span class="hljs-comment">// entersyscall doing no-split things, and the slow path has to use systemstack</span>
<span class="hljs-comment">// to run bigger things on the system stack.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// reentersyscall is the entry point used by cgo callbacks, where explicitly</span>
<span class="hljs-comment">// saved SP and PC are restored. This is needed when exitsyscall will be called</span>
<span class="hljs-comment">// from a function further up in the call stack than the parent, as g-&gt;syscallsp</span>
<span class="hljs-comment">// must always point to a valid stack frame. entersyscall below is the normal</span>
<span class="hljs-comment">// entry point for syscalls, which obtains the SP and PC from the caller.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Syscall tracing:</span>
<span class="hljs-comment">// At the start of a syscall we emit traceGoSysCall to capture the stack trace.</span>
<span class="hljs-comment">// If the syscall does not block, that is it, we do not emit any other events.</span>
<span class="hljs-comment">// If the syscall blocks (that is, P is retaken), retaker emits traceGoSysBlock;</span>
<span class="hljs-comment">// when syscall returns we emit traceGoSysExit and when the goroutine starts running</span>
<span class="hljs-comment">// (potentially instantly, if exitsyscallfast returns true) we emit traceGoStart.</span>
<span class="hljs-comment">// To ensure that traceGoSysExit is emitted strictly after traceGoSysBlock,</span>
<span class="hljs-comment">// we remember current value of syscalltick in m (_g_.m.syscalltick = _g_.m.p.ptr().syscalltick),</span>
<span class="hljs-comment">// whoever emits traceGoSysBlock increments p.syscalltick afterwards;</span>
<span class="hljs-comment">// and we wait for the increment before emitting traceGoSysExit.</span>
<span class="hljs-comment">// Note that the increment is done even if tracing is not enabled,</span>
<span class="hljs-comment">// because tracing can be enabled in the middle of syscall. We don't want the wait to hang.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//go:nosplit</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reentersyscall</span><span class="hljs-params">(pc, sp <span class="hljs-keyword">uintptr</span>)</span></span> &#123;
	_g_ := getg()

	<span class="hljs-comment">// Disable preemption because during this function g is in Gsyscall status,</span>
	<span class="hljs-comment">// but can have inconsistent g-&gt;sched, do not let GC observe it.</span>
	_g_.m.locks++

	<span class="hljs-comment">// Entersyscall must not call any function that might split/grow the stack.</span>
	<span class="hljs-comment">// (See details in comment above.)</span>
	<span class="hljs-comment">// Catch calls that might, by replacing the stack guard with something that</span>
	<span class="hljs-comment">// will trip any stack check and leaving a flag to tell newstack to die.</span>
	_g_.stackguard0 = stackPreempt
	_g_.throwsplit = <span class="hljs-literal">true</span>

	<span class="hljs-comment">// Leave SP around for GC and traceback.</span>
	save(pc, sp)
	_g_.syscallsp = sp
	_g_.syscallpc = pc
	casgstatus(_g_, _Grunning, _Gsyscall)
	<span class="hljs-keyword">if</span> _g_.syscallsp &lt; _g_.stack.lo || _g_.stack.hi &lt; _g_.syscallsp &#123;
		systemstack(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
			<span class="hljs-built_in">print</span>(<span class="hljs-string">"entersyscall inconsistent "</span>, hex(_g_.syscallsp), <span class="hljs-string">" ["</span>, hex(_g_.stack.lo), <span class="hljs-string">","</span>, hex(_g_.stack.hi), <span class="hljs-string">"]\n"</span>)
			throw(<span class="hljs-string">"entersyscall"</span>)
		&#125;)
	&#125;

	<span class="hljs-keyword">if</span> trace.enabled &#123;
		systemstack(traceGoSysCall)
		<span class="hljs-comment">// systemstack itself clobbers g.sched.&#123;pc,sp&#125; and we might</span>
		<span class="hljs-comment">// need them later when the G is genuinely blocked in a</span>
		<span class="hljs-comment">// syscall</span>
		save(pc, sp)
	&#125;

	<span class="hljs-keyword">if</span> atomic.Load(&amp;sched.sysmonwait) != <span class="hljs-number">0</span> &#123;
		systemstack(entersyscall_sysmon)
		save(pc, sp)
	&#125;

	<span class="hljs-keyword">if</span> _g_.m.p.ptr().runSafePointFn != <span class="hljs-number">0</span> &#123;
		<span class="hljs-comment">// runSafePointFn may stack split if run on this stack</span>
		systemstack(runSafePointFn)
		save(pc, sp)
	&#125;

	_g_.m.syscalltick = _g_.m.p.ptr().syscalltick
	_g_.sysblocktraced = <span class="hljs-literal">true</span>
	_g_.m.mcache = <span class="hljs-literal">nil</span>
	pp := _g_.m.p.ptr()
	pp.m = <span class="hljs-number">0</span>
	_g_.m.oldp.set(pp)
	_g_.m.p = <span class="hljs-number">0</span>
	atomic.Store(&amp;pp.status, _Psyscall)
	<span class="hljs-keyword">if</span> sched.gcwaiting != <span class="hljs-number">0</span> &#123;
		systemstack(entersyscall_gcwait)
		save(pc, sp)
	&#125;

	_g_.m.locks--
&#125;</code></pre></div>
<p><code>runtime.exitsyscall</code>则从syscall中恢复,比较复杂:</p>
<ul>
<li>同样要锁住<code>m.locks++</code>，不给抢占先,</li>
<li>写屏障不能用，p可能在syscall过程中被窃取(即当前p不是syscall前的p)</li>
<li>会走到两个路径<code>exitsyscallfast</code>或者通过<code>mcall</code>(切换到调度器的goroutine)调用<code>exitsyscall0</code>进行退出</li>
</ul>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// The goroutine g exited its system call.</span>
<span class="hljs-comment">// Arrange for it to run on a cpu again.</span>
<span class="hljs-comment">// This is called only from the go syscall library, not</span>
<span class="hljs-comment">// from the low-level system calls used by the runtime.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Write barriers are not allowed because our P may have been stolen.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// This is exported via linkname to assembly in the syscall package.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//go:nosplit</span>
<span class="hljs-comment">//go:nowritebarrierrec</span>
<span class="hljs-comment">//go:linkname exitsyscall</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exitsyscall</span><span class="hljs-params">()</span></span> &#123;
	_g_ := getg()

	_g_.m.locks++ <span class="hljs-comment">// see comment in entersyscall</span>
	<span class="hljs-keyword">if</span> getcallersp() &gt; _g_.syscallsp &#123;
		throw(<span class="hljs-string">"exitsyscall: syscall frame is no longer valid"</span>)
	&#125;

	_g_.waitsince = <span class="hljs-number">0</span>
	oldp := _g_.m.oldp.ptr()
	_g_.m.oldp = <span class="hljs-number">0</span>
	<span class="hljs-keyword">if</span> exitsyscallfast(oldp) &#123;
		<span class="hljs-keyword">if</span> _g_.m.mcache == <span class="hljs-literal">nil</span> &#123;
			throw(<span class="hljs-string">"lost mcache"</span>)
		&#125;
		<span class="hljs-keyword">if</span> trace.enabled &#123;
			<span class="hljs-keyword">if</span> oldp != _g_.m.p.ptr() || _g_.m.syscalltick != _g_.m.p.ptr().syscalltick &#123;
				systemstack(traceGoStart)
			&#125;
		&#125;
		<span class="hljs-comment">// There's a cpu for us, so we can run.</span>
		_g_.m.p.ptr().syscalltick++
		<span class="hljs-comment">// We need to cas the status and scan before resuming...</span>
		casgstatus(_g_, _Gsyscall, _Grunning)

		<span class="hljs-comment">// Garbage collector isn't running (since we are),</span>
		<span class="hljs-comment">// so okay to clear syscallsp.</span>
		_g_.syscallsp = <span class="hljs-number">0</span>
		_g_.m.locks--
		<span class="hljs-keyword">if</span> _g_.preempt &#123;
			<span class="hljs-comment">// restore the preemption request in case we've cleared it in newstack</span>
			_g_.stackguard0 = stackPreempt
		&#125; <span class="hljs-keyword">else</span> &#123;
			<span class="hljs-comment">// otherwise restore the real _StackGuard, we've spoiled it in entersyscall/entersyscallblock</span>
			_g_.stackguard0 = _g_.stack.lo + _StackGuard
		&#125;
		_g_.throwsplit = <span class="hljs-literal">false</span>

		<span class="hljs-keyword">if</span> sched.disable.user &amp;&amp; !schedEnabled(_g_) &#123;
			<span class="hljs-comment">// Scheduling of this goroutine is disabled.</span>
			Gosched()
		&#125;

		<span class="hljs-keyword">return</span>
	&#125;

	_g_.sysexitticks = <span class="hljs-number">0</span>
	<span class="hljs-keyword">if</span> trace.enabled &#123;
		<span class="hljs-comment">// Wait till traceGoSysBlock event is emitted.</span>
		<span class="hljs-comment">// This ensures consistency of the trace (the goroutine is started after it is blocked).</span>
		<span class="hljs-keyword">for</span> oldp != <span class="hljs-literal">nil</span> &amp;&amp; oldp.syscalltick == _g_.m.syscalltick &#123;
			osyield()
		&#125;
		<span class="hljs-comment">// We can't trace syscall exit right now because we don't have a P.</span>
		<span class="hljs-comment">// Tracing code can invoke write barriers that cannot run without a P.</span>
		<span class="hljs-comment">// So instead we remember the syscall exit time and emit the event</span>
		<span class="hljs-comment">// in execute when we have a P.</span>
		_g_.sysexitticks = cputicks()
	&#125;

	_g_.m.locks--

	<span class="hljs-comment">// Call the scheduler.</span>
	mcall(exitsyscall0)

	<span class="hljs-keyword">if</span> _g_.m.mcache == <span class="hljs-literal">nil</span> &#123;
		throw(<span class="hljs-string">"lost mcache"</span>)
	&#125;

	<span class="hljs-comment">// Scheduler returned, so we're allowed to run now.</span>
	<span class="hljs-comment">// Delete the syscallsp information that we left for</span>
	<span class="hljs-comment">// the garbage collector during the system call.</span>
	<span class="hljs-comment">// Must wait until now because until gosched returns</span>
	<span class="hljs-comment">// we don't know for sure that the garbage collector</span>
	<span class="hljs-comment">// is not running.</span>
	_g_.syscallsp = <span class="hljs-number">0</span>
	_g_.m.p.ptr().syscalltick++
	_g_.throwsplit = <span class="hljs-literal">false</span>
&#125;</code></pre></div>
<p>针对<code>exitsyscallfast</code>:</p>
<ul>
<li>如果goroutine处于<code>_Psyscall</code>状态，尝试用<code>wirep</code>将其与goroutine与之前旧的<code>g.m.oldP</code>(就是syscall之前会保存进来的)相连接;</li>
<li>如果全局调度器中有其他的空闲p，就会在<code>systemstack</code>下调用<code>exitsyscallfast_pidle</code>来获取p，其中<code>exitsyscallfast_pidle</code>方法会使用<code>acquirep</code>调用空闲的p来接管当前goroutine</li>
</ul>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">//go:nosplit</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exitsyscallfast</span><span class="hljs-params">(oldp *p)</span> <span class="hljs-title">bool</span></span> &#123;
	_g_ := getg()

	<span class="hljs-comment">// Freezetheworld sets stopwait but does not retake P's.</span>
	<span class="hljs-keyword">if</span> sched.stopwait == freezeStopWait &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
	&#125;

	<span class="hljs-comment">// Try to re-acquire the last P.</span>
	<span class="hljs-keyword">if</span> oldp != <span class="hljs-literal">nil</span> &amp;&amp; oldp.status == _Psyscall &amp;&amp; atomic.Cas(&amp;oldp.status, _Psyscall, _Pidle) &#123;
		<span class="hljs-comment">// There's a cpu for us, so we can run.</span>
		wirep(oldp)
		exitsyscallfast_reacquired()
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
	&#125;

	<span class="hljs-comment">// Try to get any other idle P.</span>
	<span class="hljs-keyword">if</span> sched.pidle != <span class="hljs-number">0</span> &#123;
		<span class="hljs-keyword">var</span> ok <span class="hljs-keyword">bool</span>
		systemstack(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
			ok = exitsyscallfast_pidle()
			<span class="hljs-keyword">if</span> ok &amp;&amp; trace.enabled &#123;
				<span class="hljs-keyword">if</span> oldp != <span class="hljs-literal">nil</span> &#123;
					<span class="hljs-comment">// Wait till traceGoSysBlock event is emitted.</span>
					<span class="hljs-comment">// This ensures consistency of the trace (the goroutine is started after it is blocked).</span>
					<span class="hljs-keyword">for</span> oldp.syscalltick == _g_.m.syscalltick &#123;
						osyield()
					&#125;
				&#125;
				traceGoSysExit(<span class="hljs-number">0</span>)
			&#125;
		&#125;)
		<span class="hljs-keyword">if</span> ok &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
&#125;</code></pre></div>
<p>另一个<code>exitsyscall0</code>（较慢）:</p>
<ul>
<li>首先会将<code>Gsyscall</code>状态设为<code>Grunnable</code></li>
<li>然后<code>dropg</code>断开g与P的联系;</li>
<li>然后锁住全局调度器,<code>pidleget()</code>获得空闲p，然这个p接管goroutine</li>
<li>如果<code>pidleget()</code>无法获得p，则将当前g放入全局的<code>sched.runq</code>,等待调度器;</li>
<li>解锁，下面就是一系列调度;</li>
</ul>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// exitsyscall slow path on g0.</span>
<span class="hljs-comment">// Failed to acquire P, enqueue gp as runnable.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//go:nowritebarrierrec</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exitsyscall0</span><span class="hljs-params">(gp *g)</span></span> &#123;
	_g_ := getg()

	casgstatus(gp, _Gsyscall, _Grunnable)
	dropg()
	lock(&amp;sched.lock)
	<span class="hljs-keyword">var</span> _p_ *p
	<span class="hljs-keyword">if</span> schedEnabled(_g_) &#123;
		_p_ = pidleget()
	&#125;
	<span class="hljs-keyword">if</span> _p_ == <span class="hljs-literal">nil</span> &#123;
		globrunqput(gp)
	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> atomic.Load(&amp;sched.sysmonwait) != <span class="hljs-number">0</span> &#123;
		atomic.Store(&amp;sched.sysmonwait, <span class="hljs-number">0</span>)
		notewakeup(&amp;sched.sysmonnote)
	&#125;
	unlock(&amp;sched.lock)
	<span class="hljs-keyword">if</span> _p_ != <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-comment">//将p与当前m联系起来</span>
		acquirep(_p_)
		<span class="hljs-comment">//开始在当前M开始运行传入的gp(goroutine)</span>
		execute(gp, <span class="hljs-literal">false</span>) <span class="hljs-comment">// Never returns.</span>
	&#125;
	<span class="hljs-keyword">if</span> _g_.m.lockedg != <span class="hljs-number">0</span> &#123;
		<span class="hljs-comment">// Wait until another thread schedules gp and so m again.</span>
		stoplockedm()
		execute(gp, <span class="hljs-literal">false</span>) <span class="hljs-comment">// Never returns.</span>
	&#125;
	stopm()
	schedule() <span class="hljs-comment">// Never returns.</span>
&#125;</code></pre></div>
<h4 id="协作式调度">协作式调度</h4>
<p>协作式调度主要是依靠<code>runtime.GoSched()</code>主动让出P，但该函数无法挂起goroutine,调度器会自动调度当前的goroutine???</p>
<ul>
<li>会更新当前g状态<code>Grunning</code>到<code>Grunnable</code></li>
<li>断开g与当前P的状态</li>
<li>将当前g放入全局<code>sched.runq</code></li>
<li>开始调度</li>
</ul>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">//go:nosplit</span>

<span class="hljs-comment">// Gosched yields the processor, allowing other goroutines to run. It does not</span>
<span class="hljs-comment">// suspend the current goroutine, so execution resumes automatically.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Gosched</span><span class="hljs-params">()</span></span> &#123;
	checkTimeouts()
	mcall(gosched_m)
&#125;

<span class="hljs-comment">// Gosched continuation on g0.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gosched_m</span><span class="hljs-params">(gp *g)</span></span> &#123;
	<span class="hljs-keyword">if</span> trace.enabled &#123;
		traceGoSched()
	&#125;
	goschedImpl(gp)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goschedImpl</span><span class="hljs-params">(gp *g)</span></span> &#123;
	status := readgstatus(gp)
	<span class="hljs-keyword">if</span> status&amp;^_Gscan != _Grunning &#123;
		dumpgstatus(gp)
		throw(<span class="hljs-string">"bad g status"</span>)
	&#125;
	casgstatus(gp, _Grunning, _Grunnable)
	dropg()
	lock(&amp;sched.lock)
	globrunqput(gp)
	unlock(&amp;sched.lock)

	schedule()
&#125;</code></pre></div>
<h4 id="sysmon-v2">sysmon</h4>
<p>主要对运行时间过长的，强行让出
<code>p</code>中的<code>schedtick</code> 和 <code>schedwhen</code>与当前时间计算，运算出是否超时，要让出
<code>runtime.retake</code>方法中的<code>runtime.preemptone</code>进行异步抢占:</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">//todo</span></code></pre></div>
<ol>
<li>Channel,mutex之类同步操作发生阻塞</li>
<li>time.sleep</li>
<li>主动调用runtime.GoSched()</li>
<li>网络IO阻塞</li>
<li>gc</li>
<li>运行过久或者系统调用过久</li>
</ol>
<h3 id="os线程锁">OS线程锁</h3>
<p><code>runtime.LockOSThread</code> //todo</p>
<h3 id="死锁检测和终止">死锁检测和终止</h3>
<p>//todo???
当所有P是idle的时候进行检测（全局idle P的原子计数）</p>
<p>旋转态-&gt;不旋态的转换中，
可能和创建一个新的goroutine和创建一部分或其他需要unpark的工作线程 的时候发生竞态条件
如果转换和创建都失败，我们就可以以半静态cpu未充分利用结束；
goroutine 准备步骤是：提交一个goroutine去local queue，store-style memory 屏障，检查sched.nmspinning</p>
<p>不旋态-&gt;旋转态是： 减少nmspinning，store-style memory 屏障，检查新的work的所有per-P work queue
而且以上都不适用于global run queue</p>
<h3 id="协作式抢占">协作式抢占</h3>
<p><code>retake()</code> 调用<code>runtime.preemptone()</code>将被抢占的G的<code>stackguard0</code> 设为<code>stackPreempt</code>，
被设置标志的G下一次进行函数调用的时候，检查栈空间失败。然后会触发morestack() (汇编代码,asm_xxx.s)
然后进行一连串的函数调用
大概流程</p>
<p>morestack()–&gt; newstack()–&gt; gopreempt_m() --&gt; goschedImpl() --&gt; schedule()</p>
<h2 id="补充：">补充：</h2>
<p>网上的经验（为什么呢？？？)：</p>
<p>这个goroutine类似于线程池管理(c++线程池原理相似)，</p>
<ol>
<li>遇到阻塞的情况，怎么扩展进程池，使其不会因为任务阻塞或者同步独占线程</li>
</ol>
<ol start="2">
<li>
<p>goroutine类似green threads（Green threads），是application自己维护的执行过程；很多goroutines实际上被有限个操作系统管理的threads执行;</p>
</li>
<li>
<p>goroutine的调度往往发生在I/O和系统调用的时候。如果创建的goroutines都是跑for循环做纯计算（没有I/O），那就需要我们自己时不常的调用 runtime.Gosched()，否则那几个在thread上跑的goroutines会霸占着threads，不让其他goroutines有机会跑起来;</p>
</li>
<li>
<p>用户代码造成的协程同步造成的阻塞，只是切换(gopark)协程，而不是阻塞线程，<strong>m和p仍结合</strong>，去寻找新的可执行的g;</p>
</li>
<li>
<p>上层封装了epoll，网络fd会设置成NonBlocking模式，返回EAGAIN则gopark当前goroutine，在m调度，sysmon中，gc start the world等阶段均会poll出ready的goroutine进行运行或者添加到全局runq中</p>
</li>
</ol>
<p><strong>一些小细节</strong>
代码经常发现一些编辑器生成的//go:nosplit字样</p>
<blockquote>
<blockquote>
<p>The //go:nosplit directive specifies that the next function declared in the file must not include a stack overflow check. This is most commonly used by low-level runtime sources invoked at times when it is unsafe for the calling goroutine to be preempted.</p>
</blockquote>
</blockquote>
<p>大意即为这个生成函数不能含有检查栈溢出的代码，即会跳过栈溢出检查（why???个人认为是设计问题，就不允许有检查栈移除代码），有时goroutine要被抢占陷入不安全情况时，被底层runtime调用</p>
<h2 id="systemstack">SystemStack</h2>
<p>SystemStack(fn func())
系统栈 被不同地方调用会有不同的表现方式：</p>
<ul>
<li>
<p>直接调用fn并返回 需要满足：</p>
<ul>
<li>
<p>被 单个线程的g0 stack调用    或</p>
</li>
<li>
<p>被信号处理的栈(gsignal)调用,m中有个gsinal字段 ???</p>
</li>
</ul>
</li>
<li>
<p>否则，都从一个普通的goroutine的有限的stack中调用</p>
<p>表现： 会先切去线程的栈，调用fn，然后切回来该goroutine的栈</p>
</li>
</ul>
<div class="hljs"><pre><code class="hljs golang"><span class="hljs-comment">// systemstack runs fn on a system stack.</span>
<span class="hljs-comment">// If systemstack is called from the per-OS-thread (g0) stack, or</span>
<span class="hljs-comment">// if systemstack is called from the signal handling (gsignal) stack,</span>
<span class="hljs-comment">// systemstack calls fn directly and returns.</span>
<span class="hljs-comment">// Otherwise, systemstack is being called from the limited stack</span>
<span class="hljs-comment">// of an ordinary goroutine. In this case, systemstack switches</span>
<span class="hljs-comment">// to the per-OS-thread stack, calls fn, and switches back.</span>
<span class="hljs-comment">// It is common to use a func literal as the argument, in order</span>
<span class="hljs-comment">// to share inputs and outputs with the code around the call</span>
<span class="hljs-comment">// to system stack:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//	... set up y ...</span>
<span class="hljs-comment">//	systemstack(func() &#123;</span>
<span class="hljs-comment">//		x = bigcall(y)</span>
<span class="hljs-comment">//	&#125;)</span>
<span class="hljs-comment">//	... use x ...</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//go:noescape</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">systemstack</span><span class="hljs-params">(fn <span class="hljs-keyword">func</span>()</span>)</span></code></pre></div>
<h3 id="一个大概的go程序启动流程">一个大概的go程序启动流程</h3>
<p>golang注释中有大概写明:</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// The bootstrap sequence is:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//	call osinit</span>
<span class="hljs-comment">//	call schedinit</span>
<span class="hljs-comment">//	make &amp; queue new G</span>
<span class="hljs-comment">//	call runtime·mstart</span>
<span class="hljs-comment">// The new G calls runtime·main.</span></code></pre></div>
<p><img src="/img/" srcset="/img/loading.gif" alt="大概的流程图"></p>
<p>go程序的入口点是runtime.rt0_go, 流程是:</p>
<ol>
<li>分配栈空间, 需要2个本地变量+2个函数参数, 然后向8对齐</li>
</ol>
<p>把传入的argc和argv保存到栈上(rdx寄存器通常用作上下文存储)</p>
<p>更新g0中的stackguard的值, stackguard用于检测栈空间是否不足, 需要分配新的栈空间(栈扩展会申请多一块栈空间并把现在的复制过去)</p>
<p>获取当前cpu的信息并保存到各个全局变量</p>
<p>调用_cgo_init如果函数存在</p>
<ol start="2">
<li>初始化当前线程的TLS(thread-local-storage), 设置FS寄存器为m0.tls+8(获取时会-8)
这里跟SP寄存器有关(伪的SP寄存器的地址 = 硬件SP寄存器+8，64位机)</li>
</ol>
<p>测试TLS是否工作</p>
<p>设置g0到TLS中, 表示当前的g是g0</p>
<p>设置m0.g0 = g0</p>
<p>设置g0.m = m0</p>
<h4 id="特殊的m0和g0">特殊的m0和g0</h4>
<ul>
<li>
<p><code>M0</code> 是启动程序后的编号为 0 的<code>主线程</code>，这个 M 对应的实例会在全局变量<code>runtime.m0</code>中，不需要在heap上分配，<code>M0</code>负责执行初始化操作和启动第一个 G， 在之后 M0 就和其他的 M 一样了。</p>
</li>
<li>
<p><code>G0</code> 是每次启动一个 M 都会第一个创建的 gourtine，<code>G0</code> 仅用于<strong>负责调度</strong>的 G(作用);
<code>G0</code> 不指向任何可执行的函数，每个 M 都会有一个自己的 <code>G0</code>。在调度或系统调用时会使用 G0 的栈空间(栈空间是一定的,Unix一般是8MB)，全局变量的 <code>G0</code> 是 <code>M0</code> 的 <code>G0</code> (这种一般指sysmon,垃圾回收器等，注意调度器本身属于第三种goroutine，不是g0，也不是普通的goroutine)</p>
</li>
</ul>
<ol start="3">
<li>调用runtime.check做一些检查</li>
</ol>
<p>调用runtime.args保存传入的argc和argv到全局变量</p>
<p>调用runtime.osinit根据系统执行不同的初始化</p>
<p>这里(linux x64)设置了全局变量ncpu等于cpu核心数量</p>
<ol start="4">
<li>调用**runtime.schedinit()**执行共同的初始化</li>
</ol>
<p>这里的处理比较多:</p>
<ul>
<li>
<p>首先会调用raceinit()检查race condition</p>
</li>
<li>
<p>然后进接这tracebackinit()和moduledateverify()，分别为一些变量提前初始化和包的验证</p>
</li>
</ul>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tracebackinit</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-comment">// Go variable initialization happens late during runtime startup.</span>
	<span class="hljs-comment">// Instead of initializing the variables above in the declarations,</span>
	<span class="hljs-comment">// schedinit calls this function so that the variables are</span>
	<span class="hljs-comment">// initialized and available earlier in the startup sequence.</span>
	skipPC = funcPC(skipPleaseUseCallersFrames)
&#125;</code></pre></div>
<ul>
<li>会初始化栈空间分配器(stackinit)</li>
</ul>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stackinit</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-comment">//// Per-P, per order stack segment cache size.</span>
	<span class="hljs-comment">//_StackCacheSize = 32 * 1024</span>
	<span class="hljs-comment">// stack的分段大小一定要是pagesize的倍数（容易理解，方便对齐）</span>
	<span class="hljs-comment">//_PageShift = 13</span>
	<span class="hljs-comment">//_PageSize = 1 &lt;&lt; _PageShift = 8192</span>
	<span class="hljs-comment">//_PageMask = _PageSize - 1</span>
	<span class="hljs-keyword">if</span> _StackCacheSize&amp;_PageMask != <span class="hljs-number">0</span> &#123;
		throw(<span class="hljs-string">"cache size must be a multiple of page size"</span>)
	&#125;
	<span class="hljs-comment">//stackpool就是一个span的双向链表</span>
	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> stackpool &#123;
		stackpool[i].init()
	&#125;
	<span class="hljs-comment">// stackLarge的free是一个list ， 大小为 log_2(s.npages)</span>
	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> stackLarge.free &#123;
		stackLarge.free[i].init()
	&#125;
&#125;</code></pre></div>
<p>这里插入一副<s>盗</s>借来的<img src="/img/mheap.png" srcset="/img/loading.gif" alt="图">
更加明确发现一些奇怪的特点</p>
<ul>
<li>
<p>mallocinit()</p>
<ol>
<li>这个最主要是检查page，huge page大小是不是2的倍数以及是不是大于最小页大小(4KB)</li>
<li>然后就初始化 heap，在memManage 那篇文章有讲到,会初始化多个fixalloc，包括treap，span，cache，specialfinalizer，specialprofile，arenaHint
还有getg()获得当前g的指针，以及初始化当前mcache(allocmcache())</li>
<li>创建初始化的arena区域(即是heap)的增长规则,注意在64bit机器中，其做了一些优化:
从中间空间开始分配,如上面的图一样，
<ul>
<li>可以更加容易地增长连续空间</li>
<li>使其更加容易debug</li>
<li>为了gccgo区别于其他数据</li>
<li>UTF8编码</li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li>
<p>mcommoninit(<em>g</em>.m),这里是一些公共初始化
主要对_g_.m即自己的m进行一些初始化</p>
</li>
<li>
<p>按cpu核心数量或GOMAXPROCS的值生成P(cpuinit)</p>
</li>
</ul>
<div class="hljs"><pre><code class="hljs go">cpuinit()       <span class="hljs-comment">// must run before alginit</span></code></pre></div>
<ul>
<li>alginit</li>
</ul>
<div class="hljs"><pre><code class="hljs go">alginit()       <span class="hljs-comment">// maps must not be used before this call</span></code></pre></div>
<ul>
<li>生成P的处理在procresize中</li>
</ul>
<p>更改了P的数目，期间stop the world并锁住sched，返回本地的所有p</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">schedinit</span><span class="hljs-params">()</span></span>&#123;
	...
	sched.lastpoll = <span class="hljs-keyword">uint64</span>(nanotime())
	procs := ncpu
	<span class="hljs-keyword">if</span> n, ok := atoi32(gogetenv(<span class="hljs-string">"GOMAXPROCS"</span>)); ok &amp;&amp; n &gt; <span class="hljs-number">0</span> &#123;
		procs = n
	&#125;
	<span class="hljs-keyword">if</span> procresize(procs) != <span class="hljs-literal">nil</span> &#123;
		throw(<span class="hljs-string">"unknown runnable goroutine during bootstrap"</span>)
	&#125;
	...
&#125;
<span class="hljs-comment">// Change number of processors. The world is stopped, sched is locked.</span>
<span class="hljs-comment">// gcworkbufs are not being modified by either the GC or</span>
<span class="hljs-comment">// the write barrier code.</span>
<span class="hljs-comment">// Returns list of Ps with local work, they need to be scheduled by the caller.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">procresize</span><span class="hljs-params">(nprocs <span class="hljs-keyword">int32</span>)</span> *<span class="hljs-title">p</span></span> &#123; ... &#125;</code></pre></div>
<ol start="5">
<li>
<p>调用runtime.newproc创建一个新的goroutine, 指向的是runtime.main
runtime.newproc这个函数在创建普通的goroutine时也会使用;</p>
</li>
<li>
<p>调用runtime·mstart启动m0</p>
<ul>
<li>启动后m0会不断从运行队列获取G并运行, runtime.mstart调用后不会返回</li>
<li>runtime.mstart这个函数是m的入口点(不仅仅是m0), 在下面的&quot;调度器的实现&quot;中会详细讲解</li>
</ul>
</li>
</ol>
<h3 id="runtime-main之后">runtime.main之后</h3>
<p>第一个被调度的G会运行runtime.main, 流程是:</p>
<p>标记主函数已调用, 设置mainStarted = true</p>
<p>启动一个新的M执行sysmon函数, 这个函数会监控全局的状态并对运行时间过长的G进行抢占</p>
<p>要求G必须在当前M(系统主线程)上执行</p>
<p>调用runtime_init函数</p>
<p>调用gcenable函数</p>
<p>调用main.init函数, 如果函数存在</p>
<p>不再要求G必须在当前M上运行</p>
<p>如果程序是作为c的类库编译的, 在这里返回</p>
<p>调用main.main函数</p>
<p>如果当前发生了panic, 则等待panic处理</p>
<p>调用exit(0)退出程序</p>
<h2 id="defer函数">Defer函数</h2>
<p>平常用的</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">do</span><span class="hljs-params">()</span></span>&#123;
	<span class="hljs-keyword">defer</span> done()
&#125;</code></pre></div>
<p>其结构在 runtime2.go 结构体g中</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> g <span class="hljs-keyword">struct</span>&#123;
	goid <span class="hljs-keyword">int64</span>
	...
	<span class="hljs-comment">//其结构有些在stack中有些在heap中，但是逻辑上都属于stack，所以写屏障是没有必要的;</span>
	_defer *<span class="hljs-keyword">defer</span>&#123;
		siz     <span class="hljs-keyword">int32</span> <span class="hljs-comment">// includes both arguments and results</span>
		started <span class="hljs-keyword">bool</span>
		heap    <span class="hljs-keyword">bool</span>
		sp      <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// sp at time of defer</span>
		pc      <span class="hljs-keyword">uintptr</span>
		fn      *funcval <span class="hljs-comment">//调用的函数</span>
		_panic  *_panic <span class="hljs-comment">// panic that is running defer</span>
		link    *_defer
	&#125; 
	...

&#125;</code></pre></div>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/golang/">golang</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2019/08/18/Comcon/StringCompare/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Notes about Strings</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2019/07/03/MySQL/MySQLIndexing/">
                        <span class="hidden-mobile">Notes about MySQL indexing</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Go Scheduler&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
