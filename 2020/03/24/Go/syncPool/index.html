<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>Golang sync.Pool | 兜的破烂</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="golang进程池 Sync.Pool 这个是1.13后的大改进，大幅度削减开销; 首先明确一个目标就是： 池类技术都是为了减少资源的多次分配，在这里就是减少GC的压力，以及提高缓存命中率 结构 相关内容主要在 sync/pool.go 和 sync/poolqueue.go上 123456789101112131415type Pool struct &amp;#123;	noCopy noCopy">
<meta name="keywords" content="golang">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang sync.Pool">
<meta property="og:url" content="https://mhh12121.github.io/2020/03/24/Go/syncPool/index.html">
<meta property="og:site_name" content="兜的破烂">
<meta property="og:description" content="golang进程池 Sync.Pool 这个是1.13后的大改进，大幅度削减开销; 首先明确一个目标就是： 池类技术都是为了减少资源的多次分配，在这里就是减少GC的压力，以及提高缓存命中率 结构 相关内容主要在 sync/pool.go 和 sync/poolqueue.go上 123456789101112131415type Pool struct &amp;#123;	noCopy noCopy">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-07-21T14:48:10.650Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Golang sync.Pool">
<meta name="twitter:description" content="golang进程池 Sync.Pool 这个是1.13后的大改进，大幅度削减开销; 首先明确一个目标就是： 池类技术都是为了减少资源的多次分配，在这里就是减少GC的压力，以及提高缓存命中率 结构 相关内容主要在 sync/pool.go 和 sync/poolqueue.go上 123456789101112131415type Pool struct &amp;#123;	noCopy noCopy">
  
    <link rel="alternate" href="/atom.xml" title="兜的破烂" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">兜的破烂</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">学习☆记录</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://mhh12121.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Go/syncPool" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/24/Go/syncPool/" class="article-date">
  <time datetime="2020-03-24T14:10:00.000Z" itemprop="datePublished">2020-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Golang sync.Pool
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<p>golang进程池</p>
<h1>Sync.Pool</h1>
<p>这个是1.13后的大改进，大幅度削减开销;
首先明确一个<strong>目标</strong>就是：</p>
<p>池类技术都是为了减少资源的多次分配，在这里就是<strong>减少GC</strong>的压力，以及提高缓存命中率</p>
<h2>结构</h2>
<p>相关内容主要在 sync/pool.go 和 sync/poolqueue.go上</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">	noCopy noCopy <span class="comment">//这个是一个保证了第一次使用不会被copy的结构,防止被复制，很多结构也有用到这个</span></span><br><span class="line"></span><br><span class="line">	local     unsafe.Pointer <span class="comment">// local fixed-size per-P pool, actual type is [P]poolLocal</span></span><br><span class="line">	localSize <span class="keyword">uintptr</span>        <span class="comment">// size of the local array</span></span><br><span class="line"></span><br><span class="line">    victim     unsafe.Pointer <span class="comment">// local from previous cycle</span></span><br><span class="line">    <span class="comment">//这个东西实际上在gc用到，后面再说</span></span><br><span class="line">	victimSize <span class="keyword">uintptr</span>        <span class="comment">// size of victims array</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// New optionally specifies a function to generate</span></span><br><span class="line">	<span class="comment">// a value when Get would otherwise return nil.</span></span><br><span class="line">	<span class="comment">// It may not be changed concurrently with calls to Get.</span></span><br><span class="line">	New <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容易想到池类技术多用队列来实现:
但是这里使用了我觉得“妙啊”的结构：环式队列</p>
<h3>poolDequeue</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolDequeue <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// headTail packs together a 32-bit head index and a 32-bit</span></span><br><span class="line">	<span class="comment">// tail index. Both are indexes into vals modulo len(vals)-1.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// tail = index of oldest data in queue</span></span><br><span class="line">	<span class="comment">// head = index of next slot to fill</span></span><br><span class="line">	头部，生产者放入data</span><br><span class="line">	<span class="comment">// Slots in the range [tail, head) are owned by consumers.</span></span><br><span class="line">	消费者只消费tail</span><br><span class="line">	<span class="comment">// A consumer continues to own a slot outside this range until</span></span><br><span class="line">	<span class="comment">// it nils the slot, at which point ownership passes to the</span></span><br><span class="line">	<span class="comment">// producer.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The head index is stored in the most-significant bits so</span></span><br><span class="line">	<span class="comment">// that we can atomically add to it and the overflow is</span></span><br><span class="line">	<span class="comment">// harmless.</span></span><br><span class="line">	headTail <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// vals is a ring buffer of interface&#123;&#125; values stored in this</span></span><br><span class="line">	<span class="comment">// dequeue. The size of this must be a power of 2.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	vals就是这个环形buffer，长度是<span class="number">2</span>的幂次</span><br><span class="line">	<span class="comment">// vals[i].typ is nil if the slot is empty and non-nil</span></span><br><span class="line">	<span class="comment">// otherwise. A slot is still in use until *both* the tail</span></span><br><span class="line">	<span class="comment">// index has moved beyond it and typ has been set to nil. This</span></span><br><span class="line">	<span class="comment">// is set to nil atomically by the consumer and read</span></span><br><span class="line">	<span class="comment">// atomically by the producer.</span></span><br><span class="line">	vals []eface</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 类似于没有方法 interface&#123;&#125;</span></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">//这个slot是空的话，typ将会=nil；</span></span><br><span class="line">	<span class="comment">//而且每次读写改变slot状态都会是原子性操作</span></span><br><span class="line">	typ, val unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4>pushHead</h4>
<p>队列，由 <strong>单个</strong> 生产者推入head，如果满了就返回false;</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> dequeueBits = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pushHead adds val at the head of the queue. It returns false if the</span></span><br><span class="line"><span class="comment">// queue is full. It must only be called by a single producer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span> <span class="title">pushHead</span><span class="params">(val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	ptrs := atomic.LoadUint64(&amp;d.headTail)</span><br><span class="line">	head, tail := d.unpack(ptrs)</span><br><span class="line">	<span class="comment">//这里的dequeueBits</span></span><br><span class="line">	<span class="comment">//const dequeueBits = 32</span></span><br><span class="line">	<span class="comment">//这里判断</span></span><br><span class="line">	<span class="keyword">if</span> (tail+<span class="keyword">uint32</span>(<span class="built_in">len</span>(d.vals)))&amp;(<span class="number">1</span>&lt;&lt;dequeueBits<span class="number">-1</span>) == head &#123;</span><br><span class="line">		<span class="comment">// Queue is full.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	slot := &amp;d.vals[head&amp;<span class="keyword">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check if the head slot has been released by popTail.</span></span><br><span class="line">	typ := atomic.LoadPointer(&amp;slot.typ)</span><br><span class="line">	<span class="keyword">if</span> typ != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Another goroutine is still cleaning up the tail, so</span></span><br><span class="line">		<span class="comment">// the queue is actually still full.</span></span><br><span class="line">		<span class="comment">//其他goroutine正在清除(consume)tail</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The head slot is free, so we own it.</span></span><br><span class="line">	<span class="keyword">if</span> val == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//这里实际上是*struct&#123;&#125;类型，代表interface&#123;&#125;(nil)，因为我们使用nil来代表空的slot，所以要一种sentinel value (可以理解为标记值) 来代表nil</span></span><br><span class="line">		val = dequeueNil(<span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//slot是eface类型，slot转为interface&#123;&#125;，val就可以直接赋值给slot，又因为eface是interface&#123;&#125;其中一种实现，slot.typ和slot.val则不为空, 这里其实也是之前判断是否满队列的原因</span></span><br><span class="line">	*(*<span class="keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot)) = val</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Increment head. This passes ownership of slot to popTail</span></span><br><span class="line">	<span class="comment">// and acts as a store barrier for writing the slot.</span></span><br><span class="line">	<span class="comment">//插入后head +1 </span></span><br><span class="line">	atomic.AddUint64(&amp;d.headTail, <span class="number">1</span>&lt;&lt;dequeueBits)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4>PopTail</h4>
<p>这个就是消费者(<strong>多个</strong>)所用的，pop出队列尾的元素</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span> <span class="title">popTail</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> slot *eface</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		ptrs := atomic.LoadUint64(&amp;d.headTail)</span><br><span class="line">		head, tail := d.unpack(ptrs)</span><br><span class="line">		<span class="comment">//同样，先判断是否为空</span></span><br><span class="line">		<span class="keyword">if</span> tail == head &#123;</span><br><span class="line">			<span class="comment">// Queue is empty.</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Confirm head and tail (for our speculative check</span></span><br><span class="line">		<span class="comment">// above) and increment tail. If this succeeds, then</span></span><br><span class="line">		<span class="comment">// we own the slot at tail.</span></span><br><span class="line">		ptrs2 := d.pack(head, tail+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;</span><br><span class="line">			<span class="comment">// Success.</span></span><br><span class="line">			slot = &amp;d.vals[tail&amp;<span class="keyword">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We now own slot.</span></span><br><span class="line">	val := *(*<span class="keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot))</span><br><span class="line">	<span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;</span><br><span class="line">		val = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Tell pushHead that we're done with this slot. Zeroing the</span></span><br><span class="line">	<span class="comment">// slot is also important so we don't leave behind references</span></span><br><span class="line">	<span class="comment">// that could keep this object live longer than necessary.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// We write to val first and then publish that we're done with</span></span><br><span class="line">	<span class="comment">// this slot by atomically writing to typ.</span></span><br><span class="line">	<span class="comment">//将当前的slot设为空</span></span><br><span class="line">	slot.val = <span class="literal">nil</span></span><br><span class="line">	atomic.StorePointer(&amp;slot.typ, <span class="literal">nil</span>)</span><br><span class="line">	<span class="comment">// At this point pushHead owns the slot.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4>比较奇怪的PopHead</h4>
<p>顾名思义，移除在head的元素，如果队列是空的返回false，也只能被单个生产者使用
这个有点奇怪 ？？？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// popHead removes and returns the element at the head of the queue.</span></span><br><span class="line"><span class="comment">// It returns false if the queue is empty. It must only be called by a</span></span><br><span class="line"><span class="comment">// single producer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span> <span class="title">popHead</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> slot *eface</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		ptrs := atomic.LoadUint64(&amp;d.headTail)</span><br><span class="line">		<span class="comment">//解析出head，tail</span></span><br><span class="line">		head, tail := d.unpack(ptrs)</span><br><span class="line">		<span class="keyword">if</span> tail == head &#123;</span><br><span class="line">			<span class="comment">// Queue is empty.</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Confirm tail and decrement head. We do this before</span></span><br><span class="line">		<span class="comment">// reading the value to take back ownership of this</span></span><br><span class="line">		<span class="comment">// slot.</span></span><br><span class="line">		<span class="comment">//在读取该值之前，要先确认tail以及head -1，目的是可以拿回该slot的所有权???</span></span><br><span class="line">		<span class="comment">//理解为将当前指针指向head--的位置,因为这个是环状结构，无法从head-- 获得 head的地址，所以要先转移指针指向???</span></span><br><span class="line">		head--</span><br><span class="line">		ptrs2 := d.pack(head, tail)</span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;</span><br><span class="line">			<span class="comment">//成功更新该slot，跳出循环</span></span><br><span class="line">			<span class="comment">// We successfully took back slot.</span></span><br><span class="line">			slot = &amp;d.vals[head&amp;<span class="keyword">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果失败了，重新进行</span></span><br><span class="line">		<span class="comment">//失败的情况可能是更新失败，</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	val := *(*<span class="keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot))</span><br><span class="line">	<span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;</span><br><span class="line">		val = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Zero the slot. Unlike popTail, this isn't racing with</span></span><br><span class="line">	<span class="comment">// pushHead, so we don't need to be careful here.</span></span><br><span class="line">	*slot = eface&#123;&#125;</span><br><span class="line">	<span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3>PoolChain</h3>
<p>其中还有一个结构是配合pooldequeue实现了双线链表的poolChain</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// poolChain is a dynamically-sized version of poolDequeue.</span></span><br><span class="line"><span class="comment">//poolchain实际上就是一个动态大小版本的poolDeque</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This is implemented as a doubly-linked list queue of poolDequeues</span></span><br><span class="line"><span class="comment">// where each dequeue is double the size of the previous one. Once a</span></span><br><span class="line"><span class="comment">// dequeue fills up, this allocates a new one and only ever pushes to</span></span><br><span class="line"><span class="comment">// the latest dequeue. Pops happen from the other end of the list and</span></span><br><span class="line"><span class="comment">// once a dequeue is exhausted, it gets removed from the list.</span></span><br><span class="line"><span class="comment">//这个poolchain实际就是有双倍长度的poolDequeue，当其中一个dequeue被填充数据，其会分配一个新的dequeue，且把这个填充数据放入最新的一个dequeue上；</span></span><br><span class="line"><span class="keyword">type</span> poolChain <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">//因为只被生产者所用(推入)，不保证顺序，所以不必要保证串行性</span></span><br><span class="line">	<span class="comment">// head is the poolDequeue to push to. This is only accessed</span></span><br><span class="line">	<span class="comment">// by the producer, so doesn't need to be synchronized.</span></span><br><span class="line">	head *poolChainElt</span><br><span class="line"></span><br><span class="line">	<span class="comment">// tail is the poolDequeue to popTail from. This is accessed</span></span><br><span class="line">	<span class="comment">// by consumers, so reads and writes must be atomic.</span></span><br><span class="line">	tail *poolChainElt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> poolChainElt <span class="keyword">struct</span> &#123;</span><br><span class="line">	poolDequeue</span><br><span class="line"></span><br><span class="line">	<span class="comment">// next and prev link to the adjacent poolChainElts in this</span></span><br><span class="line">	<span class="comment">// poolChain.</span></span><br><span class="line">	<span class="comment">//这里的next和prev指向相邻的poolChain元素,其中next是被生产者所写，消费者读取，只能从nil变为non-nil,prev则刚好相反</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// next is written atomically by the producer and read</span></span><br><span class="line">	<span class="comment">// atomically by the consumer. It only transitions from nil to</span></span><br><span class="line">	<span class="comment">// non-nil.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// prev is written atomically by the consumer and read</span></span><br><span class="line">	<span class="comment">// atomically by the producer. It only transitions from</span></span><br><span class="line">	<span class="comment">// non-nil to nil.</span></span><br><span class="line">	next, prev *poolChainElt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理，poolChaint也有一样的方法：</p>
<h4>pushHead</h4>
<p>生产者增加元素</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span> <span class="title">pushHead</span><span class="params">(val <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	d := c.head</span><br><span class="line">	<span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Initialize the chain.</span></span><br><span class="line">		<span class="keyword">const</span> initSize = <span class="number">8</span> <span class="comment">// Must be a power of 2</span></span><br><span class="line">		d = <span class="built_in">new</span>(poolChainElt)</span><br><span class="line">		d.vals = <span class="built_in">make</span>([]eface, initSize)</span><br><span class="line">		c.head = d</span><br><span class="line">		storePoolChainElt(&amp;c.tail, d)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//先把该val插入到pooldeqeue中</span></span><br><span class="line">	<span class="keyword">if</span> d.pushHead(val) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The current dequeue is full. Allocate a new one of twice</span></span><br><span class="line">	<span class="comment">// the size.</span></span><br><span class="line">	<span class="comment">//当前pooldequeue满了,则设置新大小为前一次pooldequeue的两倍</span></span><br><span class="line">	newSize := <span class="built_in">len</span>(d.vals) * <span class="number">2</span></span><br><span class="line">	<span class="comment">//dequeueLimit为最大的size，</span></span><br><span class="line">	<span class="comment">//const dequeueLimit = (1&lt;&lt;dequeueBits)/4 = 2^30</span></span><br><span class="line">	<span class="keyword">if</span> newSize &gt;= dequeueLimit &#123;</span><br><span class="line">		<span class="comment">// Can't make it any bigger.</span></span><br><span class="line">		newSize = dequeueLimit</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	d2 := &amp;poolChainElt&#123;prev: d&#125;</span><br><span class="line">	d2.vals = <span class="built_in">make</span>([]eface, newSize)</span><br><span class="line">	c.head = d2</span><br><span class="line">	storePoolChainElt(&amp;d.next, d2)</span><br><span class="line">	d2.pushHead(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4>popTail</h4>
<p>消费者消费队列</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span> <span class="title">popTail</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	d := loadPoolChainElt(&amp;c.tail)</span><br><span class="line">	<span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// It's important that we load the next pointer</span></span><br><span class="line">		<span class="comment">// *before* popping the tail. In general, d may be</span></span><br><span class="line">		<span class="comment">// transiently empty, but if next is non-nil before</span></span><br><span class="line">		<span class="comment">// the pop and the pop fails, then d is permanently</span></span><br><span class="line">		<span class="comment">// empty, which is the only condition under which it's</span></span><br><span class="line">		<span class="comment">// safe to drop d from the chain.</span></span><br><span class="line">		d2 := loadPoolChainElt(&amp;d.next)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> val, ok := d.popTail(); ok &#123;</span><br><span class="line">			<span class="keyword">return</span> val, ok</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> d2 == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// This is the only dequeue. It's empty right</span></span><br><span class="line">			<span class="comment">// now, but could be pushed to in the future.</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// The tail of the chain has been drained, so move on</span></span><br><span class="line">		<span class="comment">// to the next dequeue. Try to drop it from the chain</span></span><br><span class="line">		<span class="comment">// so the next pop doesn't have to look at the empty</span></span><br><span class="line">		<span class="comment">// dequeue again.</span></span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;c.tail)), unsafe.Pointer(d), unsafe.Pointer(d2)) &#123;</span><br><span class="line">			<span class="comment">// We won the race. Clear the prev pointer so</span></span><br><span class="line">			<span class="comment">// the garbage collector can collect the empty</span></span><br><span class="line">			<span class="comment">// dequeue and so popHead doesn't back up</span></span><br><span class="line">			<span class="comment">// further than necessary.</span></span><br><span class="line">			storePoolChainElt(&amp;d2.prev, <span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		d = d2</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4>popHead</h4>
<p>逻辑比较简单，一个个pooldequeue去找，找完就往前一个元素继续</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span> <span class="title">popHead</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	d := c.head</span><br><span class="line">	<span class="keyword">for</span> d != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//首先从pooldequeue中pophead</span></span><br><span class="line">		<span class="keyword">if</span> val, ok := d.popHead(); ok &#123;</span><br><span class="line">			<span class="keyword">return</span> val, ok</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// There may still be unconsumed elements in the</span></span><br><span class="line">		<span class="comment">// previous dequeue, so try backing up.</span></span><br><span class="line">		<span class="comment">//pop完当前的pooldequeue则load前面的poolChainElt</span></span><br><span class="line">		d = loadPoolChainElt(&amp;d.prev)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3>由功能出发，猜结构</h3>
<p>池类技术不用问，get，set各一个，还有超过了size之后的清空</p>
<h4>Set</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Put adds x to the pool.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Put</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		<span class="keyword">if</span> fastrand()%<span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Randomly drop x on floor.</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		race.ReleaseMerge(poolRaceAddr(x))</span><br><span class="line">		race.Disable()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里pin</span></span><br><span class="line">	l, _ := p.pin()</span><br><span class="line">	<span class="keyword">if</span> l.private == <span class="literal">nil</span> &#123;</span><br><span class="line">		l.private = x</span><br><span class="line">		x = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> x != <span class="literal">nil</span> &#123;</span><br><span class="line">		l.shared.pushHead(x)</span><br><span class="line">	&#125;</span><br><span class="line">	runtime_procUnpin()</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 l, _ := p.pin() <strong>pin()</strong> 函数就值得深入看一下:</p>
<ol>
<li>大概意思就是，这个pin函数会pin住当前goroutine，防止抢占(可以看一下goroutines一节)</li>
<li>原子性操作atomic.LoadUintPtr()保证不会同步问题</li>
<li>返回值是</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// pin pins the current goroutine to P, disables preemption and</span></span><br><span class="line"><span class="comment">// returns poolLocal pool for the P and the P's id.</span></span><br><span class="line"><span class="comment">// Caller must call runtime_procUnpin() when done with the pool.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">pin</span><span class="params">()</span> <span class="params">(*poolLocal, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	pid := runtime_procPin()</span><br><span class="line">	<span class="comment">// In pinSlow we store to local and then to localSize, here we load in opposite order.</span></span><br><span class="line">	<span class="comment">// Since we've disabled preemption, GC cannot happen in between.</span></span><br><span class="line">	<span class="comment">// Thus here we must observe local at least as large localSize.</span></span><br><span class="line">	<span class="comment">// We can observe a newer/larger local, it is fine (we must observe its zero-initialized-ness).</span></span><br><span class="line">	s := atomic.LoadUintptr(&amp;p.localSize) <span class="comment">// load-acquire</span></span><br><span class="line">	l := p.local                          <span class="comment">// load-consume</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">uintptr</span>(pid) &lt; s &#123;</span><br><span class="line">		<span class="keyword">return</span> indexLocal(l, pid), pid</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p.pinSlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4>Get</h4>
<p>与set有一定的相似</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Disable()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//与set一样，都要先"锁住"当前goroutine</span></span><br><span class="line">	l, pid := p.pin()</span><br><span class="line">	x := l.private</span><br><span class="line">	l.private = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Try to pop the head of the local shard. We prefer</span></span><br><span class="line">		<span class="comment">// the head over the tail for temporal locality of</span></span><br><span class="line">		<span class="comment">// reuse.</span></span><br><span class="line">		x, _ = l.shared.popHead()</span><br><span class="line">		<span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">			x = p.getSlow(pid)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	runtime_procUnpin()</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		<span class="keyword">if</span> x != <span class="literal">nil</span> &#123;</span><br><span class="line">			race.Acquire(poolRaceAddr(x))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> &amp;&amp; p.New != <span class="literal">nil</span> &#123;</span><br><span class="line">		x = p.New()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://mhh12121.github.io/2020/03/24/Go/syncPool/" data-id="ckcw5ou7m00258d552xc85oko" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/03/26/Go/Reflect/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Golang Reflection
        
      </div>
    </a>
  
  
    <a href="/2020/03/01/redis/basic/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Redis basis</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Design-Pattern/">Design Pattern</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Distributed/">Distributed</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/">Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/">Javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LOCK/">LOCK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Love/">Love</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/">OS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Regular-Expression/">Regular Expression</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/String/">String</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/networking/">networking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/se/">se</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/security/">security</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Design-Pattern/" style="font-size: 12.5px;">Design Pattern</a> <a href="/tags/Distributed/" style="font-size: 12.5px;">Distributed</a> <a href="/tags/Golang/" style="font-size: 17.5px;">Golang</a> <a href="/tags/Java/" style="font-size: 17.5px;">Java</a> <a href="/tags/Javascript/" style="font-size: 12.5px;">Javascript</a> <a href="/tags/LOCK/" style="font-size: 10px;">LOCK</a> <a href="/tags/Love/" style="font-size: 10px;">Love</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/MySQL/" style="font-size: 12.5px;">MySQL</a> <a href="/tags/OS/" style="font-size: 10px;">OS</a> <a href="/tags/Regular-Expression/" style="font-size: 10px;">Regular Expression</a> <a href="/tags/String/" style="font-size: 10px;">String</a> <a href="/tags/css/" style="font-size: 12.5px;">css</a> <a href="/tags/golang/" style="font-size: 20px;">golang</a> <a href="/tags/javascript/" style="font-size: 12.5px;">javascript</a> <a href="/tags/networking/" style="font-size: 15px;">networking</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/se/" style="font-size: 10px;">se</a> <a href="/tags/security/" style="font-size: 10px;">security</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/24/Go/type/">Golang type</a>
          </li>
        
          <li>
            <a href="/2020/05/03/Go/Pointer/">Golang指针</a>
          </li>
        
          <li>
            <a href="/2020/04/03/MySQL/btree/">MySQL InnoDB Ｂ+tree</a>
          </li>
        
          <li>
            <a href="/2020/03/26/Go/Reflect/">Golang Reflection</a>
          </li>
        
          <li>
            <a href="/2020/03/24/Go/syncPool/">Golang sync.Pool</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Doujohner<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>