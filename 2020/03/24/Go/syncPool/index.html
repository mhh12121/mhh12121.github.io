

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content>
  <meta name="author" content="Doujohner">
  <meta name="keywords" content>
  <title>Golang sync.Pool - 兜的破烂</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/darcula.min.css">
  

  


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-03-24 22:10" pubdate>
      March 24, 2020 pm
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      72
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">Golang sync.Pool</h1>
            
            <div class="markdown-body" id="post-body">
              <p>golang进程池</p>
<a id="more"></a>
<h1>Sync.Pool</h1>
<p>这个是1.13后的大改进，大幅度削减开销;
首先明确一个<strong>目标</strong>就是：</p>
<p>池类技术都是为了减少资源的多次分配，在这里就是<strong>减少GC</strong>的压力，以及提高缓存命中率</p>
<h2 id="结构">结构</h2>
<p>相关内容主要在 sync/pool.go 和 sync/poolqueue.go上</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Pool <span class="hljs-keyword">struct</span> &#123;
	noCopy noCopy <span class="hljs-comment">//这个是一个保证了第一次使用不会被copy的结构,防止被复制，很多结构也有用到这个，比如syncgroup等</span>

	<span class="hljs-comment">//本地per-P的固定大小的pool，具体结构其实是[P]poolLocal</span>
	local     unsafe.Pointer <span class="hljs-comment">// local fixed-size per-P pool, actual type is [P]poolLocal</span>
	localSize <span class="hljs-keyword">uintptr</span>        <span class="hljs-comment">// size of the local array</span>

  <span class="hljs-comment">//1.13的重要更新！！！这个东西实际上在gc用到（会将其保存下来避免gc），后面再说</span>
    victim     unsafe.Pointer <span class="hljs-comment">// local from previous cycle</span>
	victimSize <span class="hljs-keyword">uintptr</span>        <span class="hljs-comment">// size of victims array</span>

	<span class="hljs-comment">// New optionally specifies a function to generate</span>
	<span class="hljs-comment">// a value when Get would otherwise return nil.</span>
	<span class="hljs-comment">// It may not be changed concurrently with calls to Get.</span>
	New <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">interface</span></span>&#123;&#125;
&#125;

<span class="hljs-keyword">type</span> poolLocal <span class="hljs-keyword">struct</span> &#123;
	poolLocalInternal
	<span class="hljs-comment">// Prevents false sharing on widespread platforms with</span>
	<span class="hljs-comment">// 128 mod (cache line size) = 0 .</span>
	pad [<span class="hljs-number">128</span> - unsafe.Sizeof(poolLocalInternal&#123;&#125;)%<span class="hljs-number">128</span>]<span class="hljs-keyword">byte</span>
&#125;
<span class="hljs-comment">// Local per-P Pool appendix.</span>
<span class="hljs-keyword">type</span> poolLocalInternal <span class="hljs-keyword">struct</span> &#123;
	<span class="hljs-comment">//不为空可以复用，如果为空则要从shared队列拿对象</span>
	private <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// Can be used only by the respective P.</span>
	shared  poolChain   <span class="hljs-comment">// Local P can pushHead/popHead; any P can popTail.</span>
&#125;</code></pre></div>
<p>容易想到池类技术多用队列来实现;</p>
<p>但是这里使用了让人感叹“喵啊喵啊”的结构：<strong>环式队列</strong></p>
<h3 id="pooldequeue">poolDequeue</h3>
<h4 id="基本结构">基本结构</h4>
<p>poolDequeue是一个无锁，固定大小，单生产者，多消费者的一个环形队列，生产者可以在head或者tail加上元素，但是消费者只能在tail消费</p>
<p>其特点就是会将<strong>不使用的slots设为nil</strong>，这一点咋一看不是觉得应该这样做嘛，但细节上还是有点复杂,下面先看一下基本结构</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> poolDequeue <span class="hljs-keyword">struct</span> &#123;
	<span class="hljs-comment">// headTail packs together a 32-bit head index and a 32-bit</span>
	<span class="hljs-comment">// tail index. Both are indexes into vals modulo len(vals)-1.</span>
	<span class="hljs-comment">//</span>
	<span class="hljs-comment">// tail = index of oldest data in queue</span>
	<span class="hljs-comment">// head = index of next slot to fill</span>
	<span class="hljs-comment">//头部，生产者放入data</span>
	<span class="hljs-comment">// Slots in the range [tail, head) are owned by consumers.</span>
	<span class="hljs-comment">//消费者只消费tail</span>
	<span class="hljs-comment">// A consumer continues to own a slot outside this range until</span>
	<span class="hljs-comment">// it nils the slot, at which point ownership passes to the</span>
	<span class="hljs-comment">// producer.</span>
	<span class="hljs-comment">//</span>


	<span class="hljs-comment">// The head index is stored in the most-significant bits so</span>
	<span class="hljs-comment">// that we can atomically add to it and the overflow is</span>
	<span class="hljs-comment">// harmless.</span>
	headTail <span class="hljs-keyword">uint64</span>

	<span class="hljs-comment">// vals is a ring buffer of interface&#123;&#125; values stored in this</span>
	<span class="hljs-comment">// dequeue. The size of this must be a power of 2.</span>
	<span class="hljs-comment">//</span>
	<span class="hljs-comment">//vals就是这个环形buffer，长度是2的幂次</span>
	<span class="hljs-comment">// vals[i].typ is nil if the slot is empty and non-nil</span>
	<span class="hljs-comment">// otherwise. A slot is still in use until *both* the tail</span>
	<span class="hljs-comment">// index has moved beyond it and typ has been set to nil. This</span>
	<span class="hljs-comment">// is set to nil atomically by the consumer and read</span>
	<span class="hljs-comment">// atomically by the producer.</span>
	vals []eface
&#125;
 <span class="hljs-comment">// 类似于没有方法 interface&#123;&#125;</span>
<span class="hljs-keyword">type</span> eface <span class="hljs-keyword">struct</span> &#123;
	<span class="hljs-comment">//这个slot是空的话，typ将会=nil；</span>
	<span class="hljs-comment">//而且每次读写改变slot状态都会是原子性操作</span>
	typ, val unsafe.Pointer
&#125;
<span class="hljs-comment">//还有一些定义</span>
<span class="hljs-comment">// dequeueLimit is the maximum size of a poolDequeue.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// This must be at most (1&lt;&lt;dequeueBits)/2 because detecting fullness</span>
<span class="hljs-comment">// depends on wrapping around the ring buffer without wrapping around</span>
<span class="hljs-comment">// the index. We divide by 4 so this fits in an int on 32-bit.</span>
<span class="hljs-keyword">const</span> dequeueLimit = (<span class="hljs-number">1</span> &lt;&lt; dequeueBits) / <span class="hljs-number">4</span></code></pre></div>
<p>先回答一下之前的问题：</p>
<ul>
<li>vals[i].typ如果是nil = 该slot为空否则一定为空(必要条件)</li>
<li>判断slot是否还在被使用要结合index(已经移到前面即为空)和vals[i].typ是否为空来决定</li>
<li>消费者设置其为nil以及生产者读取都是<strong>原子操作</strong></li>
</ul>
<p>还有可以看到上面规定了dequeue的最大limit，为什么呢？
上面的解释是 检测是否队列满取决于该ring buffer而不是其index，理解&gt;???</p>
<h4 id="pushhead">pushHead</h4>
<p>队列，由 <strong>单个</strong> 生产者推入head，如果满了就返回false;</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">const</span> dequeueBits = <span class="hljs-number">32</span>

<span class="hljs-comment">// pushHead adds val at the head of the queue. It returns false if the</span>
<span class="hljs-comment">// queue is full. It must only be called by a single producer.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *poolDequeue)</span> <span class="hljs-title">pushHead</span><span class="hljs-params">(val <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span> &#123;
	ptrs := atomic.LoadUint64(&amp;d.headTail)
	<span class="hljs-comment">//根据headTail计算出真正的head和tail</span>
	head, tail := d.unpack(ptrs) 
	<span class="hljs-comment">//这里的dequeueBits</span>
	<span class="hljs-comment">//const dequeueBits = 32</span>
	<span class="hljs-comment">//这里判断???  </span>
	<span class="hljs-keyword">if</span> (tail+<span class="hljs-keyword">uint32</span>(<span class="hljs-built_in">len</span>(d.vals)))&amp;(<span class="hljs-number">1</span>&lt;&lt;dequeueBits<span class="hljs-number">-1</span>) == head &#123;
		<span class="hljs-comment">// Queue is full.</span>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
	&#125;
	slot := &amp;d.vals[head&amp;<span class="hljs-keyword">uint32</span>(<span class="hljs-built_in">len</span>(d.vals)<span class="hljs-number">-1</span>)]

	<span class="hljs-comment">// Check if the head slot has been released by popTail.</span>
	typ := atomic.LoadPointer(&amp;slot.typ)
	<span class="hljs-keyword">if</span> typ != <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-comment">// Another goroutine is still cleaning up the tail, so</span>
		<span class="hljs-comment">// the queue is actually still full.</span>
		<span class="hljs-comment">//其他goroutine正在清除(consume)tail</span>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
	&#125;

	<span class="hljs-comment">// The head slot is free, so we own it.</span>
	<span class="hljs-keyword">if</span> val == <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-comment">//这里实际上是*struct&#123;&#125;类型，代表interface&#123;&#125;(nil)，因为我们使用nil来代表空的slot，所以要一种sentinel value (可以理解为标记值) 来代表nil</span>
		val = dequeueNil(<span class="hljs-literal">nil</span>)
	&#125;
	<span class="hljs-comment">//slot是eface类型，slot转为interface&#123;&#125;，val就可以直接赋值给slot，又因为eface是interface&#123;&#125;其中一种实现，slot.typ和slot.val则不为空, 这里其实也是之前判断是否满队列的原因</span>
	*(*<span class="hljs-keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot)) = val

	<span class="hljs-comment">// Increment head. This passes ownership of slot to popTail</span>
	<span class="hljs-comment">// and acts as a store barrier for writing the slot.</span>
	<span class="hljs-comment">//插入后head +1 </span>
	atomic.AddUint64(&amp;d.headTail, <span class="hljs-number">1</span>&lt;&lt;dequeueBits)
	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
&#125;

<span class="hljs-comment">//计算head和tail的index</span>
<span class="hljs-comment">//实际前32位是head，后32位是tail</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *poolDequeue)</span> <span class="hljs-title">unpack</span><span class="hljs-params">(ptrs <span class="hljs-keyword">uint64</span>)</span> <span class="hljs-params">(head, tail <span class="hljs-keyword">uint32</span>)</span></span> &#123;
	<span class="hljs-comment">//dequeueBits = 32</span>
	<span class="hljs-keyword">const</span> mask = <span class="hljs-number">1</span>&lt;&lt;dequeueBits - <span class="hljs-number">1</span>
	head = <span class="hljs-keyword">uint32</span>((ptrs &gt;&gt; dequeueBits) &amp; mask)
	tail = <span class="hljs-keyword">uint32</span>(ptrs &amp; mask)
	<span class="hljs-keyword">return</span>
&#125;</code></pre></div>
<h4 id="poptail">PopTail</h4>
<p>这个就是消费者(<strong>多个</strong>)所用的，pop出队列尾的元素</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *poolDequeue)</span> <span class="hljs-title">popTail</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-keyword">bool</span>)</span></span> &#123;
	<span class="hljs-keyword">var</span> slot *eface
	<span class="hljs-keyword">for</span> &#123;
		ptrs := atomic.LoadUint64(&amp;d.headTail)
		head, tail := d.unpack(ptrs)
		<span class="hljs-comment">//同样，先判断是否为空</span>
		<span class="hljs-keyword">if</span> tail == head &#123;
			<span class="hljs-comment">// Queue is empty.</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>
		&#125;

		<span class="hljs-comment">// Confirm head and tail (for our speculative check</span>
		<span class="hljs-comment">// above) and increment tail. If this succeeds, then</span>
		<span class="hljs-comment">// we own the slot at tail.</span>
		ptrs2 := d.pack(head, tail+<span class="hljs-number">1</span>)
		<span class="hljs-keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;
			<span class="hljs-comment">// Success.</span>
			slot = &amp;d.vals[tail&amp;<span class="hljs-keyword">uint32</span>(<span class="hljs-built_in">len</span>(d.vals)<span class="hljs-number">-1</span>)]
			<span class="hljs-keyword">break</span>
		&#125;
	&#125;

	<span class="hljs-comment">// We now own slot.</span>
	val := *(*<span class="hljs-keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot))
	<span class="hljs-keyword">if</span> val == dequeueNil(<span class="hljs-literal">nil</span>) &#123;
		val = <span class="hljs-literal">nil</span>
	&#125;

	<span class="hljs-comment">// Tell pushHead that we're done with this slot. Zeroing the</span>
	<span class="hljs-comment">// slot is also important so we don't leave behind references</span>
	<span class="hljs-comment">// that could keep this object live longer than necessary.</span>
	<span class="hljs-comment">//</span>
	<span class="hljs-comment">// We write to val first and then publish that we're done with</span>
	<span class="hljs-comment">// this slot by atomically writing to typ.</span>
	<span class="hljs-comment">//将当前的slot设为空</span>
	slot.val = <span class="hljs-literal">nil</span>
	atomic.StorePointer(&amp;slot.typ, <span class="hljs-literal">nil</span>)
	<span class="hljs-comment">// At this point pushHead owns the slot.</span>

	<span class="hljs-keyword">return</span> val, <span class="hljs-literal">true</span>
&#125;</code></pre></div>
<h4 id="pophead">PopHead</h4>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// popHead removes and returns the element at the head of the queue.</span>
<span class="hljs-comment">// It returns false if the queue is empty. It must only be called by a</span>
<span class="hljs-comment">// single producer.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *poolDequeue)</span> <span class="hljs-title">popHead</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-keyword">bool</span>)</span></span> &#123;
	<span class="hljs-keyword">var</span> slot *eface
	<span class="hljs-keyword">for</span> &#123;
		ptrs := atomic.LoadUint64(&amp;d.headTail)
		<span class="hljs-comment">//解析出head，tail</span>
		head, tail := d.unpack(ptrs)
		<span class="hljs-keyword">if</span> tail == head &#123;
			<span class="hljs-comment">// Queue is empty.</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>
		&#125;

		<span class="hljs-comment">// Confirm tail and decrement head. We do this before</span>
		<span class="hljs-comment">// reading the value to take back ownership of this</span>
		<span class="hljs-comment">// slot.</span>
		<span class="hljs-comment">//pophead即是head--，然后再用pack计算出pophead之后的ptr2，然后用原子方法设置ptr为ptr2,放回d.headTail,并取出其slot</span>
		head--
		ptrs2 := d.pack(head, tail)
		<span class="hljs-keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;
			<span class="hljs-comment">//成功更新该slot，跳出循环</span>
			<span class="hljs-comment">// We successfully took back slot.</span>
			slot = &amp;d.vals[head&amp;<span class="hljs-keyword">uint32</span>(<span class="hljs-built_in">len</span>(d.vals)<span class="hljs-number">-1</span>)]
			<span class="hljs-keyword">break</span>
		&#125;
		<span class="hljs-comment">//如果失败了，重新进行</span>
		<span class="hljs-comment">//失败的情况可能是更新失败，</span>
	&#125;

	val := *(*<span class="hljs-keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot))
	<span class="hljs-keyword">if</span> val == dequeueNil(<span class="hljs-literal">nil</span>) &#123;
		val = <span class="hljs-literal">nil</span>
	&#125;
	<span class="hljs-comment">// Zero the slot. Unlike popTail, this isn't racing with</span>
	<span class="hljs-comment">// pushHead, so we don't need to be careful here.</span>
	*slot = eface&#123;&#125;
	<span class="hljs-keyword">return</span> val, <span class="hljs-literal">true</span>
&#125;</code></pre></div>
<ul>
<li>注意： 至于为什么要先设置headTail，再取slot，目的是可能其他P会在当前P steal对象，多个P调用本地P的popTail的时候，race现象就变严重，这样做让某个P如果拿到了，其他P就无法再拿到对应的对象（因为headtail改变了，位置不一样）</li>
</ul>
<h3 id="poolchain">PoolChain</h3>
<p>其中还有一个结构是配合pooldequeue实现了双线链表的poolChain
可以看做poolchain实际上就是一个<strong>动态大小</strong>版本的poolDeque</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// poolChain is a dynamically-sized version of poolDequeue.</span>
<span class="hljs-comment">//poolchain实际上就是一个动态大小版本的poolDeque</span>

<span class="hljs-comment">// This is implemented as a doubly-linked list queue of poolDequeues</span>
<span class="hljs-comment">// where each dequeue is double the size of the previous one. Once a</span>
<span class="hljs-comment">// dequeue fills up, this allocates a new one and only ever pushes to</span>
<span class="hljs-comment">// the latest dequeue. Pops happen from the other end of the list and</span>
<span class="hljs-comment">// once a dequeue is exhausted, it gets removed from the list.</span>
<span class="hljs-comment">//这个poolchain实际就是有双倍长度的poolDequeue，当其中一个dequeue被填充数据，其会分配一个新的dequeue，且把这个填充数据放入最新的一个dequeue上；</span>
<span class="hljs-keyword">type</span> poolChain <span class="hljs-keyword">struct</span> &#123;
	<span class="hljs-comment">//因为只被生产者所用(推入)，不保证顺序，所以不必要保证串行性</span>
	<span class="hljs-comment">// head is the poolDequeue to push to. This is only accessed</span>
	<span class="hljs-comment">// by the producer, so doesn't need to be synchronized.</span>
	head *poolChainElt

	<span class="hljs-comment">// tail is the poolDequeue to popTail from. This is accessed</span>
	<span class="hljs-comment">// by consumers, so reads and writes must be atomic.</span>
	tail *poolChainElt
&#125;

<span class="hljs-keyword">type</span> poolChainElt <span class="hljs-keyword">struct</span> &#123;
	poolDequeue

	<span class="hljs-comment">// next and prev link to the adjacent poolChainElts in this</span>
	<span class="hljs-comment">// poolChain.</span>
	<span class="hljs-comment">//这里的next和prev指向相邻的poolChain元素,其中next是被生产者所写，消费者读取，只能从nil变为non-nil,prev则刚好相反</span>
	
	<span class="hljs-comment">// next is written atomically by the producer and read</span>
	<span class="hljs-comment">// atomically by the consumer. It only transitions from nil to</span>
	<span class="hljs-comment">// non-nil.</span>
	<span class="hljs-comment">//</span>
	<span class="hljs-comment">// prev is written atomically by the consumer and read</span>
	<span class="hljs-comment">// atomically by the producer. It only transitions from</span>
	<span class="hljs-comment">// non-nil to nil.</span>
	next, prev *poolChainElt
&#125;</code></pre></div>
<p>同理，同poolDequeue一样,包裹着它的poolChaint也有一样的方法：</p>
<h4 id="pushhead-v2">pushHead</h4>
<p>生产者增加元素,注意在当前ring buffer满了之后会初始化一个新的poolChainElt，其中poolDequque大小为原来的2倍</p>
<ul>
<li>该链表poolChain的初始化大小为8</li>
<li>每次增多一个poolDequeue是前一个的2倍，且一定是2的幂次</li>
<li>poolDequeue的最大的长度是2^30，再多的poolDequeue也不会变</li>
</ul>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *poolChain)</span> <span class="hljs-title">pushHead</span><span class="hljs-params">(val <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;
	d := c.head
	<span class="hljs-keyword">if</span> d == <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-comment">// Initialize the chain.</span>
		<span class="hljs-keyword">const</span> initSize = <span class="hljs-number">8</span> <span class="hljs-comment">// Must be a power of 2</span>
		d = <span class="hljs-built_in">new</span>(poolChainElt)
		d.vals = <span class="hljs-built_in">make</span>([]eface, initSize)
		c.head = d
		storePoolChainElt(&amp;c.tail, d)
	&#125;
	<span class="hljs-comment">//先把该val插入到pooldeqeue中</span>
	<span class="hljs-keyword">if</span> d.pushHead(val) &#123;
		<span class="hljs-keyword">return</span>
	&#125;

	<span class="hljs-comment">// The current dequeue is full. Allocate a new one of twice</span>
	<span class="hljs-comment">// the size.</span>
	<span class="hljs-comment">//当前pooldequeue满了,则设置一个新的poolDeque,!!!</span>
	<span class="hljs-comment">//且新大小为前一次pooldequeue的两倍</span>
	newSize := <span class="hljs-built_in">len</span>(d.vals) * <span class="hljs-number">2</span>
	<span class="hljs-comment">//dequeueLimit为最大的size，</span>
	<span class="hljs-comment">//const dequeueLimit = (1&lt;&lt;dequeueBits)/4 = 2^30</span>
	<span class="hljs-keyword">if</span> newSize &gt;= dequeueLimit &#123;
		<span class="hljs-comment">// Can't make it any bigger.</span>
		newSize = dequeueLimit
	&#125;

	d2 := &amp;poolChainElt&#123;prev: d&#125;
	d2.vals = <span class="hljs-built_in">make</span>([]eface, newSize)
	c.head = d2
	<span class="hljs-comment">//实际就是将d.next指向新的一个ring buffer(poolChainElt),其结构体下面有</span>
	storePoolChainElt(&amp;d.next, d2)
	d2.pushHead(val)
&#125;</code></pre></div>
<h4 id="poptail-v2">popTail</h4>
<p>消费者消费队列</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *poolChain)</span> <span class="hljs-title">popTail</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-keyword">bool</span>)</span></span> &#123;
	d := loadPoolChainElt(&amp;c.tail)
	<span class="hljs-keyword">if</span> d == <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>
	&#125;

	<span class="hljs-keyword">for</span> &#123;
		<span class="hljs-comment">// It's important that we load the next pointer</span>
		<span class="hljs-comment">// *before* popping the tail. In general, d may be</span>
		<span class="hljs-comment">// transiently empty, but if next is non-nil before</span>
		<span class="hljs-comment">// the pop and the pop fails, then d is permanently</span>
		<span class="hljs-comment">// empty, which is the only condition under which it's</span>
		<span class="hljs-comment">// safe to drop d from the chain.</span>
		d2 := loadPoolChainElt(&amp;d.next)

		<span class="hljs-keyword">if</span> val, ok := d.popTail(); ok &#123;
			<span class="hljs-keyword">return</span> val, ok
		&#125;

		<span class="hljs-keyword">if</span> d2 == <span class="hljs-literal">nil</span> &#123;
			<span class="hljs-comment">// This is the only dequeue. It's empty right</span>
			<span class="hljs-comment">// now, but could be pushed to in the future.</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>
		&#125;

		<span class="hljs-comment">// The tail of the chain has been drained, so move on</span>
		<span class="hljs-comment">// to the next dequeue. Try to drop it from the chain</span>
		<span class="hljs-comment">// so the next pop doesn't have to look at the empty</span>
		<span class="hljs-comment">// dequeue again.</span>
		<span class="hljs-comment">//这里注意</span>
		<span class="hljs-keyword">if</span> atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;c.tail)), unsafe.Pointer(d), unsafe.Pointer(d2)) &#123;
			<span class="hljs-comment">// We won the race. Clear the prev pointer so</span>
			<span class="hljs-comment">// the garbage collector can collect the empty</span>
			<span class="hljs-comment">// dequeue and so popHead doesn't back up</span>
			<span class="hljs-comment">// further than necessary.</span>
			storePoolChainElt(&amp;d2.prev, <span class="hljs-literal">nil</span>)
		&#125;
		d = d2
	&#125;
&#125;</code></pre></div>
<ul>
<li>！！！！注意到上面有一段原子操作，主要可能有<strong>消费者是其他P</strong>的情况下， <strong>popTail</strong> 明显就与popHead以及pushHead有race</li>
</ul>
<h4 id="pophead-v2">popHead</h4>
<p>逻辑比较简单，一个个pooldequeue去找，找完就往前一个元素继续</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *poolChain)</span> <span class="hljs-title">popHead</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-keyword">bool</span>)</span></span> &#123;
	d := c.head
	<span class="hljs-keyword">for</span> d != <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-comment">//首先从pooldequeue中pophead</span>
		<span class="hljs-keyword">if</span> val, ok := d.popHead(); ok &#123;
			<span class="hljs-keyword">return</span> val, ok
		&#125;
		<span class="hljs-comment">// There may still be unconsumed elements in the</span>
		<span class="hljs-comment">// previous dequeue, so try backing up.</span>
		<span class="hljs-comment">//pop完当前的pooldequeue则load前面的poolChainElt</span>
		d = loadPoolChainElt(&amp;d.prev)
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>
&#125;</code></pre></div>
<p>综合上面的各个结构，大概画了<img src="/img/syncpool.png" srcset="/img/loading.gif" alt="一个图"></p>
<p>看到这里可能就有点疑问了，<strong>为啥有popTail，又要有popHead呢？？？</strong>
这也是其设计的 “喵啊喵啊” 之处，具体可以继续看下面的**Get()**方法</p>
<h3 id="由功能出发-猜结构">由功能出发，猜结构</h3>
<p>上面谈到的两种结构都有点印象了，下面就是真正如何使用:
池类技术不用问，get，set(put)各一个，还有超过了size之后的清空</p>
<h4 id="put">Put</h4>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// Put adds x to the pool.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span> <span class="hljs-title">Put</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;
	<span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-keyword">return</span>
	&#125;
	<span class="hljs-keyword">if</span> race.Enabled &#123;
		<span class="hljs-keyword">if</span> fastrand()%<span class="hljs-number">4</span> == <span class="hljs-number">0</span> &#123;
			<span class="hljs-comment">// Randomly drop x on floor.</span>
			<span class="hljs-keyword">return</span>
		&#125;
		race.ReleaseMerge(poolRaceAddr(x))
		race.Disable()
    &#125;
    <span class="hljs-comment">//这里pin</span>
	l, _ := p.pin()
	<span class="hljs-keyword">if</span> l.private == <span class="hljs-literal">nil</span> &#123;
		l.private = x
		x = <span class="hljs-literal">nil</span>
	&#125;
	<span class="hljs-keyword">if</span> x != <span class="hljs-literal">nil</span> &#123;
		l.shared.pushHead(x)
	&#125;
	runtime_procUnpin()
	<span class="hljs-keyword">if</span> race.Enabled &#123;
		race.Enable()
	&#125;
&#125;</code></pre></div>
<p>这里的 l, _ := p.pin() <strong>pin()</strong> 函数就值得深入看一下:</p>
<ol>
<li>大概意思就是，这个pin函数会pin住当前goroutine，<strong>防止抢占</strong>(可以看一下goroutines一节)</li>
<li>原子性操作atomic.LoadUintPtr()保证不会同步问题</li>
<li>返回值是本地poolLocal pool(poolChain和private)的指针，和这个p的id</li>
</ol>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// pin pins the current goroutine to P, disables preemption and</span>
<span class="hljs-comment">// returns poolLocal pool for the P and the P's id.</span>
<span class="hljs-comment">// Caller must call runtime_procUnpin() when done with the pool.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span> <span class="hljs-title">pin</span><span class="hljs-params">()</span> <span class="hljs-params">(*poolLocal, <span class="hljs-keyword">int</span>)</span></span> &#123;
	pid := runtime_procPin()
	<span class="hljs-comment">// In pinSlow we store to local and then to localSize, here we load in opposite order.</span>
	<span class="hljs-comment">// Since we've disabled preemption, GC cannot happen in between.</span>
	<span class="hljs-comment">// Thus here we must observe local at least as large localSize.</span>
	<span class="hljs-comment">// We can observe a newer/larger local, it is fine (we must observe its zero-initialized-ness).</span>
	<span class="hljs-comment">//获取localsize，锁住</span>
	s := atomic.LoadUintptr(&amp;p.localSize) <span class="hljs-comment">// load-acquire</span>
	<span class="hljs-comment">//</span>
	l := p.local                          <span class="hljs-comment">// load-consume</span>
	<span class="hljs-keyword">if</span> <span class="hljs-keyword">uintptr</span>(pid) &lt; s &#123;
		<span class="hljs-keyword">return</span> indexLocal(l, pid), pid
	&#125;
	<span class="hljs-keyword">return</span> p.pinSlow()
&#125;</code></pre></div>
<p>注意: 可以看一下这个<strong>runtime_procPin()</strong>，是runtime的汇编代码用来锁住调度过程(禁止抢占),这里主要是要获得当前P的id，如果被抢占可能P的id会变化;
一定要配合runtime_procUnpin()解锁;</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span> <span class="hljs-title">pinSlow</span><span class="hljs-params">()</span> <span class="hljs-params">(*poolLocal, <span class="hljs-keyword">int</span>)</span></span> &#123;
	<span class="hljs-comment">// Retry under the mutex.</span>
	<span class="hljs-comment">// Can not lock the mutex while pinned.</span>
	runtime_procUnpin()
	allPoolsMu.Lock()
	<span class="hljs-keyword">defer</span> allPoolsMu.Unlock()
	pid := runtime_procPin()
	<span class="hljs-comment">// poolCleanup won't be called while we are pinned.</span>
	s := p.localSize
	l := p.local
	<span class="hljs-comment">//uintptr(pid)小于[]localpool的size，则一定在[]localpool里面，直接进去拿</span>
	<span class="hljs-keyword">if</span> <span class="hljs-keyword">uintptr</span>(pid) &lt; s &#123;
		<span class="hljs-keyword">return</span> indexLocal(l, pid), pid
	&#125;
	<span class="hljs-keyword">if</span> p.local == <span class="hljs-literal">nil</span> &#123;
		allPools = <span class="hljs-built_in">append</span>(allPools, p)
	&#125;
	<span class="hljs-comment">// If GOMAXPROCS changes between GCs, we re-allocate the array and lose the old one.</span>
	size := runtime.GOMAXPROCS(<span class="hljs-number">0</span>)
	<span class="hljs-comment">//创建新的local</span>
	local := <span class="hljs-built_in">make</span>([]poolLocal, size)
	atomic.StorePointer(&amp;p.local, unsafe.Pointer(&amp;local[<span class="hljs-number">0</span>])) <span class="hljs-comment">// store-release</span>
	atomic.StoreUintptr(&amp;p.localSize, <span class="hljs-keyword">uintptr</span>(size))         <span class="hljs-comment">// store-release</span>
	<span class="hljs-keyword">return</span> &amp;local[pid], pid
&#125;</code></pre></div>
<ul>
<li>接下来，在p.pinSlow()还会进行一些判断,首先，在解锁了抢占然后再次调用runtime_ProcPin()为的就是获取最新的P的id;</li>
</ul>
<p><strong>目的</strong>: 个人理解是尽量减少 <strong>p.local([]poolLocal)</strong> 的创建，因为在解绑runtime_unProcPin()与下一次绑定之间可能P的id会变化，可以先检查切换的新的这个P的id里面是不是已经有 <strong>p.local([]poolLocal)</strong></p>
<ul>
<li>如果没有p.local没有对象就会创建新的一个 <strong>[]poollocal</strong> ，旧的poolocal就会进入GC</li>
</ul>
<h4 id="get">Get</h4>
<p>与set有一定的相似</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span> <span class="hljs-title">Get</span><span class="hljs-params">()</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;
	<span class="hljs-keyword">if</span> race.Enabled &#123;
		race.Disable()
    &#125;
    <span class="hljs-comment">//与set一样，都要先"锁住"当前goroutine</span>
	l, pid := p.pin()
	<span class="hljs-comment">//获得可复用的private对象</span>
	x := l.private
	l.private = <span class="hljs-literal">nil</span>
	<span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-comment">//private无复用的对象，只能从shared []poollocal拿</span>
		<span class="hljs-comment">// Try to pop the head of the local shard. We prefer</span>
		<span class="hljs-comment">// the head over the tail for temporal locality of</span>
		<span class="hljs-comment">// reuse.</span>
		<span class="hljs-comment">//首先会从本地的sharedpopHead</span>
		x, _ = l.shared.popHead()
		<span class="hljs-comment">//如果没有，就会进行getSlow()</span>
		<span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> &#123;
			x = p.getSlow(pid)
		&#125;
	&#125;
	runtime_procUnpin()
	<span class="hljs-keyword">if</span> race.Enabled &#123;
		race.Enable()
		<span class="hljs-keyword">if</span> x != <span class="hljs-literal">nil</span> &#123;
			race.Acquire(poolRaceAddr(x))
		&#125;
	&#125;
	<span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> &amp;&amp; p.New != <span class="hljs-literal">nil</span> &#123;
		x = p.New()
	&#125;
	<span class="hljs-keyword">return</span> x
&#125;</code></pre></div>
<p>这里就可以回答上面的问题了（<strong>为啥有popTail，又要有popHead呢？？？</strong>)：</p>
<ul>
<li>首先会从本地的sharedpopHead</li>
<li>如果在poollocal中找不到对象，则要调用**getSlow()**获得对象,getslow()代码如下</li>
<li>下面代码中 <strong>l.shared.popTail()</strong> 就发现是从其他P steal <strong>尾部</strong>获得poolChain</li>
</ul>
<p>这里都可以解释为什么有些地方不用锁:</p>
<blockquote>
<blockquote>
<blockquote>
<p>本地的就从head取对象，steal其他的P的对象就从其他P的tail取对象</p>
</blockquote>
</blockquote>
</blockquote>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span> <span class="hljs-title">getSlow</span><span class="hljs-params">(pid <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;
	<span class="hljs-comment">// See the comment in pin regarding ordering of the loads.</span>
	size := atomic.LoadUintptr(&amp;p.localSize) <span class="hljs-comment">// load-acquire</span>
	locals := p.local                        <span class="hljs-comment">// load-consume</span>
	<span class="hljs-comment">// Try to steal one element from other procs.</span>
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">int</span>(size); i++ &#123;
		l := indexLocal(locals, (pid+i+<span class="hljs-number">1</span>)%<span class="hljs-keyword">int</span>(size))
		<span class="hljs-comment">//从其他P的tail获得对象</span>
		<span class="hljs-keyword">if</span> x, _ := l.shared.popTail(); x != <span class="hljs-literal">nil</span> &#123;
			<span class="hljs-keyword">return</span> x
		&#125;
	&#125;

	<span class="hljs-comment">// Try the victim cache. We do this after attempting to steal</span>
	<span class="hljs-comment">// from all primary caches because we want objects in the</span>
	<span class="hljs-comment">// victim cache to age out if at all possible.</span>
	size = atomic.LoadUintptr(&amp;p.victimSize)
	<span class="hljs-keyword">if</span> <span class="hljs-keyword">uintptr</span>(pid) &gt;= size &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
	&#125;
	locals = p.victim
	l := indexLocal(locals, pid)
	<span class="hljs-keyword">if</span> x := l.private; x != <span class="hljs-literal">nil</span> &#123;
		l.private = <span class="hljs-literal">nil</span>
		<span class="hljs-keyword">return</span> x
	&#125;
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">int</span>(size); i++ &#123;
		l := indexLocal(locals, (pid+i)%<span class="hljs-keyword">int</span>(size))
		<span class="hljs-keyword">if</span> x, _ := l.shared.popTail(); x != <span class="hljs-literal">nil</span> &#123;
			<span class="hljs-keyword">return</span> x
		&#125;
	&#125;

	<span class="hljs-comment">// Mark the victim cache as empty for future gets don't bother</span>
	<span class="hljs-comment">// with it.</span>
	atomic.StoreUintptr(&amp;p.victimSize, <span class="hljs-number">0</span>)

	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
&#125;</code></pre></div>
<ul>
<li>因为本地P无对象，会尝试从其他p中steal对象</li>
<li><strong>victime cache</strong> (1.13新增！！！)(其实属于计算机架构设计里面的词)
代码中拿到其他p的时候，会先从victim cache中获取对象 (locals []poolChain)，然后定位slot，如果该slot的private为空则又从shared里面poptail拿到对象</li>
<li>最后还要注意，如果找不到对象，会将victim cache设置为空 (设置victimSize=0) ，防止下一次再次从victim里面查找</li>
</ul>
<h3 id="victimcache">VictimCache</h3>
<p>涉及了gc</p>
<p>在pool包初始化时即注册了poolCleanUp()函数,该函数用于初始化victimcache字段</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;
	runtime_registerPoolCleanup(poolCleanup)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">poolCleanup</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-comment">// This function is called with the world stopped, at the beginning of a garbage collection.</span>
	<span class="hljs-comment">// It must not allocate and probably should not call any runtime functions.</span>

	<span class="hljs-comment">// Because the world is stopped, no pool user can be in a</span>
	<span class="hljs-comment">// pinned section (in effect, this has all Ps pinned).</span>

	<span class="hljs-comment">// Drop victim caches from all pools.</span>
	<span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> oldPools &#123;
		p.victim = <span class="hljs-literal">nil</span>
		p.victimSize = <span class="hljs-number">0</span>
	&#125;

	<span class="hljs-comment">// Move primary cache to victim cache.</span>
	<span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> allPools &#123;
		p.victim = p.local
		p.victimSize = p.localSize
		p.local = <span class="hljs-literal">nil</span>
		p.localSize = <span class="hljs-number">0</span>
	&#125;

	<span class="hljs-comment">// The pools with non-empty primary caches now have non-empty</span>
	<span class="hljs-comment">// victim caches and no pools have primary caches.</span>
	oldPools, allPools = allPools, <span class="hljs-literal">nil</span>
&#125;</code></pre></div>
<ul>
<li>该函数在stw的时候会被调用(在gc开始的时候),其不能分配也不应该调用任何runtime的函数，原因是防止？？？
如果gc发生在goorutine与 shared.poolChain 进行 put/get时，会保留整个pool，下一次gc就会浪费多一倍内存</li>
<li>因为stw，所有pool的user不能在pinned的部分</li>
<li>首先会将所有当前的pools(oldPools) victim cache置为0</li>
<li>然后将主要的cache(allPools里面的locals([]poolLocal)字段)移到当前的victim字段</li>
<li>更新oldPools和allPools</li>
</ul>
<p>可以对比一下1.12的poolCleanUp</p>
<p><strong>1.12的poolCleanup</strong></p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">poolCleanup</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-comment">// 该函数会注册到运行时 GC 阶段(前)，此时为 STW 状态，不需要加锁</span>
	<span class="hljs-comment">// 它必须不处理分配且不调用任何运行时函数，防御性的将一切归零，有以下两点原因:</span>
	<span class="hljs-comment">// 1. 防止整个 Pool 的 false retention???</span>
	<span class="hljs-comment">// 2. 如果 GC 发生在当有 goroutine 与 l.shared 进行 Put/Get 时，它会保留整个 Pool.</span>
	<span class="hljs-comment">//   那么下个 GC 周期的内存消耗将会翻倍。</span>
	<span class="hljs-comment">// 遍历所有 Pool 实例，接触相关引用，交由 GC 进行回收</span>
	<span class="hljs-keyword">for</span> i, p := <span class="hljs-keyword">range</span> allPools &#123;
		allPools[i] = <span class="hljs-literal">nil</span>
		<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">int</span>(p.localSize); i++ &#123;
			l := indexLocal(p.local, i)
			l.private = <span class="hljs-literal">nil</span>
			<span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> l.shared &#123;
				l.shared[j] = <span class="hljs-literal">nil</span>
			&#125;
			l.shared = <span class="hljs-literal">nil</span>
		&#125;
		p.local = <span class="hljs-literal">nil</span>
		p.localSize = <span class="hljs-number">0</span>
	&#125;
	allPools = []*Pool&#123;&#125;
&#125;</code></pre></div>
<ul>
<li>其每次gc stw都遍历allPools并清空local，private,shared，导致的结果就是时间gc消耗的时间变长，以及下一次进行分配的时候时间变长，以及下一次内存的消耗也会增多(虽然总的来讲是不变)</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/golang/">golang</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/03/26/Go/Reflect/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Golang Reflection</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/03/01/redis/basic/">
                        <span class="hidden-mobile">Redis basis</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Golang sync.Pool&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
