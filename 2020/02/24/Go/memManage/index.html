

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content>
  <meta name="author" content="Doujohner">
  <meta name="keywords" content>
  <title>Golang Memory Allocator - 兜的破烂</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/darcula.min.css">
  

  


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-02-24 22:10" pubdate>
      February 24, 2020 pm
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      77
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">Golang Memory Allocator</h1>
            
            <div class="markdown-body" id="post-body">
              <h1>golang内存管理</h1>
<a id="more"></a>
<p>go的内存管理是基于tcmalloc，<a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html" target="_blank" rel="noopener">这个连接</a>看详情</p>
<p>任何大小的内存页可以被分割成<strong>一系列同样大小的object</strong>,这些规定的大小size则被定义在<a href="#sizetoclass">sizetoclass</a>,然后被一个<strong>bitmap</strong>管理</p>
<h2 id="基本数据结构">基本数据结构</h2>
<p>类似于<a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html" target="_blank" rel="noopener">TCMalloc</a></p>
<p>大概概括:
其目的是 减少多线程对内存请求时候的锁竞争，在对小内存的申请时甚至可以无锁操作，获取大内存时用spinlocks；但是其在TLS会预分配一部分空间，所以启动时相比dlmalloc等其他内存分配器空间较大，但是最终会接近;</p>
<p><strong>class_to_allocnpages</strong>总共有67个范围</p>
<p>栈的分配也是多层次和多class的</p>
<ul>
<li>
<p>mspan (主要使用该机制减少碎片):</p>
<p>被内存堆管理的的页面，至少一个页(8KB)，用于范围分配内存，比如16-32B则分配32B,112~128则分配128B的span</p>
</li>
<li>
<p>mcentral</p>
<p>全局有 67 × 2 (?) 个对应不同size的span <strong>后备</strong>mcentral
收集所有特定size的span，如果也被用完，则再次转向mheap申请</p>
</li>
</ul>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> mheap <span class="hljs-keyword">struct</span>&#123;
	...
	<span class="hljs-comment">// central free lists for small size classes.</span>
	<span class="hljs-comment">// the padding makes sure that the mcentrals are</span>
	<span class="hljs-comment">// spaced CacheLinePadSize bytes apart, so that each mcentral.lock</span>
	<span class="hljs-comment">// gets its own cache line.</span>
	<span class="hljs-comment">// central is indexed by spanClass.</span>
	<span class="hljs-comment">//numSpanClasses = _NumSizeClasses &lt;&lt; 1 = 134</span>
	central [numSpanClasses]<span class="hljs-keyword">struct</span> &#123;
		mcentral <span class="hljs-keyword">type</span> mcentral <span class="hljs-keyword">struct</span> &#123;
					lock      mutex
					spanclass spanClass
					nonempty  mSpanList <span class="hljs-comment">// list of spans with a free object, ie a nonempty free list</span>
					empty     mSpanList <span class="hljs-comment">// list of spans with no free objects (or cached in an mcache)</span>

					<span class="hljs-comment">// nmalloc is the cumulative count of objects allocated from</span>
					<span class="hljs-comment">// this mcentral, assuming all spans in mcaches are</span>
					<span class="hljs-comment">// fully-allocated. Written atomically, read under STW.</span>
					nmalloc <span class="hljs-keyword">uint64</span>
				&#125;
		pad      [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral&#123;&#125;)%cpu.CacheLinePadSize]<span class="hljs-keyword">byte</span>
	&#125;
	....
&#125;</code></pre></div>
<p>代码中的pad是用作分割多个mcentral，以CacheLinePadSize个Bytes分割开，所以每一个mcentral的lock可以得到自己的cache line
我认为可以看做是内存对齐的一种方法(???是不是捏)</p>
<ul>
<li>
<p>mcache</p>
<p>多层次的cache用来减少分配冲突，mcache是per-P的，所以无锁，mspan的每个P(process)下的可用cache空间；小于16B直接使用P中的macache</p>
</li>
</ul>
<div class="hljs"><pre><code class="hljs golang">	<span class="hljs-comment">// Per-thread (in Go, per-P) cache for small objects.</span>
<span class="hljs-comment">// No locking needed because it is per-thread (per-P).</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// mcaches are allocated from non-GC'd memory, so any heap pointers</span>
<span class="hljs-comment">// must be specially handled.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//因为只用作local P，所以自然无锁</span>
<span class="hljs-comment">//go:notinheap</span>
<span class="hljs-comment">//这个标志说明了不在heap中，也可以理解，per - P好明显不在公共heap中</span>
<span class="hljs-keyword">type</span> mcache <span class="hljs-keyword">struct</span> &#123;
	<span class="hljs-comment">// The following members are accessed on every malloc,</span>
	<span class="hljs-comment">// so they are grouped here for better caching.</span>
	next_sample <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// trigger heap sample after allocating this many bytes</span>
	local_scan  <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// bytes of scannable heap allocated</span>

	<span class="hljs-comment">// Allocator cache for tiny objects w/o pointers.</span>
	<span class="hljs-comment">// See "Tiny allocator" comment in malloc.go.</span>
	<span class="hljs-comment">//具体可以见下面的tiny allocator分配器</span>
	<span class="hljs-comment">// tiny points to the beginning of the current tiny block, or</span>
	<span class="hljs-comment">// nil if there is no current tiny block.</span>
	<span class="hljs-comment">//</span>
	<span class="hljs-comment">// tiny is a heap pointer. Since mcache is in non-GC'd memory,</span>
	<span class="hljs-comment">// we handle it by clearing it in releaseAll during mark</span>
	<span class="hljs-comment">// termination.</span>
	tiny             <span class="hljs-keyword">uintptr</span>
	tinyoffset       <span class="hljs-keyword">uintptr</span>
	local_tinyallocs <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// number of tiny allocs not counted in other stats</span>

	<span class="hljs-comment">// The rest is not accessed on every malloc.</span>

	alloc [numSpanClasses]*mspan <span class="hljs-comment">// spans to allocate from, indexed by spanClass</span>

	stackcache [_NumStackOrders]stackfreelist

	<span class="hljs-comment">// Local allocator stats, flushed during GC.</span>
	local_largefree  <span class="hljs-keyword">uintptr</span>                  <span class="hljs-comment">// bytes freed for large objects (&gt;maxsmallsize)</span>
	local_nlargefree <span class="hljs-keyword">uintptr</span>                  <span class="hljs-comment">// number of frees for large objects (&gt;maxsmallsize)</span>
	local_nsmallfree [_NumSizeClasses]<span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// number of frees for small objects (&lt;=maxsmallsize)</span>

	<span class="hljs-comment">// flushGen indicates the sweepgen during which this mcache</span>
	<span class="hljs-comment">// was last flushed. If flushGen != mheap_.sweepgen, the spans</span>
	<span class="hljs-comment">// in this mcache are stale and need to the flushed so they</span>
	<span class="hljs-comment">// can be swept. This is done in acquirep.</span>
	flushGen <span class="hljs-keyword">uint32</span>
&#125;</code></pre></div>
<ul>
<li>fixalloc</li>
</ul>
<p>一个不定长度的列表，用来管理<strong>不在堆上</strong>的固定的对象，这些对象都是runtime上大小固定的结构，比如mspan，mcache</p>
<ul>
<li>
<p>mheap:</p>
<p>全局只有一个
内存堆，以页为粒度(8KB)进行管理,结构体为treap，维护空闲连续page，归还内存到heap中时，连续地址会合并；大于32KB内存申请直接从mheap中拿，剩下的则先使用当前P的mcache中对应的size class分配，如果其对应的span已经无可用的块，则向mcentral请求，如果没有则在mheap申请，如果还不够则要向操作系统申请;</p>
</li>
<li>
<p>mstatisitc</p>
<p>提供管理信息</p>
</li>
</ul>
<h3 id="mspan的结构体">mspan的结构体</h3>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> mspan <span class="hljs-keyword">struct</span> &#123;
	next *mspan     <span class="hljs-comment">// next span in list, or nil if none</span>
	prev *mspan     <span class="hljs-comment">// previous span in list, or nil if none</span>
	list *mSpanList <span class="hljs-comment">// For debugging. <span class="hljs-doctag">TODO:</span> Remove.</span>

	startAddr <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// address of first byte of span aka s.base()</span>
	npages    <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// number of pages in span</span>

	manualFreeList gclinkptr <span class="hljs-comment">// list of free objects in mSpanManual spans</span>

	<span class="hljs-comment">// freeindex is the slot index between 0 and nelems at which to begin scanning</span>
	<span class="hljs-comment">// for the next free object in this span.</span>
	<span class="hljs-comment">// Each allocation scans allocBits starting at freeindex until it encounters a 0</span>
	<span class="hljs-comment">// indicating a free object. freeindex is then adjusted so that subsequent scans begin</span>
	<span class="hljs-comment">// just past the newly discovered free object.</span>
	<span class="hljs-comment">//</span>
	<span class="hljs-comment">// If freeindex == nelem, this span has no free objects.</span>
	<span class="hljs-comment">//</span>
	<span class="hljs-comment">// allocBits is a bitmap of objects in this span.</span>
	<span class="hljs-comment">// If n &gt;= freeindex and allocBits[n/8] &amp; (1&lt;&lt;(n%8)) is 0</span>
	<span class="hljs-comment">// then object n is free;</span>
	<span class="hljs-comment">// otherwise, object n is allocated. Bits starting at nelem are</span>
	<span class="hljs-comment">// undefined and should never be referenced.</span>
	<span class="hljs-comment">//</span>
	<span class="hljs-comment">// Object n starts at address n*elemsize + (start &lt;&lt; pageShift).</span>
	freeindex <span class="hljs-keyword">uintptr</span>
	<span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Look up nelems from sizeclass and remove this field if it</span>
	<span class="hljs-comment">// helps performance.</span>
	nelems <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// number of object in the span.</span>

	<span class="hljs-comment">// Cache of the allocBits at freeindex. allocCache is shifted</span>
	<span class="hljs-comment">// such that the lowest bit corresponds to the bit freeindex.</span>
	<span class="hljs-comment">// allocCache holds the complement of allocBits, thus allowing</span>
	<span class="hljs-comment">// ctz (count trailing zero) to use it directly.</span>
	<span class="hljs-comment">// allocCache may contain bits beyond s.nelems; the caller must ignore</span>
	<span class="hljs-comment">// these.</span>
	allocCache <span class="hljs-keyword">uint64</span>

	<span class="hljs-comment">// allocBits and gcmarkBits hold pointers to a span's mark and</span>
	<span class="hljs-comment">// allocation bits. The pointers are 8 byte aligned.</span>
	<span class="hljs-comment">// There are three arenas where this data is held.</span>
	<span class="hljs-comment">// free: Dirty arenas that are no longer accessed</span>
	<span class="hljs-comment">//       and can be reused.</span>
	<span class="hljs-comment">// next: Holds information to be used in the next GC cycle.</span>
	<span class="hljs-comment">// current: Information being used during this GC cycle.</span>
	<span class="hljs-comment">// previous: Information being used during the last GC cycle.</span>
	<span class="hljs-comment">// A new GC cycle starts with the call to finishsweep_m.</span>
	<span class="hljs-comment">// finishsweep_m moves the previous arena to the free arena,</span>
	<span class="hljs-comment">// the current arena to the previous arena, and</span>
	<span class="hljs-comment">// the next arena to the current arena.</span>
	<span class="hljs-comment">// The next arena is populated as the spans request</span>
	<span class="hljs-comment">// memory to hold gcmarkBits for the next GC cycle as well</span>
	<span class="hljs-comment">// as allocBits for newly allocated spans.</span>
	<span class="hljs-comment">//</span>
	<span class="hljs-comment">// The pointer arithmetic is done "by hand" instead of using</span>
	<span class="hljs-comment">// arrays to avoid bounds checks along critical performance</span>
	<span class="hljs-comment">// paths.</span>
	<span class="hljs-comment">// The sweep will free the old allocBits and set allocBits to the</span>
	<span class="hljs-comment">// gcmarkBits. The gcmarkBits are replaced with a fresh zeroed</span>
	<span class="hljs-comment">// out memory.</span>
	allocBits  *gcBits
	gcmarkBits *gcBits

	<span class="hljs-comment">// sweep generation:</span>
	<span class="hljs-comment">// if sweepgen == h-&gt;sweepgen - 2, the span needs sweeping</span>
	<span class="hljs-comment">// if sweepgen == h-&gt;sweepgen - 1, the span is currently being swept</span>
	<span class="hljs-comment">// if sweepgen == h-&gt;sweepgen, the span is swept and ready to use</span>
	<span class="hljs-comment">// if sweepgen == h-&gt;sweepgen + 1, the span was cached before sweep began and is still cached, and needs sweeping</span>
	<span class="hljs-comment">// if sweepgen == h-&gt;sweepgen + 3, the span was swept and then cached and is still cached</span>
	<span class="hljs-comment">// h-&gt;sweepgen is incremented by 2 after every GC</span>

	sweepgen    <span class="hljs-keyword">uint32</span>
	divMul      <span class="hljs-keyword">uint16</span>     <span class="hljs-comment">// for divide by elemsize - divMagic.mul</span>
	baseMask    <span class="hljs-keyword">uint16</span>     <span class="hljs-comment">// if non-0, elemsize is a power of 2, &amp; this will get object allocation base</span>
	allocCount  <span class="hljs-keyword">uint16</span>     <span class="hljs-comment">// number of allocated objects</span>
	spanclass   spanClass  <span class="hljs-comment">// size class and noscan (uint8)</span>
	state       mSpanState <span class="hljs-comment">// mspaninuse etc</span>
	needzero    <span class="hljs-keyword">uint8</span>      <span class="hljs-comment">// needs to be zeroed before allocation</span>
	divShift    <span class="hljs-keyword">uint8</span>      <span class="hljs-comment">// for divide by elemsize - divMagic.shift</span>
	divShift2   <span class="hljs-keyword">uint8</span>      <span class="hljs-comment">// for divide by elemsize - divMagic.shift2</span>
	scavenged   <span class="hljs-keyword">bool</span>       <span class="hljs-comment">// whether this span has had its pages released to the OS</span>
	elemsize    <span class="hljs-keyword">uintptr</span>    <span class="hljs-comment">// computed from sizeclass or from npages</span>
	limit       <span class="hljs-keyword">uintptr</span>    <span class="hljs-comment">// end of data in span</span>
	speciallock mutex      <span class="hljs-comment">// guards specials list</span>
	specials    *special   <span class="hljs-comment">// linked list of special records sorted by offset.</span>
&#125;</code></pre></div>
<p>主要的字段:</p>
<ul>
<li>
<p>elementsize: slot大小，B为单位</p>
</li>
<li>
<p>freeindex，&lt;该值的已经被分配，&gt;=该位置的可能未被分配，需要配合allocCache查找,每次分配后，freeindex设置为分配的slot+1</p>
</li>
<li>
<p>allocBits表示上一次GC之后哪一些slot被使用，0未使用或释放，1已分配</p>
</li>
<li>
<p>allocCache表示从freeindex开始的64个slot的分配情况，1为未分配，0为已分配，使用ctz(Count trailing zeros指令)找到第一个非0位，使用完了就从allocBits加载，取反；</p>
</li>
<li>
<p>每次gc完的sweep阶段，将allocBits设置为gcmarkbits</p>
</li>
</ul>
<h2 id="内存总体结构">内存总体结构</h2>
<p>暂时将linux amd64作为例子</p>
<ul>
<li>
<p>1.10以前，内存不是初始化就分配虚拟内存
arena大小为512G，为了方便将其分为一个个page，所以总共也有512G/8KB = 65536个page</p>
<p>span区域存放指向span的指针，表示arena区域page所属的span，所以其大小即为 512GB/8KB* 8B(指针大小) = 512M</p>
<p>bitmap主要用于GC，两个bit表示arena中一个字的可用状态，所以表示为 (512GB/ 8(8个byte一个字，即指令长度)) * 2 /8 (8个bit一个byte) = 16G 长度</p>
</li>
<li>
<p>1.11以后
改成两阶段稀疏索引方式，内存允许超过512G，也可以允许不连续内存
mheap中的arenas字段实际是一个指针数组，每个heapArena管理一个64MB的内存
bitmap和spans功能不变</p>
</li>
</ul>
<h2 id="go的分配内存策略：">go的分配内存策略：</h2>
<h3 id="小对象-小于32k-和大对象的不同">小对象（小于32K）和大对象的不同</h3>
<ol>
<li>小于32KB的小对象时，会直接去 P (process)的cache的list里面拿，大于32KB的才去堆拿;
拿的过程会roundup一下大小，然后在当前P的mcachexmspan</li>
</ol>
<div class="hljs"><pre><code class="hljs golang"><span class="hljs-comment">// Allocate an object of size bytes.</span>
<span class="hljs-comment">// Small objects are allocated from the per-P cache's free lists.</span>
<span class="hljs-comment">// Large objects (&gt; 32 kB) are allocated straight from the heap.</span>
<span class="hljs-comment">//typ有两种，一种noscan，一种是scan，表示分配对象是否包含指针</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mallocgc</span><span class="hljs-params">(size <span class="hljs-keyword">uintptr</span>, typ *_type, needzero <span class="hljs-keyword">bool</span>)</span> <span class="hljs-title">unsafe</span>.<span class="hljs-title">Pointer</span></span> &#123;
	<span class="hljs-keyword">if</span> gcphase == _GCmarktermination &#123;
		throw(<span class="hljs-string">"mallocgc called with gcphase == _GCmarktermination"</span>)
	&#125;

	<span class="hljs-keyword">if</span> size == <span class="hljs-number">0</span> &#123;
		<span class="hljs-keyword">return</span> unsafe.Pointer(&amp;zerobase)
	&#125;
	......
	
	<span class="hljs-comment">// assistG is the G to charge for this allocation, or nil if</span>
	<span class="hljs-comment">// GC is not currently active.</span>
	<span class="hljs-keyword">var</span> assistG *g
	<span class="hljs-keyword">if</span> gcBlackenEnabled != <span class="hljs-number">0</span> &#123;
		<span class="hljs-comment">// Charge the current user G for this allocation.</span>
		assistG = getg()
		<span class="hljs-keyword">if</span> assistG.m.curg != <span class="hljs-literal">nil</span> &#123;
			assistG = assistG.m.curg
		&#125;
		<span class="hljs-comment">// Charge the allocation against the G. We'll account</span>
		<span class="hljs-comment">// for internal fragmentation at the end of mallocgc.</span>
		assistG.gcAssistBytes -= <span class="hljs-keyword">int64</span>(size)

		<span class="hljs-keyword">if</span> assistG.gcAssistBytes &lt; <span class="hljs-number">0</span> &#123;
			<span class="hljs-comment">// This G is in debt. Assist the GC to correct</span>
			<span class="hljs-comment">// this before allocating. This must happen</span>
			<span class="hljs-comment">// before disabling preemption.</span>
			gcAssistAlloc(assistG)
		&#125;
	&#125;

	<span class="hljs-comment">// Set mp.mallocing to keep from being preempted by GC.</span>
	mp := acquirem()
	<span class="hljs-keyword">if</span> mp.mallocing != <span class="hljs-number">0</span> &#123;
		throw(<span class="hljs-string">"malloc deadlock"</span>)
	&#125;
	<span class="hljs-keyword">if</span> mp.gsignal == getg() &#123;
		throw(<span class="hljs-string">"malloc during signal"</span>)
	&#125;
	mp.mallocing = <span class="hljs-number">1</span>

	shouldhelpgc := <span class="hljs-literal">false</span>
	dataSize := size
	c := gomcache()
	<span class="hljs-keyword">var</span> x unsafe.Pointer

	noscan := typ == <span class="hljs-literal">nil</span> || typ.ptrdata == <span class="hljs-number">0</span>
	<span class="hljs-keyword">if</span> size &lt;= maxSmallSize &#123;
		...
		<span class="hljs-comment">//tiny allocator分配方式的代码</span>
	&#125; <span class="hljs-keyword">else</span> &#123;
		<span class="hljs-keyword">var</span> s *mspan
		shouldhelpgc = <span class="hljs-literal">true</span>
		systemstack(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
			s = largeAlloc(size, needzero, noscan)
		&#125;)
		s.freeindex = <span class="hljs-number">1</span>
		s.allocCount = <span class="hljs-number">1</span>
		x = unsafe.Pointer(s.base())
		size = s.elemsize
	&#125;

	<span class="hljs-keyword">var</span> scanSize <span class="hljs-keyword">uintptr</span>
	<span class="hljs-keyword">if</span> !noscan &#123;
		<span class="hljs-comment">// If allocating a defer+arg block, now that we've picked a malloc size</span>
		<span class="hljs-comment">// large enough to hold everything, cut the "asked for" size down to</span>
		<span class="hljs-comment">// just the defer header, so that the GC bitmap will record the arg block</span>
		<span class="hljs-comment">// as containing nothing at all (as if it were unused space at the end of</span>
		<span class="hljs-comment">// a malloc block caused by size rounding).</span>
		<span class="hljs-comment">// The defer arg areas are scanned as part of scanstack.</span>
		<span class="hljs-keyword">if</span> typ == deferType &#123;
			dataSize = unsafe.Sizeof(_defer&#123;&#125;)
		&#125;
		heapBitsSetType(<span class="hljs-keyword">uintptr</span>(x), size, dataSize, typ)
		<span class="hljs-keyword">if</span> dataSize &gt; typ.size &#123;
			<span class="hljs-comment">// Array allocation. If there are any</span>
			<span class="hljs-comment">// pointers, GC has to scan to the last</span>
			<span class="hljs-comment">// element.</span>
			<span class="hljs-keyword">if</span> typ.ptrdata != <span class="hljs-number">0</span> &#123;
				scanSize = dataSize - typ.size + typ.ptrdata
			&#125;
		&#125; <span class="hljs-keyword">else</span> &#123;
			scanSize = typ.ptrdata
		&#125;
		c.local_scan += scanSize
	&#125;

	<span class="hljs-comment">// Ensure that the stores above that initialize x to</span>
	<span class="hljs-comment">// type-safe memory and set the heap bits occur before</span>
	<span class="hljs-comment">// the caller can make x observable to the garbage</span>
	<span class="hljs-comment">// collector. Otherwise, on weakly ordered machines,</span>
	<span class="hljs-comment">// the garbage collector could follow a pointer to x,</span>
	<span class="hljs-comment">// but see uninitialized memory or stale heap bits.</span>
	publicationBarrier()

	<span class="hljs-comment">// Allocate black during GC.</span>
	<span class="hljs-comment">// All slots hold nil so no scanning is needed.</span>
	<span class="hljs-comment">// This may be racing with GC so do it atomically if there can be</span>
	<span class="hljs-comment">// a race marking the bit.</span>
	<span class="hljs-keyword">if</span> gcphase != _GCoff &#123;
		gcmarknewobject(<span class="hljs-keyword">uintptr</span>(x), size, scanSize)
	&#125;

	<span class="hljs-keyword">if</span> raceenabled &#123;
		racemalloc(x, size)
	&#125;

	<span class="hljs-keyword">if</span> msanenabled &#123;
		msanmalloc(x, size)
	&#125;

	mp.mallocing = <span class="hljs-number">0</span>
	releasem(mp)

	<span class="hljs-keyword">if</span> debug.allocfreetrace != <span class="hljs-number">0</span> &#123;
		tracealloc(x, size, typ)
	&#125;

	<span class="hljs-keyword">if</span> rate := MemProfileRate; rate &gt; <span class="hljs-number">0</span> &#123;
		<span class="hljs-keyword">if</span> rate != <span class="hljs-number">1</span> &amp;&amp; size &lt; c.next_sample &#123;
			c.next_sample -= size
		&#125; <span class="hljs-keyword">else</span> &#123;
			mp := acquirem()
			profilealloc(mp, x, size)
			releasem(mp)
		&#125;
	&#125;

	<span class="hljs-keyword">if</span> assistG != <span class="hljs-literal">nil</span> &#123;
		<span class="hljs-comment">// Account for internal fragmentation in the assist</span>
		<span class="hljs-comment">// debt now that we know it.</span>
		assistG.gcAssistBytes -= <span class="hljs-keyword">int64</span>(size - dataSize)
	&#125;

	<span class="hljs-keyword">if</span> shouldhelpgc &#123;
		<span class="hljs-keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerHeap&#125;); t.test() &#123;
			gcStart(t)
		&#125;
	&#125;

	<span class="hljs-keyword">return</span> x
&#125;</code></pre></div>
<h3 id="各种分配器">各种分配器</h3>
<h4 id="tinyallocator">TinyAllocator</h4>
<p>上面的源代码中，当size&lt;=maxSmallSize时，实际上调用了一种tinyAllocator的分配器</p>
<p>该分配是 <strong>会结合多个申请内存请求 成为 申请一个内存块的请求(即合并小对象存储下来)</strong>；
所以当所有的子对象都不可达时，这个内存块才会被释放（同时这些对象一定不含指针，这个很好理解，有指针又要从指针处进行可达性查询）
作用是<strong>避免可能内存浪费</strong></p>
<p>其中这个maxTinySize是可调整的，调整成8bytes就一定不会浪费任何内存（一个页就8B），但是这样就没什么意义（不用combine）
照这个道理，16bytes就可能会造成2× 最坏情况的内存浪费，32B就会造成4×最坏情况的内存浪费</p>
<ul>
<li>
<p>其中从tinyallocator分配的对象不能被显式释放(?)，所以每次我们显式释放对象的时候，自然的要保证这个对象是大于maxTinySize</p>
</li>
<li>
<p>主要的对象是一些小字符串和一些独立的变量，json的benchmark使用了这个分配器，减少了20%的堆size</p>
</li>
</ul>
<p>其结构<img src="/img/tinyObjects.png" srcset="/img/loading.gif" alt="如图"></p>
<ul>
<li>每个P在本地维护了专门的memory block来存储tinyObject，分配时根据tinyoffset和需要的size及对齐来判断该block是否容纳该object，如果可以就返回地址</li>
</ul>
<div class="hljs"><pre><code class="hljs go">
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mallocgc</span><span class="hljs-params">(size <span class="hljs-keyword">uintptr</span>, typ *_type, needzero <span class="hljs-keyword">bool</span>)</span> <span class="hljs-title">unsafe</span>.<span class="hljs-title">Pointer</span></span> &#123;
	....
	<span class="hljs-comment">//maxSmallsize = 32786</span>
	<span class="hljs-keyword">if</span> size&lt;=maxSmallSize &#123;
		<span class="hljs-comment">//申请对象不含指针且小于16B则会调用tiny allocator</span>
		<span class="hljs-keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123;
			<span class="hljs-comment">// Tiny allocator.</span>
			<span class="hljs-comment">//</span>
			<span class="hljs-comment">//一种分配器</span>
			<span class="hljs-comment">// Tiny allocator combines several tiny allocation requests</span>
			<span class="hljs-comment">// into a single memory block. The resulting memory block</span>
			<span class="hljs-comment">// is freed when all subobjects are unreachable. The subobjects</span>
			<span class="hljs-comment">// must be noscan (don't have pointers), this ensures that</span>
			<span class="hljs-comment">// the amount of potentially wasted memory is bounded.</span>
			<span class="hljs-comment">//</span>
			<span class="hljs-comment">// Size of the memory block used for combining (maxTinySize) is tunable.</span>
			<span class="hljs-comment">// Current setting is 16 bytes, which relates to 2x worst case memory</span>
			<span class="hljs-comment">// wastage (when all but one subobjects are unreachable).</span>
			<span class="hljs-comment">// 8 bytes would result in no wastage at all, but provides less</span>
			<span class="hljs-comment">// opportunities for combining.</span>
			<span class="hljs-comment">// 32 bytes provides more opportunities for combining,</span>
			<span class="hljs-comment">// but can lead to 4x worst case wastage.</span>
			<span class="hljs-comment">// The best case winning is 8x regardless of block size.</span>
			<span class="hljs-comment">//</span>
			<span class="hljs-comment">// Objects obtained from tiny allocator must not be freed explicitly.</span>
			<span class="hljs-comment">// So when an object will be freed explicitly, we ensure that</span>
			<span class="hljs-comment">// its size &gt;= maxTinySize.</span>
			<span class="hljs-comment">//</span>
			<span class="hljs-comment">// SetFinalizer has a special case for objects potentially coming</span>
			<span class="hljs-comment">// from tiny allocator, it such case it allows to set finalizers</span>
			<span class="hljs-comment">// for an inner byte of a memory block.</span>
			<span class="hljs-comment">//</span>
			<span class="hljs-comment">// The main targets of tiny allocator are small strings and</span>
			<span class="hljs-comment">// standalone escaping variables. On a json benchmark</span>
			<span class="hljs-comment">// the allocator reduces number of allocations by ~12% and</span>
			<span class="hljs-comment">// reduces heap size by ~20%.</span>
			off := c.tinyoffset
			<span class="hljs-comment">// Align tiny pointer for required (conservative) alignment.</span>
			<span class="hljs-keyword">if</span> size&amp;<span class="hljs-number">7</span> == <span class="hljs-number">0</span> &#123;
				off = round(off, <span class="hljs-number">8</span>)
			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> size&amp;<span class="hljs-number">3</span> == <span class="hljs-number">0</span> &#123;
				off = round(off, <span class="hljs-number">4</span>)
			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> size&amp;<span class="hljs-number">1</span> == <span class="hljs-number">0</span> &#123;
				off = round(off, <span class="hljs-number">2</span>)
			&#125;
			<span class="hljs-keyword">if</span> off+size &lt;= maxTinySize &amp;&amp; c.tiny != <span class="hljs-number">0</span> &#123;
				<span class="hljs-comment">// The object fits into existing tiny block.</span>
				<span class="hljs-comment">//该对象适合于已有的tinyblock</span>
				x = unsafe.Pointer(c.tiny + off)
				c.tinyoffset = off + size
				c.local_tinyallocs++
				mp.mallocing = <span class="hljs-number">0</span>
				releasem(mp)
				<span class="hljs-keyword">return</span> x
			&#125;
			<span class="hljs-comment">// Allocate a new maxTinySize block.</span>
			span := c.alloc[tinySpanClass]
			v := nextFreeFast(span)
			<span class="hljs-keyword">if</span> v == <span class="hljs-number">0</span> &#123;
				v, _, shouldhelpgc = c.nextFree(tinySpanClass)
			&#125;
			x = unsafe.Pointer(v)
			(*[<span class="hljs-number">2</span>]<span class="hljs-keyword">uint64</span>)(x)[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>
			(*[<span class="hljs-number">2</span>]<span class="hljs-keyword">uint64</span>)(x)[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>
			<span class="hljs-comment">// See if we need to replace the existing tiny block with the new one</span>
			<span class="hljs-comment">// based on amount of remaining free space.</span>
			<span class="hljs-keyword">if</span> size &lt; c.tinyoffset || c.tiny == <span class="hljs-number">0</span> &#123;
				c.tiny = <span class="hljs-keyword">uintptr</span>(x)
				c.tinyoffset = size
			&#125;
			size = maxTinySize
		&#125; <span class="hljs-keyword">else</span> &#123;
			<span class="hljs-comment">//在32KB以内，16B以上的</span>
			<span class="hljs-keyword">var</span> sizeclass <span class="hljs-keyword">uint8</span>
			<span class="hljs-comment">//smallSizeMax = 1024</span>
			<span class="hljs-keyword">if</span> size &lt;= smallSizeMax<span class="hljs-number">-8</span> &#123;
				sizeclass = size_to_class8[(size+smallSizeDiv<span class="hljs-number">-1</span>)/smallSizeDiv]
			&#125; <span class="hljs-keyword">else</span> &#123;
				sizeclass = size_to_class128[(size-smallSizeMax+largeSizeDiv<span class="hljs-number">-1</span>)/largeSizeDiv]
			&#125;
			size = <span class="hljs-keyword">uintptr</span>(class_to_size[sizeclass])
			spc := makeSpanClass(sizeclass, noscan)
			span := c.alloc[spc]
			v := nextFreeFast(span)
			<span class="hljs-keyword">if</span> v == <span class="hljs-number">0</span> &#123;
				v, span, shouldhelpgc = c.nextFree(spc)
			&#125;
			x = unsafe.Pointer(v)
			<span class="hljs-keyword">if</span> needzero &amp;&amp; span.needzero != <span class="hljs-number">0</span> &#123;
				memclrNoHeapPointers(unsafe.Pointer(v), size)
			&#125;
		&#125;
	&#125;<span class="hljs-keyword">else</span>&#123;
		....
	&#125;
	....
&#125;</code></pre></div>
<h4 id="fixalloc">fixAlloc</h4>
<p>因为我们的都知道go分配对象是在go gc heap中，并且由mspan，mcache，mcentral这些结构管理，但是这些结构的对象又是在哪里管理和分配呢？</p>
<p>fixalloc就是做这个的：
前面讲到fixalloc都是mheap中固定的结构</p>
<ul>
<li>主要目的就是一次性分配一大块内存(注意persistentalloc方法，使用是mmap，不指定地址，分配内存不再arena范围内，从进程空间获得可能百来KB)，
每次请求对应的结构体大小，释放时就放在list链表中</li>
</ul>
<p>大概的分配有以下集中</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> mheap <span class="hljs-keyword">struct</span>&#123;
	...
	spanalloc             fixalloc <span class="hljs-comment">// allocator for span*</span>
	cachealloc            fixalloc <span class="hljs-comment">// allocator for mcache*</span>
	treapalloc            fixalloc <span class="hljs-comment">// allocator for treapNodes*</span>
	specialfinalizeralloc fixalloc <span class="hljs-comment">// allocator for specialfinalizer*</span>
	specialprofilealloc   fixalloc <span class="hljs-comment">// allocator for specialprofile*</span>
	speciallock           mutex    <span class="hljs-comment">// lock for special record allocators.</span>
	arenaHintAlloc        fixalloc <span class="hljs-comment">// allocator for arenaHints</span>
	...
&#125;</code></pre></div>
<h4 id="stackcache">stackCache</h4>
<p>在mcache结构上</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// Number of orders that get caching. Order 0 is FixedStack</span>
	<span class="hljs-comment">// and each successive order is twice as large.</span>
	<span class="hljs-comment">// We want to cache 2KB, 4KB, 8KB, and 16KB stacks. Larger stacks</span>
	<span class="hljs-comment">// will be allocated directly.</span>
	<span class="hljs-comment">// Since FixedStack is different on different systems, we</span>
	<span class="hljs-comment">// must vary NumStackOrders to keep the same maximum cached size.</span>
	<span class="hljs-comment">//   OS               | FixedStack | NumStackOrders</span>
	<span class="hljs-comment">//   -----------------+------------+---------------</span>
	<span class="hljs-comment">//   linux/darwin/bsd | 2KB        | 4</span>
	<span class="hljs-comment">//   windows/32       | 4KB        | 3</span>
	<span class="hljs-comment">//   windows/64       | 8KB        | 2</span>
	<span class="hljs-comment">//   plan9            | 4KB        | 3</span>
_NumStackOrders = <span class="hljs-number">4</span> - sys.PtrSize/<span class="hljs-number">4</span>*sys.GoosWindows - <span class="hljs-number">1</span>*sys.GoosPlan9
<span class="hljs-keyword">type</span> mcache <span class="hljs-keyword">struct</span>&#123;
	...
	stackcache [_NumStackOrders]stackfreelist 
	...
&#125;
<span class="hljs-keyword">type</span> stackfreelist <span class="hljs-keyword">struct</span> &#123;
	list gclinkptr <span class="hljs-comment">// linked list of free stacks</span>
	size <span class="hljs-keyword">uintptr</span>   <span class="hljs-comment">// total size of stacks in list</span>
&#125;</code></pre></div>
<p>大概结构<img src="/img/stackCache.png" srcset="/img/loading.gif" alt="如图"></p>
<p>stackCache是per-P的，在另外一篇文章<a href="../goroutine.html">goroutine</a>上讲过，主要用于分配goroutine的stack，同普通内存一样
其分为多个segment，class, linux就分为2KB,4KB,8KB,16KB等级</p>
<p>其中 &gt; 16K的直接从全局stacklarge分配
否则按照先从P的stackcache分配=&gt; 如果无法分配 =&gt; 从全局stackpool分配一批stack(stackpoolalloc)，赋给该p的stackcache，再从local stackcache分配</p>
<h3 id="一些重要参数">一些重要参数</h3>
<ul>
<li>
<p>go_memstats_sys_bytes: 进程从操作系统获得内存的总字节数，包含了go运行的stack，heap还有其他数据结构相关的虚拟地址空间</p>
</li>
<li>
<p>go_memstats_heap_inuse_bytes: 在span中真正被使用的字节数；其中不包括可能已经返回到操作系统，或者可以重用进行对分配、可以将作为堆栈内存重用的字节 (?)</p>
</li>
<li>
<p>go_memstats_heap_idle_bytes: 在span中空闲的字节数;</p>
</li>
<li>
<p>go_memstats_stack_sys_bytes: 栈内存字节数；主要用于goroutine栈内存的分配;</p>
</li>
</ul>
<p>由以上参数结合代码其实可以知道大概span在内存中有几种状态:</p>
<ol>
<li>
<p>idle不包含对象或者其他数据，空闲的物理内存可以释放回OS（虚拟地址不会释放！！！），或者将其转换成inuse状态或者stack span</p>
</li>
<li>
<p>inuse,至少包含一个mheap，并且可能有空闲空间分配更多堆对象</p>
</li>
<li>
<p>stack span，只会在堆或者是栈内存其中之一</p>
</li>
</ol>
<h2 id="内存对齐以及一些分配规则-补充前面的tcmalloc">内存对齐以及一些分配规则(补充前面的tcmalloc)</h2>
<p>runtime/msize.go</p>
<div class="hljs"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">roundupsize</span><span class="hljs-params">(size <span class="hljs-keyword">uintptr</span>)</span> <span class="hljs-title">uintptr</span></span> &#123;
	<span class="hljs-comment">//size&lt;32768</span>
	<span class="hljs-keyword">if</span> size &lt; _MaxSmallSize &#123;
		<span class="hljs-keyword">if</span> size &lt;= smallSizeMax<span class="hljs-number">-8</span> &#123;
			<span class="hljs-comment">//这里面的字段是go对特定class设定的对应大小</span>
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">uintptr</span>(class_to_size[size_to_class8[(size+smallSizeDiv<span class="hljs-number">-1</span>)/smallSizeDiv]])
		&#125; <span class="hljs-keyword">else</span> &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">uintptr</span>(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv<span class="hljs-number">-1</span>)/largeSizeDiv]])
		&#125;
	&#125;
	<span class="hljs-comment">//size为负数,_PageSize=1&lt;&lt;13 </span>
	<span class="hljs-keyword">if</span> size+_PageSize &lt; size &#123;
		<span class="hljs-keyword">return</span> size
	&#125;
	<span class="hljs-keyword">return</span> round(size, _PageSize)
&#125;
<span class="hljs-comment">//该运算在下面会提到</span>
<span class="hljs-comment">// round n up to a multiple of a.  a must be a power of 2.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">round</span><span class="hljs-params">(n, a <span class="hljs-keyword">uintptr</span>)</span> <span class="hljs-title">uintptr</span></span> &#123;
	<span class="hljs-keyword">return</span> (n + a - <span class="hljs-number">1</span>) &amp;^ (a - <span class="hljs-number">1</span>)
&#125;</code></pre></div>
<p>注意到<strong>class_to_size</strong>和<strong>size_to_class</strong>等等字段</p>
<p><a id="sizetoclass">[sizetoclass]</a>
实际上在runtime/sizeclasses.go里面可以体现出go对不同大小的class设置的size：
每个span都带有一个sizeclass，即表明该span的page应该被怎么用；
PS: <strong>可以参照tcmalloc 实现思想基本一直</strong></p>
<blockquote>
<blockquote>
<p>class0表示单独分配一个&gt;32KB对象的span，有67个size，每个size有两种，分配用于有指针和无指针对象，所以有个67*2	= 134个class (即上面提到的numSpanClasses)</p>
</blockquote>
</blockquote>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// class  bytes/obj  bytes/span  objects  tail waste  max waste</span>
<span class="hljs-comment">//     1          8        8192     1024           0     87.50%</span>
<span class="hljs-comment">//     2         16        8192      512           0     43.75%</span>
<span class="hljs-comment">//     3         32        8192      256           0     46.88%</span>
<span class="hljs-comment">//     4         48        8192      170          32     31.52%</span>
<span class="hljs-comment">//     5         64        8192      128           0     23.44%</span>
<span class="hljs-comment">//     6         80        8192      102          32     19.07%</span>
<span class="hljs-comment">//     7         96        8192       85          32     15.95%</span>
<span class="hljs-comment">//     8        112        8192       73          16     13.56%</span>
<span class="hljs-comment">//     9        128        8192       64           0     11.72%</span>
<span class="hljs-comment">//    10        144        8192       56         128     11.82%</span>
<span class="hljs-comment">//    11        160        8192       51          32      9.73%</span>
......
<span class="hljs-comment">//    60      19072       57344        3         128      3.57%</span>
<span class="hljs-comment">//    61      20480       40960        2           0      6.87%</span>
<span class="hljs-comment">//    62      21760       65536        3         256      6.25%</span>
<span class="hljs-comment">//    63      24576       24576        1           0     11.45%</span>
<span class="hljs-comment">//    64      27264       81920        3         128     10.00%</span>
<span class="hljs-comment">//    65      28672       57344        2           0      4.91%</span>
<span class="hljs-comment">//    66      32768       32768        1           0     12.50%</span></code></pre></div>
<p>可以看到bytes/obj一栏，就是go预定义object大小，最小是8B，最大是32KB（注意这里只是在32KB以内，还有大于32KB以外的），所以都可以解释到<strong>slice</strong>在扩容的时候可能会不遵守*2和1.25倍扩容的规则；</p>
<p>相关的main方法可以在classToSize的转换runtime/mksizeclass.go中找到</p>
<h3 id="golang的位运算">golang的位运算</h3>
<p>有时候会经常看见会用一些全局常量：</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">//指针大小,一般64位就是8</span>
<span class="hljs-keyword">const</span> PtrSize = <span class="hljs-number">4</span> &lt;&lt; (^<span class="hljs-keyword">uintptr</span>(<span class="hljs-number">0</span>) &gt;&gt; <span class="hljs-number">63</span>) <span class="hljs-comment">//8</span></code></pre></div>
<p>sys.PtrSize, sys.RegSize等等</p>
<h4 id="1-运算">1. ^运算</h4>
<ul>
<li>用作单目运算时， ^ 指的就是取反,等于一些语言的 ~ 符号（这里注意都一样取补码）</li>
</ul>
<p>ps: 这里复习一下，</p>
<p>正数取反：化为二进制，得到补码(正数补码和原码一样)，再对补码每位取反</p>
<p>负数取反：化为二进制，得到补码(所有除符号位的每位取反，+1)，然后再对补码全部每位取反</p>
<div class="hljs"><pre><code class="hljs go">x:=^<span class="hljs-number">3</span>
<span class="hljs-comment">//3=》 0011=》 1100=-4 </span>
log.Printf(<span class="hljs-string">"%d"</span>,x)<span class="hljs-comment">//-4</span>

x:=^(<span class="hljs-number">-3</span>)
<span class="hljs-comment">//-3=》 1011 =》 1100 =》 1101 =》 0010=2</span>
log.Printf(<span class="hljs-string">"%d"</span>,x)<span class="hljs-comment">//2</span></code></pre></div>
<p>也可以用比较直接的方法：
^a= -(a+1)</p>
<ul>
<li>用作双目运算符时则为异或（XOR）
相同为0，相异为1</li>
</ul>
<h4 id="2-运算">2. &amp;^运算</h4>
<p>将运算符号左边数据相异保留，相同置为0;</p>
<p>符合：</p>
<ul>
<li>右侧为0，左侧数不变，</li>
<li>右侧是1，左侧清零</li>
<li>符合结合法即 a&amp;^b=a&amp;(^b)</li>
</ul>
<p>经常用该符号作内存对齐
如runtime/stubs.go里面</p>
<div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// round n up to a multiple of a.  a must be a power of 2.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">round</span><span class="hljs-params">(n, a <span class="hljs-keyword">uintptr</span>)</span> <span class="hljs-title">uintptr</span></span> &#123;
	<span class="hljs-keyword">return</span> (n + a - <span class="hljs-number">1</span>) &amp;^ (a - <span class="hljs-number">1</span>)
&#125;
<span class="hljs-comment">//可以有这种说法：</span>
<span class="hljs-comment">//找到最大位为１的位数，然后用１左移该位数即是roundup后的结果,</span>
<span class="hljs-comment">//比如6 : 110,最大为为1的是在第三位，1&lt;&lt;3 = 1000 = 8,即十进制的8</span>
<span class="hljs-comment">// n=6,a=2 : 110 =&gt; (6+2-1) = 111 &amp;^ 001 = 110</span></code></pre></div>
<p>runtime/malloc.go</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/golang/">golang</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/02/24/Go/gc/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Golang Garbage Collection</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/02/10/Comcon/consensus/">
                        <span class="hidden-mobile">Consensus</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Golang Memory Allocator&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
